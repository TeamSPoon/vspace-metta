#!/bin/bash

export RPWD=$PWD
IS_SOURCED=$( [[ "${BASH_SOURCE[0]}" != "${0}" ]] && echo 1 || echo 0)
# Function to exit the script properly
exit_script() { [[ "$IS_SOURCED" == "1" ]] && return $1 || exit $1; }
if [ "$IS_SOURCED" -eq "0" ]; then SCRIPT=$(readlink -f "$0"); else SCRIPT=$(readlink -f "${BASH_SOURCE[0]}"); fi
export MeTTa=$(basename "$SCRIPT")
export METTALOG_DIR=$(dirname "$SCRIPT")
#echo "METTALOG_DIR=$METTALOG_DIR"
cd "$METTALOG_DIR" || { echo "Failed to navigate to $METTALOG_DIR"; exit_script 1; }
export TEE_FILE=${TEE_FILE:-"$METTALOG_DIR/TEE.ansi"}

set -e
python_flag=enable

function load_mettalogrc {
    local file="${1:-$HOME/.mettalogrc}"  # Use the argument if supplied, else use the default file
    local METTALOG_OPTIONS=()
    local multiline_accumulator=""
    local verbose="${VERBOSE:-0}"  # Use the VERBOSE environment variable or default to '0' (not verbose)

    if [[ -f "$file" ]]; then
        while IFS= read -r line || [[ -n "$line" ]]; do
            # Trim leading and trailing whitespace
            line="${line#"${line%%[![:space:]]*}"}"
            line="${line%"${line##*[![:space:]]}"}"

            [[ -z "$line" ]] && continue # Skip empty lines

            # Check for line continuation (trailing '\')
            if [[ "$line" =~ \\$ ]]; then
                multiline_accumulator+="${line%\\} "
                continue
            else
                line="$multiline_accumulator$line"
                multiline_accumulator=""
            fi

            [[ $line =~ ^# ]] && continue # Skip lines that start with a comment

            METTALOG_OPTIONS+=("$line")

            # Verbose logging
            [[ "$verbose" == "1" ]] && echo "Loaded option: $line"
        done < "$file"
    else
        [[ "$verbose" == "1" ]] && echo "File $file does not exist."
        return 1
    fi

    # Return the array (in bash, arrays are typically returned by echoing their elements)
    echo "${METTALOG_OPTIONS[@]}"
    return 0
}



add_to_list() {
    local item="$1"
    local -n list_ref="$2"
    if [[ ! " ${list_ref[*]} " =~ " $item " ]]; then
        list_ref+=("$item")
    fi
}

function print_help {
    echo " CMD: $0"
    echo " Usage: $MeTTa [options] <metta-files|directories> ... [-- arg ...passed to your program...]"
    echo "        $MeTTa [options] [-o executable] -c metta-file1 -c metta-file2 ... to compile into executable ..."
    echo "        $MeTTa --help         Display this message"
    echo "        $MeTTa --version      Display version information"
    echo "        $MeTTa --abi-version  Display ABI version key"
    echo "        $MeTTa --arch         Display architecture"
    echo "        $MeTTa --dump-runtime-variables[=format]"
    echo "                        Dump link info in sh(1) format"
    echo ""
    echo "    -x state                 Start from state (must be first)"
    echo "    -g goal                  Run goal (may be repeated)"
    echo "    -t toplevel              Toplevel goal"
    echo "    -f file                  User initialisation file"
    echo "    -F file                  Site initialisation file"
    echo "    -l file                  Script source file"
    echo "    -s file                  Script source file"
    echo "    -p alias=path            Define file search path 'alias'"
    echo "    -O                       Optimised compilation"
    echo "    --on-error=style         One of print, halt or status"
    echo "    --on-warning=style       One of print, halt or status"
    echo "    --tty[=bool]             (Dis)allow tty control"
    echo "    --packs[=bool]           Do (not) attach add-ons"
    echo "    --signals[=bool]         Do (not) modify signal handling"
    echo "    --threads[=bool]         Do (not) allow for threads"
    echo "    --debug[=bool]           Do (not) generate debug info"
    echo "    --debug-on-interrupt[=bool] Trap the debugger on interrupt"
    echo "    --quiet[=bool] (-q)      Do (not) suppress informational messages"
    echo "    --traditional            Disable extensions of version 7"
    echo "    --home[=DIR]             Print home or use DIR as SWI-Prolog home"
    echo "    --stack-limit=size[BKMG] Specify maximum size of Prolog stacks"
    echo "    --table-space=size[BKMG] Specify maximum size of SLG tables"
    echo "    --shared-table-space=size[BKMG] Maximum size of shared SLG tables"
    echo "    --pce[=bool]             Make the xpce gui available"
    echo "    --pldoc[=port]           Start PlDoc server [at port]"
    echo "    --python[=bool]          Enable or disable Python support (default: $python_flag)"
    echo "    --repl                   Start the REPL (Read-Eval-Print Loop) after processing metta files."
    echo "                             If no metta files are provided, this is the default behavior."
    echo "    --timeout=seconds        Kill the script after so many seconds."
    echo "    --html[=bool]            Save an HTML file containing terminal output in the same"
    echo "                             directory as the input file or directory."
    echo "                             Defaults to true if exactly one metta file or directory argument was provided"
    echo ""
    echo " Boolean options may be written as --name=bool, --name, --no-name or --noname."
    echo " Both '-' or '_' are accepted as word-separator for long options."
    echo ""
    echo " Configuration File:"
    echo "    This script reads options from the ~/.mettalogrc file, one option per line."
    echo "    Options specified in ~/.mettalogrc are processed before command-line arguments."
    echo ""
    exit_script 0
}


# Initialize variables
SWI_OPTIONS=()
OTHER_OPTIONS=()
FLAG_WITH_ARG=false
LIST_OF_FILE_ARGS=()
PYSWIP_VERSION="pyswip"

remove_quotes() {
  local value="$1"
  echo "${value//\"/}"
}

function handle_args {
    FLAG_WITH_ARG=false
    for arg in "$@"; do

	arg=$(remove_quotes "$arg")  # Remove the quotes

	if [[ -f "$arg" || -d "$arg" ]]; then
	    arg_realpath="$(realpath "$arg")"
	    if [[ -f "$arg_realpath" || -d "$arg_realpath" ]]; then
	       add_to_list "$arg_realpath" LIST_OF_FILE_ARGS
	    fi
	fi

        [[ "$arg" == "--help" || "$arg" == "-h" ]] && { print_help; exit_script 0; }
        [[ "$arg" =~ ^--dump-runtime-variables.*$ || "$arg" == "--abi-version" || "$arg" == "--version" || "$arg" == "--arch" ]] && { swipl $@; exit_script 0; }

        if [[ "$arg" =~ ^--timeout=([0-9]+)$ ]]; then
            TIMEOUT="${BASH_REMATCH[1]}"
	    echo "$0 TIMEOUT=$TIMEOUT"
	    export TIMEOUT
	    continue
	elif [[ "$arg" =~ ^--python=(enable|false)$ ]]; then
            python_flag="${BASH_REMATCH[1]}"
        elif [[ "$arg" == "--python" ]]; then
            python_flag=enable
        elif [[ "$arg" == "--no-python" ]]; then
            python_flag=false
        elif [[ "$arg" == "--repl" ]]; then
            repl_flag=enable
        elif [[ "$arg" == "--no-repl" ]]; then
            repl_flag=false
        elif [[ "$arg" == "--html" ]]; then
            html_flag=enable
        elif [[ "$arg" == "--no-html" ]]; then
            html_flag=false
        fi


        [[ "$FLAG_WITH_ARG" == true ]] && { SWI_OPTIONS+=("$arg"); FLAG_WITH_ARG=false; continue; }

        # These options require an argument (like a filename)
        case $arg in
            --v1)
                PYSWIP_VERSION="pyswip1"
                continue
                ;;
            --v2)
                PYSWIP_VERSION="pyswip"
                continue
                ;;
            -x|-g|-t|-f|-F|-l|-s|-p|--on-error|--on-warning|--home|--stack-limit|--table-space|--shared-table-space|--pldoc)
                SWI_OPTIONS+=("$arg")
                FLAG_WITH_ARG=true
                continue
                ;;
            # These options don't require an argument
            -O|--traditional|--tty*|--packs*|--signals*|--threads*|--debug*|--debug-on-interrupt*|--quiet*|--pce*)
                SWI_OPTIONS+=("$arg")
                continue
                ;;
            *)
		if [[ -f "$arg" || -d "$arg" ]]; then
		    arg_realpath="$(realpath "$arg")"
		    if [[ -f "$arg_realpath" || -d "$arg_realpath" ]]; then
		       add_to_list "$arg_realpath" LIST_OF_FILE_ARGS
		    fi
		else
		    add_to_list "$arg" OTHER_OPTIONS
		fi
                ;;
        esac
    done
}

# First process arguments from ~/.mettalogrc
handle_args $(load_mettalogrc)
# Then process actual command-line arguments
handle_args "$@"
#echo "LIST_OF_FILE_ARGS[0]=${LIST_OF_FILE_ARGS[0]}"
DIRNAME=$(dirname "${LIST_OF_FILE_ARGS[0]}")
DIR_RC="$DIRNAME/.mettalogrc"
#echo "DIR_RC=$DIR_RC"
if [[ -f "$DIR_RC" ]]; then
    DIR_OPTS=$(load_mettalogrc "$DIR_RC")
    echo "DIR_RC($DIR_RC)='$DIR_OPTS'"
    # Assuming DIR_OPTS contains options and not filenames.
    # So we directly handle them as arguments.
    if [[ ! -z "$DIR_OPTS" ]]; then
	handle_args $DIR_OPTS
    fi
else
    echo "No RC file (.mettalogrc) for directory: $DIRNAME"
fi


#echo "Debug: SWI_OPTIONS: ${SWI_OPTIONS[@]}"
#echo "Debug: LIST_OF_FILE_ARGS: ${LIST_OF_FILE_ARGS[@]}"
#echo "Debug: OTHER_OPTIONS: ${OTHER_OPTIONS[@]}"

# Decide on enabling the REPL
if [[ -z "$repl_flag" ]]; then
  [[ ${#LIST_OF_FILE_ARGS[@]} -eq 0 ]] && repl_flag=enable || repl_flag=false
fi


# Add metta_vspace to PYTHONPATH if not already present
[[ ":$PYTHONPATH:" != *":$METTALOG_DIR/metta_vspace:"* ]] && export PYTHONPATH="${PYTHONPATH:+${PYTHONPATH}:}$METTALOG_DIR/metta_vspace"
export RUST_BACKTRACE=full

if [[ -f "$METTALOG_DIR/MeTTaLog" ]]; then
  MLOG="$METTALOG_DIR/MeTTaLog"
else
  MLOG="swipl ${SWI_OPTIONS[*]} -l $METTALOG_DIR/metta_vspace/$PYSWIP_VERSION/metta_interp.pl"
fi

METTA_CMD="$MLOG -- --python=$python_flag ${LIST_OF_FILE_ARGS[*]} --repl=$repl_flag --args ${OTHER_OPTIONS[*]}"

if [[ -n "$TIMEOUT" && "$TIMEOUT" -gt 0 ]]; then
    METTA_CMD="timeout --foreground --preserve-status --signal=SIGTERM --kill-after=5s $TIMEOUT ${METTA_CMD}"
fi


#echo "METTA_CMD=\"$METTA_CMD\""

# Conditional to check if html_flag is enabled
if [[ "enable" == "enable" ]]; then

    export TEE_FILE=${TEE_FILE:-"$METTALOG_DIR/TEE.ansi"}
    touch "$TEE_FILE"
    chmod 777 "$TEE_FILE"
    cat /dev/null > "$TEE_FILE"

    #[ -z "$TYPESCRIPT" ] && TYPESCRIPT=1 /usr/bin/script -f --force -e -a "$TEE_FILE" -c "TYPESCRIPT=1 $METTA_CMD"

    ( export TYPESCRIPT=1
      /usr/bin/script -q -f --force -e -a "$TEE_FILE" -c "$METTA_CMD" ) || true
    stty sane

    # MeTTa write the html file now
    if [[ "notenable" == "enable" ]]; then


	BASENAME=$(basename "${LIST_OF_FILE_ARGS[0]}")

	# Remove extension if it's a file
	[[ -f "${LIST_OF_FILE_ARGS[0]}" ]] && BASENAME=${BASENAME%.*}

	if command -v ansi2html >/dev/null 2>&1; then
	    ansi2html < "$TEE_FILE" > "$DIRNAME/$BASENAME.html"
	    #echo "Output saved to $DIRNAME/$BASENAME.html"
	else
	    echo ""
	    echo "ansi2html command not found. HTML output will not be generated."
	fi

    fi
    exit_script 0
fi

(eval $METTA_CMD) || true
stty sane







