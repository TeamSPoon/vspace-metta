#!/bin/bash

export RPWD=$PWD
IS_SOURCED=$( [[ "${BASH_SOURCE[0]}" != "${0}" ]] && echo 1 || echo 0)
# Function to exit the script properly
if [ "$IS_SOURCED" -eq "0" ]; then SCRIPT=$(readlink -f "$0"); else SCRIPT=$(readlink -f "${BASH_SOURCE[0]}"); fi
export MeTTa=$(basename "$SCRIPT")
export METTALOG_DIR=$(dirname "$SCRIPT")
#echo "METTALOG_DIR=$METTALOG_DIR"
cd "$METTALOG_DIR" || { echo "Failed to navigate to $METTALOG_DIR"; [[ "$IS_SOURCED" == "1" ]] && return 1 || exit 1; }
export TEE_FILE=${TEE_FILE:-"$METTALOG_DIR/TEE.ansi"}

set -e

function load_mettalogrc {
    local file="${1:-$HOME/.mettalogrc}"  # Use the argument if supplied, else use the default file
    local METTALOG_OPTIONS=()
    local multiline_accumulator=""
    local verbose="${VERBOSE:-0}"  # Use the VERBOSE environment variable or default to '0' (not verbose)

    if [[ -f "$file" ]]; then
        while IFS= read -r line || [[ -n "$line" ]]; do
            # Trim leading and trailing whitespace
            line="${line#"${line%%[![:space:]]*}"}"
            line="${line%"${line##*[![:space:]]}"}"

            [[ -z "$line" ]] && continue # Skip empty lines

            # Check for line continuation (trailing '\')
            if [[ "$line" =~ \\$ ]]; then
                multiline_accumulator+="${line%\\} "
                continue
            else
                line="$multiline_accumulator$line"
                multiline_accumulator=""
            fi

            [[ $line =~ ^# ]] && continue # Skip lines that start with a comment

            METTALOG_OPTIONS+=("$line")

            # Verbose logging
            [[ "$verbose" == "1" ]] && echo "Loaded option: $line"
        done < "$file"
    else
        [[ "$verbose" == "1" ]] && echo "File $file does not exist."
        return 1
    fi

    # Return the array (in bash, arrays are typically returned by echoing their elements)
    echo "${METTALOG_OPTIONS[@]}"
    return 0
}



add_to_list() {
    local item="$1"
    local -n list_ref="$2"
    if [[ ! " ${list_ref[*]} " =~ " $item " ]]; then
        list_ref+=("$item")
    fi
}

function print_help {
    echo " CMD: $0"
    echo " Usage: $MeTTa [options] <metta-files|directories> ... [-- arg ...passed to your program...]"
    echo "        $MeTTa [options] [-o executable] -c metta-file1 -c metta-file2 ... to compile into executable ..."
    echo "        $MeTTa --help         Display this message"
    echo "        $MeTTa --version      Display version information"
    echo "        $MeTTa --abi-version  Display ABI version key"
    echo "        $MeTTa --arch         Display architecture"
    echo "        $MeTTa --dump-runtime-variables[=format]"
    echo "                        Dump link info in sh(1) format"
    echo ""
    echo "    -x state                 Start from state (must be first)"
    echo "    -g goal                  Run goal (may be repeated)"
    echo "    -t toplevel              Toplevel goal"
    echo "    -f file                  User initialisation file"
    echo "    -F file                  Site initialisation file"
    echo "    -l file                  Script source file"
    echo "    -s file                  Script source file"
    echo "    -p alias=path            Define file search path 'alias'"
    echo "    -O                       Optimised compilation"
    echo "    --on-error=style         One of print, halt or status"
    echo "    --on-warning=style       One of print, halt or status"
    echo "    --tty[=bool]             (Dis)allow tty control"
    echo "    --packs[=bool]           Do (not) attach add-ons"
    echo "    --signals[=bool]         Do (not) modify signal handling"
    echo "    --threads[=bool]         Do (not) allow for threads"
    echo "    --debug[=bool]           Do (not) generate debug info"
    echo "    --debug-on-interrupt[=bool] Trap the debugger on interrupt"
    echo "    --quiet[=bool] (-q)      Do (not) suppress informational messages"
    echo "    --traditional            Disable extensions of version 7"
    echo "    --home[=DIR]             Print home or use DIR as SWI-Prolog home"
    echo "    --stack-limit=size[BKMG] Specify maximum size of Prolog stacks"
    echo "    --table-space=size[BKMG] Specify maximum size of SLG tables"
    echo "    --shared-table-space=size[BKMG] Maximum size of shared SLG tables"
    echo "    --pce[=bool]             Make the xpce gui available"
    echo "    --pldoc[=port]           Start PlDoc server [at port]"
    echo "    --python[=bool]          Enable or disable Python support (default: $python_flag)"
    echo "    --repl                   Start the REPL (Read-Eval-Print Loop) after processing metta files."
    echo "                             If no metta files are provided, this is the default behavior."
    echo "    --timeout=seconds        Kill the script after so many seconds."
    echo "    --html[=bool]            Save an HTML file containing terminal output in the same"
    echo "                             directory as the input file or directory."
    echo "                             Defaults to true if exactly one metta file or directory argument was provided"
    echo ""
    echo " Boolean options may be written as --name=bool, --name, --no-name or --noname."
    echo " Both '-' or '_' are accepted as word-separator for long options."
    echo ""
    echo " Configuration File:"
    echo "    This script reads options from the ~/.mettalogrc file, one option per line."
    echo "    Options specified in ~/.mettalogrc are processed before command-line arguments."
    echo ""
}


# Initialize variables
SWI_OPTIONS=()
OTHER_OPTIONS=()
FLAG_WITH_ARG=false
python_flag=enable
LIST_OF_FILE_ARGS=()
PYSWIP_VERSION="pyswip"



remove_quotes() {
  local value="$1"
  echo "${value//\"/}"
}

function handle_args {
    FLAG_WITH_ARG=false
    SKIP_TO_OTHER_OPTIONS=false

    for arg in "$@"; do
        arg=$(remove_quotes "$arg")  # Remove the quotes

        if [[ -f "$arg" || -d "$arg" ]]; then
            arg_realpath="$(realpath "$arg")"
            if [[ -f "$arg_realpath" || -d "$arg_realpath" ]]; then
                add_to_list "$arg_realpath" LIST_OF_FILE_ARGS
            fi
        fi

        if [[ $SKIP_TO_OTHER_OPTIONS == true ]]; then
            add_to_list "$arg" OTHER_OPTIONS
            continue
        fi

        if [[ "$arg" == "--" ]]; then
            SKIP_TO_OTHER_OPTIONS=true
            continue
        fi

        [[ "$arg" == "--help" || "$arg" == "-h" ]] && { print_help; EXIT_SCRIPT=0; }
        [[ "$arg" =~ ^--dump-runtime-variables.*$ || "$arg" == "--abi-version" || "$arg" == "--version" || "$arg" == "--arch" ]] && { swipl $@; EXIT_SCRIPT=0; }

        if [[ "$arg" =~ ^--timeout=([0-9]+)$ ]]; then
            TIMEOUT="${BASH_REMATCH[1]}"
	    echo "$0 TIMEOUT=$TIMEOUT"
	    export TIMEOUT
	    continue
	elif [[ "$arg" =~ ^--python=(enable|false)$ ]]; then
            python_flag="${BASH_REMATCH[1]}"
        elif [[ "$arg" == "--python" ]]; then
            python_flag=enable
        elif [[ "$arg" == "--no-python" ]]; then
            python_flag=false
        elif [[ "$arg" == "--repl" ]]; then
            repl_flag=enable
        elif [[ "$arg" == "--no-repl" ]]; then
            repl_flag=false
        elif [[ "$arg" == "--html" ]]; then
            html_flag=enable
        elif [[ "$arg" == "--no-html" ]]; then
            html_flag=false
        fi


        [[ "$FLAG_WITH_ARG" == true ]] && { SWI_OPTIONS+=("$arg"); FLAG_WITH_ARG=false; continue; }

        # These options require an argument (like a filename)
        case $arg in
            --v1)
                PYSWIP_VERSION="pyswip1"
                continue
                ;;
            --v2)
                PYSWIP_VERSION="pyswip2"
                continue
                ;;
            -x|-g|-t|-f|-F|-l|-s|-p|--on-error|--on-warning|--home|--stack-limit|--table-space|--shared-table-space|--pldoc)
                SWI_OPTIONS+=("$arg")
                FLAG_WITH_ARG=true
                continue
                ;;
            # These options don't require an argument
            -O|--traditional|--tty*|--packs*|--signals*|--threads*|--debug*|--debug-on-interrupt*|--quiet*|--pce*)
                SWI_OPTIONS+=("$arg")
                continue
                ;;
            *)
		if [[ -f "$arg" || -d "$arg" ]]; then
		    arg_realpath="$(realpath "$arg")"
		    if [[ -f "$arg_realpath" || -d "$arg_realpath" ]]; then
		       add_to_list "$arg_realpath" LIST_OF_FILE_ARGS
		    fi
		    add_to_list "$arg" OTHER_OPTIONS
		else
		    add_to_list "$arg" OTHER_OPTIONS
		fi
                ;;
        esac
    done
}

# First process arguments from ~/.mettalogrc
handle_args $(load_mettalogrc)
# Then process actual command-line arguments
handle_args "$@"
#echo "LIST_OF_FILE_ARGS[0]=${LIST_OF_FILE_ARGS[0]}"
DIRNAME="${LIST_OF_FILE_ARGS[0]}"
if [[ -f "$DIRNAME" ]]; then
  DIRNAME=$(dirname "${DIRNAME}")
elif [[ -d "$DIRNAME" ]]; then
  exec ./scripts/test_in_metta.sh -y $@
  [[ "$IS_SOURCED" == "1" ]] && return $RVAL || exit $RVAL
else
  handle_args --repl
fi
DIR_RC="$DIRNAME/.mettalogrc"
#echo "DIR_RC=$DIR_RC"
if [[ -f "$DIR_RC" ]]; then
    DIR_OPTS=$(load_mettalogrc "$DIR_RC")
    echo "DIR_RC($DIR_RC)='$DIR_OPTS'"
    # Assuming DIR_OPTS contains options and not filenames.
    # So we directly handle them as arguments.
    if [[ ! -z "$DIR_OPTS" ]]; then
	handle_args $DIR_OPTS
    fi
else
    echo "No RC file (.mettalogrc) for directory: $DIRNAME"
fi

# Then process actual command-line arguments
handle_args "$@"
if [[ ! -z "$DIR_OPTS" ]]; then
    handle_args $DIR_OPTS
fi

if [ -z "${EXIT_SCRIPT+x}" ]; then
    :
else
    [[ "$IS_SOURCED" == "1" ]] && return "$EXIT_SCRIPT" || exit "$EXIT_SCRIPT"
fi


#echo "Debug: SWI_OPTIONS: ${SWI_OPTIONS[@]}"
#echo "Debug: LIST_OF_FILE_ARGS: ${LIST_OF_FILE_ARGS[@]}"
#echo "Debug: OTHER_OPTIONS: ${OTHER_OPTIONS[@]}"

# Decide on enabling the REPL
if [[ -z "$repl_flag" ]]; then
  [[ ${#LIST_OF_FILE_ARGS[@]} -eq 0 ]] && repl_flag=enable || repl_flag=false
fi

# Store the initial PYTHONPATH for later comparison
initial_pythonpath="$PYTHONPATH"

# Add DIRNAME to PYTHONPATH if it's a valid path and not already present
if [[ -d "$DIRNAME" && ":$PYTHONPATH:" != *":$DIRNAME:"* ]]; then
    export PYTHONPATH="${PYTHONPATH:+${PYTHONPATH}:}$DIRNAME"
fi

# Add metta_vspace to PYTHONPATH if not already present
[[ ":$PYTHONPATH:" != *":$METTALOG_DIR/metta_vspace:"* ]] && export PYTHONPATH="${PYTHONPATH:+${PYTHONPATH}:}$METTALOG_DIR/metta_vspace"

# If PYTHONPATH has changed, echo the new value
if [[ "$PYTHONPATH" != "$initial_pythonpath" ]]; then
    echo ";; Updated PYTHONPATH: $PYTHONPATH"
fi

export RUST_BACKTRACE=full



# Directory containing the .pl files
pl_directory="metta_vspace/pyswip"

# Initialize a flag to check if any file is newer or if reference file is missing
should_compile=0

# Reference file
reference_file=$(find . -maxdepth 1 -type f -name "Sav.MeTTaLog*" -not -name "*.*" -printf "%T@ %p\n" | sort -k1,1nr | head -n 1 | cut -f2- -d" ")
if [[ -z "$reference_file" ]]; then
  reference_file="Sav.MeTTaLog"
fi

# Check if Sav.MeTTaLog exists
if [[ ! -e "$reference_file" ]]; then
    echo "Reference file $reference_file does not exist. Compiler will be called."
    should_compile=1
else
    # Iterate over each .pl file to check if it's newer
    for pl_file in "$pl_directory"/*_*.pl; do
        if [[ ! -e "$pl_file" ]]; then
            echo "No matching .pl files found in $pl_directory."
            #exit 1
        fi

        # Check if this .pl file is newer than the reference file
        if [[ "$pl_file" -nt "$reference_file" ]]; then
            echo "$pl_file is newer than $reference_file."
            should_compile=1
            break  # No need to check further, exit loop
        fi
    done
fi


# If any newer file found or reference file missing, call the compiler
if [[ $should_compile -eq 1 ]]; then
    if [[ -f "$reference_file" ]]; then
        echo "Calling compiler from $reference_file..."
	swipl -x $reference_file -g qsave_program -g halt
    else
        echo "Calling compiler..."
	swipl -l metta_vspace/pyswip/metta_interp.pl -g qcompile_mettalog
    fi
fi

reference_file=$(find . -maxdepth 1 -type f -name "Sav.MeTTaLog*" -not -name "*.*" -printf "%T@ %p\n" | sort -k1,1nr | head -n 1 | cut -f2- -d" ")
if [[ -z "$reference_file" ]]; then
  reference_file="Sav.MeTTaLog"
fi

if [[ -f "$reference_file" ]]; then
  MLOG="$reference_file"
  #MLOG="swipl -x $reference_file"
else
  MLOG="swipl ${SWI_OPTIONS[*]} -l $METTALOG_DIR/metta_vspace/$PYSWIP_VERSION/metta_interp.pl --"
fi

MLOG="swipl ${SWI_OPTIONS[*]} -l $METTALOG_DIR/metta_vspace/$PYSWIP_VERSION/metta_interp.pl --"

METTA_CMD="$MLOG --python=$python_flag ${OTHER_OPTIONS[*]}"

OS=$(uname)
TIMEOUT_CMD="timeout"

if [[ "$OS" == "Darwin" ]]; then
    # macOS
    if command -v gtimeout >/dev/null 2>&1; then
        TIMEOUT_CMD="gtimeout"
    else
        echo "Please install coreutils using Homebrew to get the gtimeout command."
        [[ "$IS_SOURCED" == "1" ]] && return 1 || exit 1
    fi
fi

if [[ -n "$TIMEOUT" && "$TIMEOUT" -gt 0 ]]; then
    METTA_CMD="$TIMEOUT_CMD --foreground --preserve-status --signal=SIGTERM --kill-after=5s $TIMEOUT ${METTA_CMD}"
fi

# Conditional to check if html_flag is enabled
if [[ "$html_flag" == "enable" ]]; then
    export TEE_FILE=${TEE_FILE:-"$METTALOG_DIR/TEE.ansi"}
    touch "$TEE_FILE"
    chmod 777 "$TEE_FILE"
    cat /dev/null > "$TEE_FILE"

    ( export TYPESCRIPT=1

	if [[ "$OS" == "Darwin" ]]; then
	    # macOS
	    /usr/bin/script -q -f -a "$TEE_FILE" "$METTA_CMD"
	else
	    # Assume Linux
	    /usr/bin/script -q -f --force -e -a "$TEE_FILE" -c "$METTA_CMD"
	fi

    ) || true
    stty sane
else
  (eval $METTA_CMD) || true
   stty sane
fi


