<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>
<style type="text/css">
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi31 { color: #aa0000; }
.ansi33 { color: #aa5500; }
.ansi36 { color: #00aaaa; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content">
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Higher-order functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Type definition for `curry` function
(: curry (-&gt; (-&gt; $a $b $c) (-&gt; $a (-&gt; $b $c))))
; A trick to define `curry` in MeTTa without `lambda`
(= (((curry $f) $x) $y) ($f $x $y))

; Type checks
!(assertEqual
  (get-type (curry +))
  (-&gt; Number (-&gt; Number Number)))
!(assertEqual
  (get-type ((curry +) 2))
  (-&gt; Number Number))

; Partial application is not reduced, basically
!(assertEqualToResult
   ((curry +) 2)
  (((curry +) 2)))
; Full application will be reduced
!(assertEqual
  (((curry +) 2) 3)
  5)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Curry with first application
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Definitions
(: curry-a (-&gt; (-&gt; $a $b $c) $a (-&gt; $b $c)))
(= ((curry-a $f $a) $b) ($f $a $b))

; Tests
!(assertEqual
  (get-type (curry-a + 2))
  (-&gt; Number Number))
!(assertEqual
  (get-type ((curry-a + 2) 3))
  Number)
; Badly typed
!(assertEqualToResult
  (get-type ((curry-a + 2) "S"))
  ())
; Full application works
!(assertEqual
  ((curry-a + 2) 3)
  5)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; More tests with partial application wrapping
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Definitions
(: Socrates Entity)
(: Human Entity)
(: is (-&gt; Entity Entity Bool))
; Facts
(= (is Socrates Human) True)
(= (is-socrates) (curry-a is Socrates))

; Tests
!(assertEqualToResult
  (is-socrates)
  ((curry-a is Socrates)))
; not reduced
!(assertEqual
  ((curry-a is Socrates) Human)
  (is Socrates Human))
; reduced
!(assertEqual
  ((is-socrates) Human)
  True)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; The same trick works for defining lambda
; (basically, `lambda` is curried `let`)
; FIXME: how to make parameterized type here?
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Definitions
(: lambda (-&gt; Atom $t (-&gt; $a $t)))
(= ((lambda $var $body) $arg)
   (let $var $arg $body))

; Tests
!(assertEqual
  ((lambda $x (+ $x 1)) 2)
  3)
!(assertEqual
  ((lambda ($x $y) (+ $x $y)) (2 7))
  9)

; Another example
(= (part-appl $f $x)
   (lambda $y ($f $x $y)))
(= (inc) (part-appl + 1))
!(assertEqual
  ((inc) 5)
  6)
; REM:
;   (get-type (lambda ($x $y) (+ $x $y)))
; returns (-&gt; %Undefined% Number), because the type of `($x $y)` is not defined.
; It is also not clear how to check that the type of `$var` is suitable for `$body`
; (it should somehow be done on`let` side)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Let's introduce some functors
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(: Maybe (-&gt; $t Type))
(: Nothing (-&gt; (Maybe $t)))
(: Something (-&gt; $t (Maybe $t)))

(: Either (-&gt; $t Type))
(: Left (-&gt; $t (Either $t)))
(: Right (-&gt; $t (Either $t)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; We can implement a generic `fmap`, but it requires
; concrete patterns in the type constructors above
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Instead, we implement `fmap` as:
(: fmap (-&gt; (-&gt; $a $b) ($F $a) ($F $b)))
; Mapping over empty functor, returns empty functor
(= (fmap $f ($C0))
  ($C0))
; Inductive case for singleton functor: apply $f to the
; element and rewrap in $C.
(= (fmap $f ($C $x))
  ($C ($f $x)))
; Inductive case for non-empty functor: apply to the
; head and recurse on the tail.
(= (fmap $f ($C $x $xs))
  ($C ($f $x) (fmap $f $xs)))

; NOTE: We had to define `Nothing` as a functional constructor.
;       Otherwise, we'd have to define `(= (fmap $f $C0) $C0)`,
;       and `$C0` would match both `Nothing` and `(Something 2)`
; TODO? This could be avoided if we could indicate that $C0
;       is a `Symbol` (not `Expression` or `Atom` in general)

; Tests
!(assertEqual
  (fmap (curry-a + 2) (Something 5))
  (Something 7))
!(assertEqual
  (fmap (curry-a + 2) (Nothing))
  (Nothing))

; Type inference works
!(assertEqual
  (get-type (fmap (curry-a + 1) (Left 5)))
  (Either Number))

; It works for untyped constructors as well, if they
; follow the patterns in `fmap` equalities
!(assertEqual
  (fmap (curry-a + 2) (UntypedC 5))
  (UntypedC 7))
!(assertEqual
  (fmap (curry-a + 2) (UntypedC 5 (UntypedC 8 (Null))))
  (UntypedC 7 (UntypedC 10 (Null))))

; Type mismatches are detected:
!(assertEqualToResult
  (get-type (fmap (curry-a + 2) (Left "5")))
  ())
!(assertEqualToResult
  (get-type (fmap (curry-a + 2) (UntypedC "5")))
  ())
!(assertEqualToResult
  (get-type (fmap (curry-a + 2) (UntypedC (Null) 5)))
  ())

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; It is possible to implement `fmap` only as an interface
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Type definition is the same as `fmap` above
(: fmap-i (-&gt; (-&gt; $a $b) ($F $a) ($F $b)))
; Custom implementations for different functors will be
; possible (and needed):
(= (fmap-i $f (Left $x)) (Left ($f $x)))
(= (fmap-i $f (Right $x)) (Right ($f $x)))
!(assertEqual
  (fmap-i (curry-a - 7) (Right 3))
  (Right 4))

; More examples
(: List (-&gt; $a Type))
(: Nil (List $a))
(: Cons (-&gt; $a (List $a) (List $a)))
(= (fmap-i $f Nil) Nil)
(= (fmap-i $f (Cons $x $xs))
   (Cons ($f $x) (fmap-i $f $xs)))
!(assertEqual
  (fmap-i (curry-a * 2) (Cons 3 (Cons 4 Nil)))
  (Cons 6 (Cons 8 Nil)))

; Thus, there is no problem in having different implementations
; of the same function for different types. But it will not
; work "for free" (it requires explicit implementation for each type)
!(assertEqualToResult
   (fmap-i (curry-a + 2) (Untyped 5))
  ((fmap-i (curry-a + 2) (Untyped 5))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; As per issue
;
; https://github.com/trueagi-io/hyperon-experimental/issues/104
;
; Test if adding type declaration to List data structure does
; not interfere with executing functions operating on List.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Insert an element in a presumably sorted list
(= (insert $x Nil) (Cons $x Nil))
(= (insert $x (Cons $head $tail))
  (case (&lt; $x $head)
      ((True  (Cons $x (Cons $head $tail)))
       (False (Cons $head (insert $x $tail))))))

; Sort a list
(= (sort Nil) Nil)
(= (sort (Cons $head $tail)) (insert $head (sort $tail)))
!(assertEqual
  (insert 3 (insert 2 (insert 1 Nil)))
  (Cons 1 (Cons 2 (Cons 3 Nil))))
!(assertEqual
  (sort (Cons 3 (Cons 1 (Cons 2 Nil))))
  (Cons 1 (Cons 2 (Cons 3 Nil))))
BCMD=export TEE_FILE='/mnt/ffff/metta-vspace/tee.ansi' ; cd /mnt/ffff/metta-vspace ; exec swipl -l metta_vspace/pyswip/metta_interp.pl examples/compat/test_scripts/d2_higherfunc.metta -- -- --args examples/compat/test_scripts/d2_higherfunc.metta
% init_phase(after_load).
% dot_cfg:using_dot_type(core,user)
add_history1(list_column_names)
add_history1(setup_flybase_cols)
add_history1(pmt)
add_history1(save_value_symbol_cols)
add_history1(is_swipl)
add_history1(mine_args_that_need_reduced)
add_history1(print_est_sizes)
add_history1(print_loaded_from_files)
add_history1(load_flybase_chado)
add_history1(load_obo_files)
add_history1(load_flybase_obo_files)
add_history1(load_fbase_after_17)
add_history1(load_flybase_files_ftp)
add_history1(load_flybase_das_11)
add_history1(load_flybase_files)
add_history1(load_flybase_dirs)
add_history1(load_flybase)
add_history1(recount_total_loaded_symbols)
add_history1(gc_now)
add_history1(cleanup_arities)
add_history1(should_sample)
add_history1(should_fix_args)
add_history1(reached_file_max)
add_history1(should_cache)
add_history1(try_overlaps)
add_history1(mine_unif_overlap)
add_history1(mine_symbolspace_overlaps)
add_history1(mine_typelevel_overlaps)
add_history1(mine_overlaps2_slow)
add_history1(mine_overlaps1)
add_history1(mine_overlaps)
add_history1(fb_stats)
 
(track_load_into_file  "examples/compat/test_scripts/d2_higherfunc.metta")
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;; Higher-order functions
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;; Type definition for `curry` function

(metta_arity  &amp;self curry 2)
(metta_params  &amp;self curry 
 ((-&gt; $A $B $C) 
  (-&gt; $A 
   (-&gt; $B $C))))
(metta_last  &amp;self curry C)
%; A trick to define `curry` in MeTTa without `lambda`

(metta_head  &amp;self 
 ((curry $F) $X) 
 ($Y))
(metta_defn  &amp;self 
 (((curry $F) $X) $Y) 
 ($F $X $Y))
(metta_body  &amp;self $F 
 ($X $Y))
%; Type checks

(:-  
 (metta_eval  
  (assertEqual 
   (get-type 
    (curry +)) 
   (-&gt; Number 
    (-&gt; Number Number)))))<span class="ansi31">

(loonit_failure  
 (=@=  () 
  ((-&gt; Number 
    (-&gt; Number Number)))))
</span><span class="ansi33"> % 'False'

</span>
(:-  
 (metta_eval  
  (assertEqual 
   (get-type 
    ((curry +) 2)) 
   (-&gt; Number Number))))<span class="ansi31">

(loonit_failure  
 (=@=  () 
  ((-&gt; Number Number))))
</span><span class="ansi33"> % 'False'

</span>%; Partial application is not reduced, basically

(:-  
 (metta_eval  
  (assertEqualToResult 
   ((curry +) 2) 
   (((curry +) 2)))))<span class="ansi36">

(loonit_success  
 (=@=  
  (((curry +) 2)) 
  (((curry +) 2))))
</span><span class="ansi33"> % 'True'

</span>%; Full application will be reduced

(:-  
 (metta_eval  
  (assertEqual 
   (((curry +) 2) 3) 5)))<span class="ansi31">

(loonit_failure  
 (=@=  
  (5 
   (((curry +) 2) 3)) 
  (5)))
</span><span class="ansi33"> % 'False'

</span>%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; Curry with first application
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; Definitions

(metta_arity  &amp;self curry-a 3)
(metta_params  &amp;self curry-a 
 ((-&gt; $A $B $C) $A 
  (-&gt; $B $C)))
(metta_last  &amp;self curry-a C)
(metta_head  &amp;self 
 (curry-a $F $A) 
 ($B))
(metta_defn  &amp;self 
 ((curry-a $F $A) $B) 
 ($F $A $B))
(metta_body  &amp;self $F 
 ($A $B))
%; Tests

(:-  
 (metta_eval  
  (assertEqual 
   (get-type 
    (curry-a + 2)) 
   (-&gt; Number Number))))<span class="ansi31">

(loonit_failure  
 (=@=  () 
  ((-&gt; Number Number))))
</span><span class="ansi33"> % 'False'

</span>
(:-  
 (metta_eval  
  (assertEqual 
   (get-type 
    ((curry-a + 2) 3)) Number)))<span class="ansi31">

(loonit_failure  
 (=@=  () 
  (Number)))
</span><span class="ansi33"> % 'False'

</span>%; Badly typed

(:-  
 (metta_eval  
  (assertEqualToResult 
   (get-type 
    ((curry-a + 2) 
     ($STRING  "S"))) ())))<span class="ansi36">

(loonit_success  
 (=@=  () ()))
</span><span class="ansi33"> % 'True'

</span>%; Full application works

(:-  
 (metta_eval  
  (assertEqual 
   ((curry-a + 2) 3) 5)))<span class="ansi31">

(loonit_failure  
 (=@=  
  (5 
   ((curry-a + 2) 3)) 
  (5)))
</span><span class="ansi33"> % 'False'

</span>%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; More tests with partial application wrapping
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; Definitions

(metta_arity  &amp;self Socrates 0)
(metta_head  &amp;self : 
 (Socrates Entity))
(metta_atom  &amp;self 
 (: Socrates Entity))
(metta_arity  &amp;self Human 0)
(metta_head  &amp;self : 
 (Human Entity))
(metta_atom  &amp;self 
 (: Human Entity))
(metta_arity  &amp;self is 3)
(metta_params  &amp;self is 
 (Entity Entity Bool))
(metta_last  &amp;self is Bool)
%; Facts

(metta_head  &amp;self is 
 (Socrates Human))
(metta_atom  &amp;self 
 (is Socrates Human))
(metta_head  &amp;self is-socrates ())
(metta_defn  &amp;self 
 (is-socrates) 
 (curry-a is Socrates))
(metta_body  &amp;self curry-a 
 (is Socrates))
%; Tests

(:-  
 (metta_eval  
  (assertEqualToResult 
   (is-socrates) 
   ((curry-a is Socrates)))))<span class="ansi31">

(loonit_failure  
 (=@=  
  ((is-socrates)) 
  ((curry-a is Socrates))))
</span><span class="ansi33"> % 'False'

</span>%; not reduced

(:-  
 (metta_eval  
  (assertEqual 
   ((curry-a is Socrates) Human) 
   (is Socrates Human))))<span class="ansi31">

(loonit_failure  
 (=@=  
  (True 
   (is Socrates Human) 
   ((curry-a is Socrates) Human)) 
  (True 
   (is Socrates Human))))
</span><span class="ansi33"> % 'False'

</span>%; reduced

(:-  
 (metta_eval  
  (assertEqual 
   ((is-socrates) Human) True)))<span class="ansi31">

(loonit_failure  
 (=@=  
  (((is-socrates) Human)) 
  (True)))
</span><span class="ansi33"> % 'False'

</span>%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; The same trick works for defining lambda
%; (basically, `lambda` is curried `let`)
%; FIXME: how to make parameterized type here?
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; Definitions

(metta_arity  &amp;self lambda 3)
(metta_params  &amp;self lambda 
 (Atom $T 
  (-&gt; $A $T)))
(metta_last  &amp;self lambda T)
(metta_head  &amp;self 
 (lambda $Var $Body) 
 ($Arg))
(metta_defn  &amp;self 
 ((lambda $Var $Body) $Arg) 
 (let $Var $Arg $Body))
(metta_body  &amp;self let 
 ($Var $Arg $Body))
%; Tests

(:-  
 (metta_eval  
  (assertEqual 
   ((lambda $X 
     (+ $X 1)) 2) 3)))<span class="ansi31">

(loonit_failure  
 (=@=  
  (3 
   ((lambda $_132204 
     (+ $_132204 1)) 2)) 
  (3)))
</span><span class="ansi33"> % 'False'

</span>
(:-  
 (metta_eval  
  (assertEqual 
   ((lambda 
     ($X $Y) 
     (+ $X $Y)) 
    (2 7)) 9)))<span class="ansi31">

(loonit_failure  
 (=@=  
  (((lambda 
     ($_205064 $_205070) 
     (+ $_205064 $_205070)) 
    (2 7))) 
  (9)))
</span><span class="ansi33"> % 'False'

</span>%; Another example

(metta_head  &amp;self part-appl 
 ($F $X))
(metta_defn  &amp;self 
 (part-appl $F $X) 
 (lambda $Y 
  ($F $X $Y)))
(metta_body  &amp;self lambda 
 ($Y 
  ($F $X $Y)))
(metta_head  &amp;self inc ())
(metta_defn  &amp;self 
 (inc) 
 (part-appl + 1))
(metta_body  &amp;self part-appl 
 (+ 1))
(:-  
 (metta_eval  
  (assertEqual 
   ((inc) 5) 6)))<span class="ansi31">

(loonit_failure  
 (=@=  
  (((inc) 5)) 
  (6)))
</span><span class="ansi33"> % 'False'

</span>%; REM:
%;   (get-type (lambda ($x $y) (+ $x $y)))
%; returns (-&gt; %Undefined% Number), because the type of `($x $y)` is not defined.
%; It is also not clear how to check that the type of `$var` is suitable for `$body`
%; (it should somehow be done on`let` side)
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; Let's introduce some functors
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(metta_arity  &amp;self Maybe 2)
(metta_params  &amp;self Maybe 
 ($T Type))
(metta_last  &amp;self Maybe Type)
(metta_arity  &amp;self Nothing 1)
(metta_params  &amp;self Nothing 
 ((Maybe $T)))
(metta_last  &amp;self Nothing T)
(metta_arity  &amp;self Something 2)
(metta_params  &amp;self Something 
 ($T 
  (Maybe $T)))
(metta_last  &amp;self Something T)
(metta_arity  &amp;self Either 2)
(metta_params  &amp;self Either 
 ($T Type))
(metta_last  &amp;self Either Type)
(metta_arity  &amp;self Left 2)
(metta_params  &amp;self Left 
 ($T 
  (Either $T)))
(metta_last  &amp;self Left T)
(metta_arity  &amp;self Right 2)
(metta_params  &amp;self Right 
 ($T 
  (Either $T)))
(metta_last  &amp;self Right T)
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; We can implement a generic `fmap`, but it requires
%; concrete patterns in the type constructors above
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; Instead, we implement `fmap` as:

(metta_arity  &amp;self fmap 3)
(metta_params  &amp;self fmap 
 ((-&gt; $A $B) 
  ($F $A) 
  ($F $B)))
(metta_last  &amp;self fmap B)
%; Mapping over empty functor, returns empty functor

(metta_head  &amp;self fmap 
 ($F 
  ($C0)))
(metta_defn  &amp;self 
 (fmap $F 
  ($C0)) 
 ($C0))
(metta_body  &amp;self $C0 ())
%; Inductive case for singleton functor: apply $f to the
%; element and rewrap in $C.

(metta_head  &amp;self fmap 
 ($F 
  ($C $X)))
(metta_defn  &amp;self 
 (fmap $F 
  ($C $X)) 
 ($C 
  ($F $X)))
(metta_body  &amp;self $C 
 (($F $X)))
%; Inductive case for non-empty functor: apply to the
%; head and recurse on the tail.

(metta_head  &amp;self fmap 
 ($F 
  ($C $X $Xs)))
(metta_defn  &amp;self 
 (fmap $F 
  ($C $X $Xs)) 
 ($C 
  ($F $X) 
  (fmap $F $Xs)))
(metta_body  &amp;self $C 
 (($F $X) 
  (fmap $F $Xs)))
%; NOTE: We had to define `Nothing` as a functional constructor.
%;       Otherwise, we'd have to define `(= (fmap $f $C0) $C0)`,
%;       and `$C0` would match both `Nothing` and `(Something 2)`
%; TODO? This could be avoided if we could indicate that $C0
%;       is a `Symbol` (not `Expression` or `Atom` in general)
%; Tests

(:-  
 (metta_eval  
  (assertEqual 
   (fmap 
    (curry-a + 2) 
    (Something 5)) 
   (Something 7))))<span class="ansi31">

(loonit_failure  
 (=@=  
  ((Something 
    ((curry-a + 2) 5)) 
   (Something 
    (+ 2 5)) 
   (Something 7) 
   (fmap 
    (curry-a + 2) 
    (Something 5))) 
  ((Something 7))))
</span><span class="ansi33"> % 'False'

</span>
(:-  
 (metta_eval  
  (assertEqual 
   (fmap 
    (curry-a + 2) 
    (Nothing)) 
   (Nothing))))<span class="ansi31">

(loonit_failure  
 (=@=  
  ((Nothing) 
   (fmap 
    (curry-a + 2) 
    (Nothing))) 
  ((Nothing))))
</span><span class="ansi33"> % 'False'

</span>%; Type inference works

(:-  
 (metta_eval  
  (assertEqual 
   (get-type 
    (fmap 
     (curry-a + 1) 
     (Left 5))) 
   (Either Number))))<span class="ansi31">

(loonit_failure  
 (=@=  () 
  ((Either Number))))
</span><span class="ansi33"> % 'False'

</span>%; It works for untyped constructors as well, if they
%; follow the patterns in `fmap` equalities

(:-  
 (metta_eval  
  (assertEqual 
   (fmap 
    (curry-a + 2) 
    (UntypedC 5)) 
   (UntypedC 7))))<span class="ansi31">

(loonit_failure  
 (=@=  
  ((UntypedC 
    ((curry-a + 2) 5)) 
   (UntypedC 
    (+ 2 5)) 
   (UntypedC 7) 
   (fmap 
    (curry-a + 2) 
    (UntypedC 5))) 
  ((UntypedC 7))))
</span><span class="ansi33"> % 'False'

</span>
(:-  
 (metta_eval  
  (assertEqual 
   (fmap 
    (curry-a + 2) 
    (UntypedC 5 
     (UntypedC 8 
      (Null)))) 
   (UntypedC 7 
    (UntypedC 10 
     (Null))))))


./MeTTa: line 29: 704837 Killed                  bash -c "${BCMD}"

</pre>
</body>

</html>
