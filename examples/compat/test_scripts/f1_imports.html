<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>
<style type="text/css">
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi36 { color: #00aaaa; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content">
; NOTE: this behavior can change in the future
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Even at the very beginning of the main script `(get-atoms &amp;self)`
; returns one atom, which wraps the space of stdlib.
; The type of this atom is the same as of `&amp;self`
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
!(assertEqual
  ((let $x (get-atoms &amp;self) (get-type $x)))
  ((get-type &amp;self)))

; stdlib is already loaded
!(assertEqual
  (if (&gt; 1 2) 1 2)
  2)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Importing the module into new space
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
!(import! &amp;m f1_moduleA.metta)

; It''s first atom is a space
!(assertEqual
  (let* (($x (collapse (get-atoms &amp;m)))
         ($y (car-atom $x)))
        (get-type $y))
  (get-type &amp;self))

; FIXME? Now, it is moduleC space.
;        Should it be `stdlib` atom for a separately imported space
; !(let $x (collapse (get-atoms &amp;m)) (car-atom $x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Without additional means like `(&amp;m.f 2)` notation or `(interpret &amp;m (f 2))`,
; we cannot execute functions from the separate space - we can only use `match`.
; Although `&amp;m` imports another space with definition of `g`, it is not reduced
; because it is not defined in the context of `&amp;self`. This is the expected
; behavior, but it shows that this way of importing spaces is not too useful
; for importing modules with functions.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
!(assertEqual
  (match &amp;m (= (f 2) $x) $x)
  (g 3))

; Importing the same space into `&amp;self` should break nothing
; TODO? If stdlib space would be in `&amp;m`, which should check that it is not
; there anymore since in should be removed after importing it to `&amp;self`
!(import! &amp;self f1_moduleA.metta)

; Now indirectly imported `g` works and `f` fully works
!(assertEqual (g 2) 102)
!(assertEqual (f 2) 103)

; `&amp;self` contains 3 atoms-spaces now:
; - stdlib
; - moduleC imported by moduleA and removed from A after its import to &amp;self
; - moduleA itself, which is the same as &amp;m
!(assertEqual &amp;m
  (let* (($a (collapse (get-atoms &amp;self)))
          ($x (cdr-atom $a))
          ($y (cdr-atom $x)))
         (car-atom $y)))

; NOTE: now the first atom, which was a space, is removed from `&amp;m`,
; because we load modules only once, and we collect atoms-spaces to
; prevent duplication
!(assertEqual
  (== (let* (($x (collapse (get-atoms &amp;m)))
             ($y (car-atom $x)))
            (get-type $y))
        (get-type &amp;self))
   False)

; Let''s check that `if` from stdlib is not duplicated and gives only one result
!(assertEqual
  (if (&gt; 1 2) 1 2)
  2)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Let''s import one more module into `&amp;self` with a diamond dependence
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
!(import! &amp;self f1_moduleB.metta)
; `g` from moduleC imported via two paths as well as `f`, which uses `g`,
; are not duplicated and produce deterministic results
!(assertEqual (g 2) 102)
!(assertEqual (f 2) 103)

; Function declared in different imported modules will still produce
; non-deterministic results
!(assertEqualToResult
  (dup 2)
  (12 102))

; Let''s import f1_moduleB.metta once more using a different path.
; Such import should be ignored and thus f, g and dup should remain
; unchanged.
!(import! &amp;self f1_moduleB.metta)
!(assertEqual (g 2) 102)
!(assertEqual (f 2) 103)
!(assertEqualToResult
  (dup 2)
  (12 102))
BCMD=export TEE_FILE='/mnt/ffff/metta-vspace/tee.ansi' ; cd /mnt/ffff/metta-vspace ; exec swipl -l metta_vspace/pyswip/metta_interp.pl examples/compat/test_scripts/f1_imports.metta -- -- --args examples/compat/test_scripts/f1_imports.metta
% init_phase(after_load).
% dot_cfg:using_dot_type(core,user)
add_history1(list_column_names)
add_history1(setup_flybase_cols)
add_history1(pmt)
add_history1(save_value_symbol_cols)
add_history1(is_swipl)
add_history1(mine_args_that_need_reduced)
add_history1(print_est_sizes)
add_history1(print_loaded_from_files)
add_history1(load_flybase_chado)
add_history1(load_obo_files)
add_history1(load_flybase_obo_files)
add_history1(load_fbase_after_17)
add_history1(load_flybase_files_ftp)
add_history1(load_flybase_das_11)
add_history1(load_flybase_files)
add_history1(load_flybase_dirs)
add_history1(load_flybase)
add_history1(recount_total_loaded_symbols)
add_history1(gc_now)
add_history1(cleanup_arities)
add_history1(should_sample)
add_history1(should_fix_args)
add_history1(reached_file_max)
add_history1(should_cache)
add_history1(try_overlaps)
add_history1(mine_unif_overlap)
add_history1(mine_symbolspace_overlaps)
add_history1(mine_typelevel_overlaps)
add_history1(mine_overlaps2_slow)
add_history1(mine_overlaps1)
add_history1(mine_overlaps)
add_history1(fb_stats)
 
(track_load_into_file  "examples/compat/test_scripts/f1_imports.metta")
%;; NOTE: this behavior can change in the future
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;; Even at the very beginning of the main script `(get-atoms &amp;self)`
%;; returns one atom, which wraps the space of stdlib.
%;; The type of this atom is the same as of `&amp;self`
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(:-  
 (metta_eval  
  (assertEqual 
   ((let $X 
     (get-atoms &amp;self) 
     (get-type $X))) 
   ((get-type &amp;self)))))<span class="ansi36">

(loonit_success  
 (=@=  () ()))
</span><span class="ansi33"> % 'True'

</span>%; stdlib is already loaded

(:-  
 (metta_eval  
  (assertEqual 
   (if 
    (&gt; 1 2) 1 2) 2)))<span class="ansi36">

(loonit_success  
 (=@=  
  (2) 
  (2)))
</span><span class="ansi33"> % 'True'

</span>%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; Importing the module into new space
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(:-  
 (metta_eval  
  (import! &amp;m f1_moduleA.metta)))
 
(track_load_into_file  f1_moduleA.metta)
%; It''s first atom is a space
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;; Example file used by f1_imports.metta
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(:-  
 (metta_eval  
  (import! &amp;self f1_moduleC.metta)))
 
(track_load_into_file  f1_moduleC.metta)
%; FIXME? stdlib space is not available at importing time -
%; only tokens / grounded operations work, while symbolic functions
%; (like `if`) don''t work.
%; FIXME? Exceptions are not caught by `importOp`
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;; Example file used by f1_imports.metta
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(metta_arity  &amp;m __g 1)
(metta_params  &amp;m __g 
 (Number))
(metta_last  &amp;m __g Number)
(metta_head  &amp;m __g ())
(metta_defn  &amp;m 
 (__g) 100)
(unknown_do_metta  &amp;m load 
 (= 
  (__g) 100))
(metta_arity  &amp;m g 2)
(metta_params  &amp;m g 
 (Number Numer))
(metta_last  &amp;m g Numer)
(metta_head  &amp;m g 
 ($X))
(metta_defn  &amp;m 
 (g $X) 
 (+ $X 
  (__g)))
(metta_body  &amp;m + 
 ($X 
  (__g)))<span class="ansi32">
% 20,292 inferences, 0.004 CPU in 0.004 seconds (93% CPU, 5773630 Lips)
</span> 
(=  f1_moduleC.metta 0)
<span class="ansi33"> % '&amp;m'

</span>
(:-  
 (metta_eval  
  (assertEqual 
   (+ 1 2) 3)))<span class="ansi36">

(loonit_success  
 (=@=  
  (3) 
  (3)))
</span><span class="ansi33"> % 'True'

</span>%; !(assertEqual (if True "S" "F") "S")

(metta_head  &amp;m dup 
 ($X))
(metta_defn  &amp;m 
 (dup $X) 
 (if 
  (== $X 0) 
  (+ $X 10) 
  (g $X)))
(metta_body  &amp;m if 
 ((== $X 0) 
  (+ $X 10) 
  (g $X)))
(metta_arity  &amp;m f 2)
(metta_params  &amp;m f 
 (Number Number))
(metta_last  &amp;m f Number)
(metta_head  &amp;m f 
 ($X))
(metta_defn  &amp;m 
 (f $X) 
 (if 
  (&lt; $X 0) 
  (- 0 $X) 
  (g 
   (+ 1 $X))))
(metta_body  &amp;m if 
 ((&lt; $X 0) 
  (- 0 $X) 
  (g 
   (+ 1 $X))))<span class="ansi32">
% 63,320 inferences, 0.013 CPU in 0.014 seconds (93% CPU, 4941355 Lips)
</span> 
(=  f1_moduleA.metta 0)
<span class="ansi33"> % '&amp;m'

</span>
(:-  
 (metta_eval  
  (assertEqual 
   (let* 
    (($X 
      (collapse 
       (get-atoms &amp;m))) 
     ($Y 
      (car-atom $X))) 
    (get-type $Y)) 
   (get-type &amp;self))))<span class="ansi36">

(loonit_success  
 (=@=  () ()))
</span><span class="ansi33"> % 'True'

</span>%; FIXME? Now, it is moduleC space.
%;        Should it be `stdlib` atom for a separately imported space
%; !(let $x (collapse (get-atoms &amp;m)) (car-atom $x))
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; Without additional means like `(&amp;m.f 2)` notation or `(interpret &amp;m (f 2))`,
%; we cannot execute functions from the separate space - we can only use `match`.
%; Although `&amp;m` imports another space with definition of `g`, it is not reduced
%; because it is not defined in the context of `&amp;self`. This is the expected
%; behavior, but it shows that this way of importing spaces is not too useful
%; for importing modules with functions.
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(:-  
 (metta_eval  
  (assertEqual 
   (match &amp;m 
    (= 
     (f 2) $X) $X) 
   (g 3))))<span class="ansi31">

(loonit_failure  
 (=@=  
  ((g 
    (+ 1 2)) 
   (g 3)) 
  ((g 3))))
</span><span class="ansi33"> % 'False'

</span>%; Importing the same space into `&amp;self` should break nothing
%; TODO? If stdlib space would be in `&amp;m`, which should check that it is not
%; there anymore since in should be removed after importing it to `&amp;self`

(:-  
 (metta_eval  
  (import! &amp;self f1_moduleA.metta)))
 
(track_load_into_file  f1_moduleA.metta)
%; Now indirectly imported `g` works and `f` fully works
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;; Example file used by f1_imports.metta
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(:-  
 (metta_eval  
  (import! &amp;self f1_moduleC.metta)))
 
(track_load_into_file  f1_moduleC.metta)
%; FIXME? stdlib space is not available at importing time -
%; only tokens / grounded operations work, while symbolic functions
%; (like `if`) don''t work.
%; FIXME? Exceptions are not caught by `importOp`
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;; Example file used by f1_imports.metta
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(metta_arity  &amp;self __g 1)
(metta_params  &amp;self __g 
 (Number))
(metta_last  &amp;self __g Number)
(metta_head  &amp;self __g ())
(metta_defn  &amp;self 
 (__g) 100)
(unknown_do_metta  &amp;self load 
 (= 
  (__g) 100))
(metta_arity  &amp;self g 2)
(metta_params  &amp;self g 
 (Number Numer))
(metta_last  &amp;self g Numer)
(metta_head  &amp;self g 
 ($X))
(metta_defn  &amp;self 
 (g $X) 
 (+ $X 
  (__g)))
(metta_body  &amp;self + 
 ($X 
  (__g)))<span class="ansi32">
% 20,288 inferences, 0.005 CPU in 0.005 seconds (100% CPU, 3866443 Lips)
</span> 
(=  f1_moduleC.metta 0)
<span class="ansi33"> % '&amp;self'

</span>
(:-  
 (metta_eval  
  (assertEqual 
   (+ 1 2) 3)))<span class="ansi36">

(loonit_success  
 (=@=  
  (3) 
  (3)))
</span><span class="ansi33"> % 'True'

</span>%; !(assertEqual (if True "S" "F") "S")

(metta_head  &amp;self dup 
 ($X))
(metta_defn  &amp;self 
 (dup $X) 
 (if 
  (== $X 0) 
  (+ $X 10) 
  (g $X)))
(metta_body  &amp;self if 
 ((== $X 0) 
  (+ $X 10) 
  (g $X)))
(metta_arity  &amp;self f 2)
(metta_params  &amp;self f 
 (Number Number))
(metta_last  &amp;self f Number)
(metta_head  &amp;self f 
 ($X))
(metta_defn  &amp;self 
 (f $X) 
 (if 
  (&lt; $X 0) 
  (- 0 $X) 
  (g 
   (+ 1 $X))))
(metta_body  &amp;self if 
 ((&lt; $X 0) 
  (- 0 $X) 
  (g 
   (+ 1 $X))))<span class="ansi32">
% 63,271 inferences, 0.018 CPU in 0.018 seconds (100% CPU, 3545547 Lips)
</span> 
(=  f1_moduleA.metta 0)
<span class="ansi33"> % '&amp;self'

</span>
(:-  
 (metta_eval  
  (assertEqual 
   (g 2) 102)))<span class="ansi31">

(loonit_failure  
 (=@=  
  ((+ 2 
    (__g)) 
   (g 2)) 
  (102)))
</span><span class="ansi33"> % 'False'

</span>
(:-  
 (metta_eval  
  (assertEqual 
   (f 2) 103)))<span class="ansi31">

(loonit_failure  
 (=@=  
  ((+ 
    (+ 1 2) 
    (__g)) 
   (+ 3 
    (__g)) 
   (g 
    (+ 1 2)) 
   (g 3) -2 
   (f 2)) 
  (103)))
</span><span class="ansi33"> % 'False'

</span>%; `&amp;self` contains 3 atoms-spaces now:
%; - stdlib
%; - moduleC imported by moduleA and removed from A after its import to &amp;self
%; - moduleA itself, which is the same as &amp;m

(:-  
 (metta_eval  
  (assertEqual &amp;m 
   (let* 
    (($A 
      (collapse 
       (get-atoms &amp;self))) 
     ($X 
      (cdr-atom $A)) 
     ($Y 
      (cdr-atom $X))) 
    (car-atom $Y)))))<span class="ansi31">

(loonit_failure  
 (=@=  
  (&amp;m) 
  ((car-atom 
    (cdr-atom 
     (cdr-atom ()))))))
</span><span class="ansi33"> % 'False'

</span>%; NOTE: now the first atom, which was a space, is removed from `&amp;m`,
%; because we load modules only once, and we collect atoms-spaces to
%; prevent duplication

(:-  
 (metta_eval  
  (assertEqual 
   (== 
    (let* 
     (($X 
       (collapse 
        (get-atoms &amp;m))) 
      ($Y 
       (car-atom $X))) 
     (get-type $Y)) 
    (get-type &amp;self)) False)))<span class="ansi36">

(loonit_success  
 (=@=  
  (False) 
  (False)))
</span><span class="ansi33"> % 'True'

</span>%; Let''s check that `if` from stdlib is not duplicated and gives only one result

(:-  
 (metta_eval  
  (assertEqual 
   (if 
    (&gt; 1 2) 1 2) 2)))<span class="ansi36">

(loonit_success  
 (=@=  
  (2) 
  (2)))
</span><span class="ansi33"> % 'True'

</span>%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%; Let''s import one more module into `&amp;self` with a diamond dependence
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(:-  
 (metta_eval  
  (import! &amp;self f1_moduleB.metta)))
 
(track_load_into_file  f1_moduleB.metta)
%; `g` from moduleC imported via two paths as well as `f`, which uses `g`,
%; are not duplicated and produce deterministic results
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;; Example file used by f1_imports.metta
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(:-  
 (metta_eval  
  (import! &amp;self f1_moduleC.metta)))
 
(track_load_into_file  f1_moduleC.metta)
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;; Example file used by f1_imports.metta
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(metta_arity  &amp;self __g 1)
(metta_params  &amp;self __g 
 (Number))
(metta_last  &amp;self __g Number)
(metta_head  &amp;self __g ())
(metta_defn  &amp;self 
 (__g) 100)
(unknown_do_metta  &amp;self load 
 (= 
  (__g) 100))
(metta_arity  &amp;self g 2)
(metta_params  &amp;self g 
 (Number Numer))
(metta_last  &amp;self g Numer)
(metta_head  &amp;self g 
 ($X))
(metta_defn  &amp;self 
 (g $X) 
 (+ $X 
  (__g)))
(metta_body  &amp;self + 
 ($X 
  (__g)))<span class="ansi32">
% 19,470 inferences, 0.003 CPU in 0.003 seconds (100% CPU, 6664841 Lips)
</span> 
(=  f1_moduleC.metta 0)
<span class="ansi33"> % '&amp;self'

</span>
(metta_head  &amp;self dup 
 ($X))
(metta_defn  &amp;self 
 (dup $X) 
 (if 
  (== $X 0) 
  (g $X) 
  (+ $X 10)))
(metta_body  &amp;self if 
 ((== $X 0) 
  (g $X) 
  (+ $X 10)))<span class="ansi32">
% 36,285 inferences, 0.006 CPU in 0.006 seconds (95% CPU, 6191557 Lips)
</span> 
(=  f1_moduleB.metta 0)
<span class="ansi33"> % '&amp;self'

</span>
(:-  
 (metta_eval  
  (assertEqual 
   (g 2) 102)))<span class="ansi31">

(loonit_failure  
 (=@=  
  ((+ 2 
    (__g)) 
   (g 2)) 
  (102)))
</span><span class="ansi33"> % 'False'

</span>
(:-  
 (metta_eval  
  (assertEqual 
   (f 2) 103)))<span class="ansi31">

(loonit_failure  
 (=@=  
  ((+ 
    (+ 1 2) 
    (__g)) 
   (+ 3 
    (__g)) 
   (g 
    (+ 1 2)) 
   (g 3) -2 
   (f 2)) 
  (103)))
</span><span class="ansi33"> % 'False'

</span>%; Function declared in different imported modules will still produce
%; non-deterministic results

(:-  
 (metta_eval  
  (assertEqualToResult 
   (dup 2) 
   (12 102))))<span class="ansi31">

(loonit_failure  
 (=@=  
  ((+ 2 
    (__g)) 
   (g 2) 12 
   (dup 2)) 
  (12 102)))
</span><span class="ansi33"> % 'False'

</span>%; Let''s import f1_moduleB.metta once more using a different path.
%; Such import should be ignored and thus f, g and dup should remain
%; unchanged.

(:-  
 (metta_eval  
  (import! &amp;self f1_moduleB.metta)))
 
(track_load_into_file  f1_moduleB.metta)
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;; Example file used by f1_imports.metta
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(:-  
 (metta_eval  
  (import! &amp;self f1_moduleC.metta)))
 
(track_load_into_file  f1_moduleC.metta)
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%;; Example file used by f1_imports.metta
%;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(metta_arity  &amp;self __g 1)
(metta_params  &amp;self __g 
 (Number))
(metta_last  &amp;self __g Number)
(metta_head  &amp;self __g ())
(metta_defn  &amp;self 
 (__g) 100)
(unknown_do_metta  &amp;self load 
 (= 
  (__g) 100))
(metta_arity  &amp;self g 2)
(metta_params  &amp;self g 
 (Number Numer))
(metta_last  &amp;self g Numer)
(metta_head  &amp;self g 
 ($X))
(metta_defn  &amp;self 
 (g $X) 
 (+ $X 
  (__g)))
(metta_body  &amp;self + 
 ($X 
  (__g)))<span class="ansi32">
% 19,469 inferences, 0.003 CPU in 0.003 seconds (100% CPU, 6169862 Lips)
</span> 
(=  f1_moduleC.metta 0)
<span class="ansi33"> % '&amp;self'

</span>
(metta_head  &amp;self dup 
 ($X))
(metta_defn  &amp;self 
 (dup $X) 
 (if 
  (== $X 0) 
  (g $X) 
  (+ $X 10)))
(metta_body  &amp;self if 
 ((== $X 0) 
  (g $X) 
  (+ $X 10)))<span class="ansi32">
% 35,878 inferences, 0.006 CPU in 0.006 seconds (100% CPU, 6157622 Lips)
</span> 
(=  f1_moduleB.metta 0)
<span class="ansi33"> % '&amp;self'

</span>
(:-  
 (metta_eval  
  (assertEqual 
   (g 2) 102)))<span class="ansi31">

(loonit_failure  
 (=@=  
  ((+ 2 
    (__g)) 
   (g 2)) 
  (102)))
</span><span class="ansi33"> % 'False'

</span>
(:-  
 (metta_eval  
  (assertEqual 
   (f 2) 103)))<span class="ansi31">

(loonit_failure  
 (=@=  
  ((+ 
    (+ 1 2) 
    (__g)) 
   (+ 3 
    (__g)) 
   (g 
    (+ 1 2)) 
   (g 3) -2 
   (f 2)) 
  (103)))
</span><span class="ansi33"> % 'False'

</span>
(:-  
 (metta_eval  
  (assertEqualToResult 
   (dup 2) 
   (12 102))))<span class="ansi31">

(loonit_failure  
 (=@=  
  ((+ 2 
    (__g)) 
   (g 2) 12 
   (dup 2)) 
  (12 102)))
</span><span class="ansi33"> % 'False'

</span><span class="ansi32">% 10,784,417 inferences, 1.514 CPU in 1.516 seconds (100% CPU, 7121320 Lips)
</span> 
(=  "examples/compat/test_scripts/f1_imports.metta" 0)
<span class="ansi1">LoonIt Report
</span>------------
<span class="ansi32">Successes: 7
</span><span class="ansi31">Failures: 10
</span>

</pre>
</body>

</html>
