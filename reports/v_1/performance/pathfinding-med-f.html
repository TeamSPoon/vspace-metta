<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>
<style type="text/css">
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi32 { color: #00aa00; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content">
 (@ track_load_into_file "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/performance/pathfinding-med-f.metta")
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/performance/pathfinding-med-f.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/performance/pathfinding-med-f.metta')
:- dynamic file_answers/3.


;; Metta Pathfinding Example
; Define the edge-f function, which represents one-way edges in the graph.
; This function is crucial for specifying connections between nodes.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'edge-f',[->,'Symbol','Symbol']])
</span><span class="ansi38-255165000">  (: edge-f 
    (-> Symbol Symbol))
</span>

; Define the edges in the graph using the edge-f function.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['edge-f',a],b)
</span><span class="ansi38-255165000">  (= 
    (edge-f a) b)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['edge-f',b],c)
</span><span class="ansi38-255165000">  (= 
    (edge-f b) c)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['edge-f',c],d)
</span><span class="ansi38-255165000">  (= 
    (edge-f c) d)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['edge-f',e],f)
</span><span class="ansi38-255165000">  (= 
    (edge-f e) f)
</span>

; The following code is commented-out and relates to node connectivity checks.
;(= (at $x) (assertTrue $x))
;(= (at-a-b) (at (== (edge-f a) b)))
;!(at-a-b)
;(= (a-t-a-b) (assertTrue (== (edge-f a) b)))
;!(a-t-a-b)
; Testing the presence of nodes in the graph.
<span class="ansi38-000068000">!(assertTrue 
  (== 
    (edge-f a) b))

</span><h3 id="PERFORMANCE.PATHFINDING-MED-F.01">;; PERFORMANCE.PATHFINDING-MED-F.01</h3>
; 
; EVAL TEST
; took 1.22 ms.
; Node 'a' is connected to 'b'
; Not present
<span class="ansi38-000068000">!(assertFalse 
  (== 
    (edge-f a) d))

</span><h3 id="PERFORMANCE.PATHFINDING-MED-F.02">;; PERFORMANCE.PATHFINDING-MED-F.02</h3>
; 
; EVAL TEST
; took 1.39 ms.
; Node 'a' is not connected to 'd'
; Define the path-f function for pathfinding.
; This function utilizes recursive calls to the edge-f function.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'path-f',[->,'Symbol','Symbol']])
</span><span class="ansi38-255165000">  (: path-f 
    (-> Symbol Symbol))
</span>

; A node is always connected to itself.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['path-f',X],X)
</span><span class="ansi38-255165000">  (= 
    (path-f $X) $X)
</span>

; The path-f function follows edges using the edge-f function.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['path-f',X],['edge-f',['path-f',X]])
</span><span class="ansi38-255165000">  (= 
    (path-f $X) 
    (edge-f 
      (path-f $X)))
</span>

; The following unit tests for the path-f function are currently commented out.
;!(assertTrue (== (path-f e) e))
;!(assertTrue (== (path-f a) b))
;!(assertTrue (== (path-f a) d))
; There should be only one direction
;!(assertFalse (== (path-f c) a))
; Not connected
;!(assertFalse (== (path-f a) f))
; Define the epath-f function for pathfinding using edges.
; This function also employs recursive calls to the edge-f function.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'epath-f',[->,'Symbol','Symbol']])
</span><span class="ansi38-255165000">  (: epath-f 
    (-> Symbol Symbol))
</span>

; The epath-f function follows edges using the edge-f function.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['epath-f',X],['epath-f',['edge-f',X]])
</span><span class="ansi38-255165000">  (= 
    (epath-f $X) 
    (epath-f 
      (edge-f $X)))
</span>

; A node is still connected to itself.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['epath-f',X],X)
</span><span class="ansi38-255165000">  (= 
    (epath-f $X) $X)
</span>

; The following unit tests for the epath-f function are currently commented out.
; Uncomment these unit tests as needed.
;!(assertTrue (== (epath-f e) e))
;!(assertTrue (== (epath-f a) b))
;!(assertTrue (== (epath-f a) d))
; There should be only one direction
;!(assertFalse (== (epath-f c) a))
; Not connected
;!(assertFalse (== (epath-f a) f))
; Pathfinding with nondeterministic epath-f

[assertEqual,['epath-f',a],[superpose,[a,b,c,d]]]
<span class="ansi38-000068000">!(assertEqual 
  (epath-f a) 
  (superpose 
    (a b c d)))

</span>; Define the epath-f-p predicate for pathfinding using edges.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['epath-f-p','?x','?y'],[==,['epath-f',X],'?y'])
</span><span class="ansi38-255165000">  (= 
    (epath-f-p ?x ?y) 
    (== 
      (epath-f $X) ?y))
</span>

; Running epath-f in reverse directly via '=='

[assertEqual,[match,'&self',[==,['epath-f',X],c],'?x'],[superpose,[a,b,c]]]
<span class="ansi38-000068000">!(assertEqual 
  (match &self 
    (== 
      (epath-f $X) c) ?x) 
  (superpose 
    (a b c)))

</span>; Running epath-f in reverse via the truth predicate

[assertEqual,[match,'&self',['epath-f-p',X,c],X],[superpose,[a,b,c]]]
<span class="ansi38-000068000">!(assertEqual 
  (match &self 
    (epath-f-p $X c) $X) 
  (superpose 
    (a b c)))

</span>; Redefine the edge function using facts instead of functions.
; The graph is represented as facts: (= (edge A B) True) means there is a one-way edge from A to B.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,edge,[->,'Symbol','Symbol','Bool']])
</span><span class="ansi38-255165000">  (: edge 
    (-> Symbol Symbol Bool))
</span>

; Define the directional edges in the graph using facts.
;a -> b -> c -> d
;     \
;      e -> f
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[edge,a,b],'True')
</span><span class="ansi38-255165000">  (= 
    (edge a b) True)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[edge,b,c],'True')
</span><span class="ansi38-255165000">  (= 
    (edge b c) True)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[edge,c,d],'True')
</span><span class="ansi38-255165000">  (= 
    (edge c d) True)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[edge,b,e],'True')
</span><span class="ansi38-255165000">  (= 
    (edge b e) True)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[edge,e,f],'True')
</span><span class="ansi38-255165000">  (= 
    (edge e f) True)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[edge,g,h],'True')
</span><span class="ansi38-255165000">  (= 
    (edge g h) True)
</span>

; Define the path function using facts for pathfinding.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,path,[->,'Symbol','Symbol','Bool']])
</span><span class="ansi38-255165000">  (: path 
    (-> Symbol Symbol Bool))
</span>

; A node is always connected to itself.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[path,X,X],'True')
</span><span class="ansi38-255165000">  (= 
    (path $X $X) True)
</span>

; The path function uses facts to check edge connectivity.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[path,X,Y],[and,[edge,X,Z],[path,Z,Y]])
</span><span class="ansi38-255165000">  (= 
    (path $X $Y) 
    (and 
      (edge $X $Z) 
      (path $Z $Y)))
</span>

; Unit tests for the path function.

[assertEqual,[path,a,b],'True']
<span class="ansi38-000068000">!(assertEqual 
  (path a b) True)

</span>
[assertEqual,[path,a,c],'True']
<span class="ansi38-000068000">!(assertEqual 
  (path a c) True)

</span>
[assertEqual,[path,a,d],'True']
<span class="ansi38-000068000">!(assertEqual 
  (path a d) True)

</span>
[assertEqual,[path,a,f],'True']
<span class="ansi38-000068000">!(assertEqual 
  (path a f) True)

</span>
[assertEqual,[path,b,e],'True']
<span class="ansi38-000068000">!(assertEqual 
  (path b e) True)

</span>
[assertEqual,[path,e,f],'True']
<span class="ansi38-000068000">!(assertEqual 
  (path e f) True)

</span><span class="ansi32">% 226,298 inferences, 0.408 CPU in 0.408 seconds (100% CPU, 554568 Lips)
</span> (@ = "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/performance/pathfinding-med-f.metta" 0)
doing(ansi2html -u < "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/TEE.ansi" > "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/performance/pathfinding-med-f.html" )

</pre>
</body>

</html>
