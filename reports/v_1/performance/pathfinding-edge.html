<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>
<style type="text/css">
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content">
 (@ track_load_into_file "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/performance/pathfinding-edge.metta")
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/performance/pathfinding-edge.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/performance/pathfinding-edge.metta')
:- dynamic file_answers/3.


;; Metta Pathfinding Example
; these examples actually need the compiler!
<span class="ansi38-000068000">!(pragma! compile full)

</span>; Evaluation took 0.088 ms. (87.90 microseconds) 
<span class="ansi33"> Empty

</span>; Define the edge-f function, which represents one-way edges in the graph.
; This function is crucial for specifying connections between nodes.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'edge-f',[->,'Symbol','Symbol']])
</span><span class="ansi38-255165000">  (: edge-f 
    (-> Symbol Symbol))
</span>

; Define the edges in the graph using the edge-f function.
%~ [ convert(Convert),
%~   head_preconds_into_body(('edge-f'(a,_345278):-_345278=b))]
%~ [convert(_346686),head_preconds_into_body(('edge-f'(a,_345278):-_345278=b))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['edge-f',a],b)
</span><span class="ansi38-255165000">  (= 
    (edge-f a) b)
</span><span class="ansi38-000082136">  :- dynamic'edge-f'/2.

  'edge-f'(a, A) :-
    A=b.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('edge-f'(b,_426452):-_426452=c))]
%~ [convert(_427860),head_preconds_into_body(('edge-f'(b,_426452):-_426452=c))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['edge-f',b],c)
</span><span class="ansi38-255165000">  (= 
    (edge-f b) c)
</span><span class="ansi38-000082136">
  'edge-f'(b, A) :-
    A=c.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('edge-f'(c,_488034):-_488034=d))]
%~ [convert(_489442),head_preconds_into_body(('edge-f'(c,_488034):-_488034=d))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['edge-f',c],d)
</span><span class="ansi38-255165000">  (= 
    (edge-f c) d)
</span><span class="ansi38-000082136">
  'edge-f'(c, A) :-
    A=d.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('edge-f'(e,_32386):-_32386=f))]
%~ [convert(_33794),head_preconds_into_body(('edge-f'(e,_32386):-_32386=f))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['edge-f',e],f)
</span><span class="ansi38-255165000">  (= 
    (edge-f e) f)
</span><span class="ansi38-000082136">
  'edge-f'(e, A) :-
    A=f.

</span>

; The following code is commented-out and relates to node connectivity checks.
;(= (at $x) (assertTrue $x))
;(= (at-a-b) (at (is-same (edge-f a) b)))
;!(at-a-b)
;(= (a-t-a-b) (assertTrue (is-same (edge-f a) b)))
;!(a-t-a-b)
%~ [ convert(Convert),
%~   head_preconds_into_body(('is-same'(X,X,_96758):-_96758='True'))]
%~ [convert(_98210),head_preconds_into_body(('is-same'(X,X,_96758):-_96758='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['is-same',X,X],'True')
</span><span class="ansi38-255165000">  (= 
    (is-same $X $X) True)
</span><span class="ansi38-000082136">  :- dynamic'is-same'/3.

  'is-same'(X, X, A) :-
    A='True'.

</span>

; Testing the presence of nodes in the graph.
<span class="ansi38-000068000">!(assertTrue 
  (is-same 
    (edge-f a) b))

</span>%~ [ convert(Convert),
%~   head_preconds_into_body( exec(Assign_Exec_AssertTrue) :-
%~                              u_assign(['edge-f',a],Assign) ,
%~                              u_assign(['is-same',Assign,b],AssertTrue_Assign3) ,
%~                              u_assign(assertTrue(AssertTrue_Assign3),Assign_Exec_AssertTrue))]
exec(A) :-
    u_assign(['edge-f', a], B),
    u_assign(['is-same', B, b], C),
    u_assign(assertTrue(C), A).

subst_vars((u_assign(['edge-f',a],L38),u_assign(['is-same',L38,b],M38),u_assign(assertTrue(M38),N38)),[],[L38,M38,N38])
<h3 id="PERFORMANCE.PATHFINDING-EDGE.01">;; PERFORMANCE.PATHFINDING-EDGE.01</h3>
; 
; EVAL TEST
; took 0.036 ms. (36.10 microseconds) 
; Evaluation took 0.289 ms. (289.10 microseconds) 
<span class="ansi33">  (assertTrue True)

</span>; Node 'a' is connected to 'b'
; Not present
<span class="ansi38-000068000">!(assertFalse 
  (is-same 
    (edge-f a) d))

</span>%~ [ convert(Convert),
%~   head_preconds_into_body( exec(Assign_Exec_AssertFalse) :-
%~                              u_assign(['edge-f',a],Assign) ,
%~                              u_assign(['is-same',Assign,d],AssertFalse_Assign3) ,
%~                              u_assign(assertFalse(AssertFalse_Assign3),Assign_Exec_AssertFalse))]
exec(A) :-
    u_assign(['edge-f', a], B),
    u_assign(['is-same', B, d], C),
    u_assign(assertFalse(C), A).

subst_vars((u_assign(['edge-f',a],L38),u_assign(['is-same',L38,d],M38),u_assign(assertFalse(M38),N38)),[],[L38,M38,N38])
%~ user: message_hook(
%~          error(existence_error(source_sink,'is-same'),Existence_error),
%~          error,
%~          ['~w `~p\' does not exist'-[source_sink,'is-same']]).
<span class="ansi1 ansi31">ERROR: source_sink `'is-same'' does not exist
</span>%~ user: message_hook(
%~          error(existence_error(source_sink,b),Existence_error),
%~          error,
%~          ['~w `~p\' does not exist'-[source_sink,b]]).
<span class="ansi1 ansi31">ERROR: source_sink `b' does not exist
</span>%~ user: message_hook(
%~          error(existence_error(source_sink,d),Existence_error),
%~          error,
%~          ['~w `~p\' does not exist'-[source_sink,d]]).
<span class="ansi1 ansi31">ERROR: source_sink `d' does not exist
</span><h3 id="PERFORMANCE.PATHFINDING-EDGE.02">;; PERFORMANCE.PATHFINDING-EDGE.02</h3>
; 
; EVAL TEST
; took 0.040 ms. (39.70 microseconds) 
; Evaluation took 58.96 ms.
<span class="ansi33">  (assertFalse True)

</span>; Node 'a' is not connected to 'd'
; Define the path-f function for pathfinding.
; This function utilizes recursive calls to the edge-f function.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'path-f',[->,'Symbol','Symbol']])
</span><span class="ansi38-255165000">  (: path-f 
    (-> Symbol Symbol))
</span>

; A node is always connected to itself.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['path-f',X],X)
</span><span class="ansi38-255165000">  (= 
    (path-f $X) $X)
</span><span class="ansi38-000082136">  :- dynamic'path-f'/2.

  'path-f'(X, A) :-
    u_assign(X, A).

</span>

; The path-f function follows edges using the edge-f function.
%~ [ convert(Convert),
%~   head_preconds_into_body( 'path-f'(X,Edge_f_X) :-
%~                              u_assign(['path-f',X],Edge_f_Assign) ,
%~                              u_assign('edge-f'(Edge_f_Assign),Edge_f_X))]
%~ [convert(_41926),head_preconds_into_body(('path-f'(X,_40474):-u_assign(['path-f',X],_42634),u_assign('edge-f'(_42634),_40474)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['path-f',X],['edge-f',['path-f',X]])
</span><span class="ansi38-255165000">  (= 
    (path-f $X) 
    (edge-f 
      (path-f $X)))
</span><span class="ansi38-000082136">
  'path-f'(X, A) :-
    u_assign(['path-f', X], B),
    u_assign('edge-f'(B), A).

</span>

; The following unit tests for the path-f function are currently commented out.
;!(assertTrue (is-same (path-f e) e))
;!(assertTrue (is-same (path-f a) b))
;!(assertTrue (is-same (path-f a) d))
; There should be only one direction
;!(assertFalse (is-same (path-f c) a))
; Not connected
;!(assertFalse (is-same (path-f a) f))
; Define the epath-f function for pathfinding using edges.
; This function also employs recursive calls to the edge-f function.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'epath-f',[->,'Symbol','Symbol']])
</span><span class="ansi38-255165000">  (: epath-f 
    (-> Symbol Symbol))
</span>

; The epath-f function follows edges using the edge-f function.
%~ [ convert(Convert),
%~   head_preconds_into_body( 'epath-f'(X,Epath_f_X) :-
%~                              u_assign(['edge-f',X],Epath_f_Assign) ,
%~                              u_assign('epath-f'(Epath_f_Assign),Epath_f_X))]
%~ [convert(_142504),head_preconds_into_body(('epath-f'(X,_141052):-u_assign(['edge-f',X],_143212),u_assign('epath-f'(_143212),_141052)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['epath-f',X],['epath-f',['edge-f',X]])
</span><span class="ansi38-255165000">  (= 
    (epath-f $X) 
    (epath-f 
      (edge-f $X)))
</span><span class="ansi38-000082136">  :- dynamic'epath-f'/2.

  'epath-f'(X, A) :-
    u_assign(['edge-f', X], B),
    u_assign('epath-f'(B), A).

</span>

; A node is still connected to itself.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['epath-f',X],X)
</span><span class="ansi38-255165000">  (= 
    (epath-f $X) $X)
</span><span class="ansi38-000082136">
  'epath-f'(X, A) :-
    u_assign(X, A).

</span>

; The following unit tests for the epath-f function are currently commented out.
; Uncomment these unit tests as needed.
;!(assertTrue (is-same (epath-f e) e))
;!(assertTrue (is-same (epath-f a) b))
;!(assertTrue (is-same (epath-f a) d))
; There should be only one direction
;!(assertFalse (is-same (epath-f c) a))
; Not connected
;!(assertFalse (is-same (epath-f a) f))
; Pathfinding with nondeterministic epath-f

[assertEqualToResult,['epath-f',a],[collapse,[superpose,[a,b,c,d]]]]
<span class="ansi38-000068000">!(assertEqualToResult 
  (epath-f a) 
  (collapse 
    (superpose 
      (a b c d))))

</span>; Define the epath-f-p predicate for pathfinding using edges
%~ [ convert(Convert),
%~   head_preconds_into_body( 'epath-f-p'(X,Y,Is_same_Y) :-
%~                              u_assign(['epath-f',X],Assign_Y1) ,
%~                              u_assign('is-same'(Assign_Y1,Y),Is_same_Y))]
%~ [convert(_283144),head_preconds_into_body(('epath-f-p'(X,Y,_281672):-u_assign(['epath-f',X],_283910),u_assign('is-same'(_283910,Y),_281672)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['epath-f-p',X,Y],['is-same',['epath-f',X],Y])
</span><span class="ansi38-255165000">  (= 
    (epath-f-p $X $Y) 
    (is-same 
      (epath-f $X) $Y))
</span><span class="ansi38-000082136">  :- dynamic'epath-f-p'/3.

  'epath-f-p'(X, Y, A) :-
    u_assign(['epath-f', X], B),
    u_assign('is-same'(B, Y), A).

</span>

; Running epath-f in reverse directly via 'is-same'

[assertEqual,[match,'&self',['is-same',['epath-f',X],c],X],[superpose,[a,b,c]]]
<span class="ansi38-000068000">!(assertEqual 
  (match &self 
    (is-same 
      (epath-f $X) c) $X) 
  (superpose 
    (a b c)))

</span>; Running epath-f in reverse via the truth predicate

[assertEqual,[match,'&self',['epath-f-p',X,c],X],[superpose,[a,b,c]]]
<span class="ansi38-000068000">!(assertEqual 
  (match &self 
    (epath-f-p $X c) $X) 
  (superpose 
    (a b c)))

</span>; Redefine the edge function using facts instead of functions.
; The graph is represented as facts: (= (edge A B) True) means there is a one-way edge from A to B.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,edge,[->,'Symbol','Symbol','Bool']])
</span><span class="ansi38-255165000">  (: edge 
    (-> Symbol Symbol Bool))
</span>

; Define the directional edges in the graph using facts.
;a -> b -> c -> d
;     \
;      e -> f
%~ [ convert(Convert),
%~   head_preconds_into_body((edge(a,b,_424028):-_424028='True'))]
%~ [convert(_425450),head_preconds_into_body((edge(a,b,_424028):-_424028='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[edge,a,b],'True')
</span><span class="ansi38-255165000">  (= 
    (edge a b) True)
</span><span class="ansi38-000082136">  :- dynamic edge/3.

  edge(a, b, A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((edge(b,c,_470366):-_470366='True'))]
%~ [convert(_471788),head_preconds_into_body((edge(b,c,_470366):-_470366='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[edge,b,c],'True')
</span><span class="ansi38-255165000">  (= 
    (edge b c) True)
</span><span class="ansi38-000082136">
  edge(b, c, A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((edge(c,d,_2388):-_2388='True'))]
%~ [convert(_2412),head_preconds_into_body((edge(c,d,_2388):-_2388='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[edge,c,d],'True')
</span><span class="ansi38-255165000">  (= 
    (edge c d) True)
</span><span class="ansi38-000082136">
  edge(c, d, A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((edge(b,e,_45576):-_45576='True'))]
%~ [convert(_46998),head_preconds_into_body((edge(b,e,_45576):-_45576='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[edge,b,e],'True')
</span><span class="ansi38-255165000">  (= 
    (edge b e) True)
</span><span class="ansi38-000082136">
  edge(b, e, A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((edge(e,f,_92708):-_92708='True'))]
%~ [convert(_94130),head_preconds_into_body((edge(e,f,_92708):-_92708='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[edge,e,f],'True')
</span><span class="ansi38-255165000">  (= 
    (edge e f) True)
</span><span class="ansi38-000082136">
  edge(e, f, A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((edge(g,h,_141514):-_141514='True'))]
%~ [convert(_142936),head_preconds_into_body((edge(g,h,_141514):-_141514='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[edge,g,h],'True')
</span><span class="ansi38-255165000">  (= 
    (edge g h) True)
</span><span class="ansi38-000082136">
  edge(g, h, A) :-
    A='True'.

</span>

; Define the path function using facts for pathfinding.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,path,[->,'Symbol','Symbol','Bool']])
</span><span class="ansi38-255165000">  (: path 
    (-> Symbol Symbol Bool))
</span>

; A node is always connected to itself.
%~ [ convert(Convert),
%~   head_preconds_into_body((path(X,X,_203642):-_203642='True'))]
%~ [convert(_205152),head_preconds_into_body((path(X,X,_203642):-_203642='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[path,X,X],'True')
</span><span class="ansi38-255165000">  (= 
    (path $X $X) True)
</span><span class="ansi38-000082136">  :- dynamic path/3.

  path(X, X, A) :-
    A='True'.

</span>

; The path function uses facts to check edge connectivity.
%~ [ convert(Convert),
%~   head_preconds_into_body( path(X,Y,Assign_Path_Y) :-
%~                              u_assign(edge(X,Z),Assign_True_Edge) ,
%~                              u_assign('True',Assign_True_Edge) ,
%~                              u_assign(path(Z,Y),Assign_Path_Y))]
%~ [convert(_257544),head_preconds_into_body((path(X,Y,_256034):-u_assign(edge(X,Z),_257842),u_assign('True',_257842),u_assign(path(Z,Y),_256034)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[path,X,Y],[and,[edge,X,Z],[path,Z,Y]])
</span><span class="ansi38-255165000">  (= 
    (path $X $Y) 
    (and 
      (edge $X $Z) 
      (path $Z $Y)))
</span><span class="ansi38-000082136">
  path(X, Y, A) :-
    u_assign(edge(X, Z), B),
    u_assign('True', B),
    u_assign(path(Z, Y), A).

</span>

; Unit tests for the path function.

[assertEqual,[path,a,b],'True']
<span class="ansi38-000068000">!(assertEqual 
  (path a b) True)

</span>
[assertEqual,[path,a,c],'True']
<span class="ansi38-000068000">!(assertEqual 
  (path a c) True)

</span>
[assertEqual,[path,a,d],'True']
<span class="ansi38-000068000">!(assertEqual 
  (path a d) True)

</span>
[assertEqual,[path,a,f],'True']
<span class="ansi38-000068000">!(assertEqual 
  (path a f) True)

</span>
[assertEqual,[path,b,e],'True']
<span class="ansi38-000068000">!(assertEqual 
  (path b e) True)

</span>
[assertEqual,[path,e,f],'True']
<span class="ansi38-000068000">!(assertEqual 
  (path e f) True)

</span><span class="ansi32">% 3,059,342 inferences, 0.999 CPU in 0.999 seconds (100% CPU, 3063561 Lips)
</span> (@ = "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/performance/pathfinding-edge.metta" 0)
doing(ansi2html -u < "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/TEE.ansi" > "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/performance/pathfinding-edge.html" )

</pre>
</body>

</html>
