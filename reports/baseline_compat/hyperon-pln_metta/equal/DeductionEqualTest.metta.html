<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>
<style type="text/css">
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-250144246 { color: #FA90F6; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-250144246 { color: #FA90F6; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content">
Script started on 2024-01-09 15:23:49-08:00 [TERM="xterm" TTY="/dev/pts/0" COLUMNS="152" LINES="150"]
; init_why(before_boot,after('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/metta_vspace/pyswip/metta_interp.pl')).
; init_phase(after_load).
; init_phase(restore_state).
; libswipl: [/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/Sav.godlike.MeTTaLog,--,--python=enable,--timeout=10,--html,--repl=false,examples/baseline_compat/hyperon-pln_metta/equal/DeductionEqualTest.metta,--halt=true]
;     (compiled_loon default)
%~   (run_vspace_server 3023)
;     (compiled_loon restore)
;    (compiled_loon goal)
; init_why(after_boot,program).
;    (compiled_loon program)
;   (began_loon toplevel)
;      (is_cmd_option python --python=enable enable)
;      (is_cmd_option timeout --timeout=10 10)
;       (is_cmd_option html --html True)
;       (is_cmd_option repl --repl=false False)

; (: user 
  (load_metta_file  &self examples/baseline_compat/hyperon-pln_metta/equal/DeductionEqualTest.metta))
;                (track_load_into_file /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/equal/DeductionEqualTest.metta)
;                              (load_answer_file /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/equal/DeductionEqualTest.metta.answers /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/equal/DeductionEqualTest.metta)
;                              (= 1 "+ '[' 0 -eq 1 ']'")
;                               (= 1 "+ echo 'Doing: timeout --foreground --kill-after=5 --signal=SIGINT 121 time metta /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/equal/DeductionEqualTest.metta'")
;                               (= 1 "Doing: timeout --foreground --kill-after=5 --signal=SIGINT 121 time metta /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/equal/DeductionEqualTest.metta")
;                                (= 1 "+ eval 'timeout --foreground --kill-after=5 --signal=SIGINT 121 time metta /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/equal/DeductionEqualTest.metta'")
;                                (= 1 "++ timeout --foreground --kill-after=5 --signal=SIGINT 121 time metta /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/equal/DeductionEqualTest.metta")
;                                (= 1 "[()]")
;                                 (= 2 "[(≞ (→ P R) (deduction-formula ((STV 1 0.1) (STV 1 0.1) (STV 1 0.1) (STV 1 0.5) (STV 1 0.5))))]")
;                                 (= 3 "[(≞ (→ P S) (deduction-formula ((STV 1 0.1) (STV 1 0.1) (STV 1 0.1) (deduction-formula ((STV 1 0.1) (STV 1 0.1) (STV 1 0.1) (STV 1 0.5) (STV 1 0.5))) (STV 1 0.5))))]")
;                                  (= 4 "0.06user 0.00system 0:00.06elapsed 100%CPU (0avgtext+0avgdata 26352maxresident)k")
;                                  (= 4 "0inputs+0outputs (0major+3432minor)pagefaults 0swaps")
;;; Test Deduction equality Rule
<span class="ansi38-013099040">!(import! &self DeductionEqual.metta)

</span>;                                        (load_answer_file /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/equal/DeductionEqual.metta.answers /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/equal/DeductionEqual.metta)
;;; Test 1:
;;; MeTTa port for deduction PLN rule
;;; using equality, =
;;;
;;; (≞ P ptv)
;;; (≞ Q qtv)
;;; (≞ R rtv)
;;; (≞ (→ P Q) tv1)
;;; (≞ (→ Q R) tv2)
;;; ⊢
;;; (≞ (→ P R) TV)
;;;
;;; where ptv, qtv, rtv, tv1 and tv2 are truth values of the
;;; premises P, Q, R, (→ P Q) and (→ Q R) respectively.
;;; TV represents the resulting truth value of the conclusion.

;;; Import formula functions
<span class="ansi38-013099040">!(import! &self ../common/formula/DeductionFormula.metta)

</span>;                                         (load_answer_file /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/formula/DeductionFormula.metta.answers /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/formula/DeductionFormula.metta)
;;;;;;;;;;;;;;;;;;;;;;
;;; Rule Definition ;;
;;;;;;;;;;;;;;;;;;;;;;
;;; Forward
;;; Formula and other functions used for the deduction rule

;;; Import modules
<span class="ansi38-013099040">!(import! &self ../truthvalue/TruthValue.metta)

</span>;                                         (load_answer_file /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/truthvalue/TruthValue.metta.answers /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/truthvalue/TruthValue.metta)
;;; Truth value type definition

;;; Import modules
<span class="ansi38-013099040">!(import! &self ../Num.metta)

</span>;                                         (load_answer_file /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/Num.metta.answers /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/Num.metta)
;;;;;;;;;;;
;;; Type ;;
;;;;;;;;;;;
;;; Collection of functions operating on numbers

;;; Define max
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,max,[->,'$VAR'(a),'$VAR'(a),'$VAR'(a)]])
</span><span class="ansi38-255165000">(: max 
  (-> $a $a $a))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[max,'$VAR'(x),'$VAR'(y)],[if,[>,'$VAR'(x),'$VAR'(y)],'$VAR'(x),'$VAR'(y)]])
</span><span class="ansi38-255165000">(= 
  (max $x $y) 
  (if 
    (> $x $y) $x $y))
</span>

;;; Define min
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,min,[->,'$VAR'(a),'$VAR'(a),'$VAR'(a)]])
</span><span class="ansi38-255165000">(: min 
  (-> $a $a $a))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[min,'$VAR'(x),'$VAR'(y)],[if,[<,'$VAR'(x),'$VAR'(y)],'$VAR'(x),'$VAR'(y)]])
</span><span class="ansi38-255165000">(= 
  (min $x $y) 
  (if 
    (< $x $y) $x $y))
</span>

;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,clamp,[->,'$VAR'(a),'$VAR'(a),'$VAR'(a),'$VAR'(a)]])
</span><span class="ansi38-255165000">(: clamp 
  (-> $a $a $a $a))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[clamp,'$VAR'(x),'$VAR'(l),'$VAR'(u)],[max,'$VAR'(l),[min,'$VAR'(u),'$VAR'(x)]]])
</span><span class="ansi38-255165000">(= 
  (clamp $x $l $u) 
  (max $l 
    (min $u $x)))
</span>

;;; Define abs
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,abs,[->,'$VAR'(a),'$VAR'(a)]])
</span><span class="ansi38-255165000">(: abs 
  (-> $a $a))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[abs,'$VAR'(x)],[if,[<,'$VAR'(x),0],[*,-1,'$VAR'(x)],'$VAR'(x)]])
</span><span class="ansi38-255165000">(= 
  (abs $x) 
  (if 
    (< $x 0) 
    (* -1 $x) $x))
</span>

;;; Define <=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,<=,[->,'$VAR'(a),'$VAR'(a),'Bool']])
</span><span class="ansi38-255165000">(: <= 
  (-> $a $a Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[<=,'$VAR'(x),'$VAR'(y)],[or,[<,'$VAR'(x),'$VAR'(y)],[==,'$VAR'(x),'$VAR'(y)]]])
</span><span class="ansi38-255165000">(= 
  (<= $x $y) 
  (or 
    (< $x $y) 
    (== $x $y)))
</span>

;;; Define >=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,>=,[->,'$VAR'(a),'$VAR'(a),'Bool']])
</span><span class="ansi38-255165000">(: >= 
  (-> $a $a Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[>=,'$VAR'(x),'$VAR'(y)],[or,[>,'$VAR'(x),'$VAR'(y)],[==,'$VAR'(x),'$VAR'(y)]]])
</span><span class="ansi38-255165000">(= 
  (>= $x $y) 
  (or 
    (> $x $y) 
    (== $x $y)))
</span>

;;; Define approximately equal
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,approxEq,[->,'$VAR'(a),'$VAR'(a),'$VAR'(a),'Bool']])
</span><span class="ansi38-255165000">(: approxEq 
  (-> $a $a $a Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[approxEq,'$VAR'(x),'$VAR'(y),'$VAR'(epsilon)],[<=,[abs,[-,'$VAR'(x),'$VAR'(y)]],'$VAR'(epsilon)]])
</span><span class="ansi38-255165000">(= 
  (approxEq $x $y $epsilon) 
  (<= 
    (abs 
      (- $x $y)) $epsilon))
</span>

;;; Define Nat
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'Nat','Type'])
</span><span class="ansi38-255165000">(: Nat Type)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'Z','Nat'])
</span><span class="ansi38-255165000">(: Z Nat)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'S',[->,'Nat','Nat']])
</span><span class="ansi38-255165000">(: S 
  (-> Nat Nat))
</span>

;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,fromNumber,[->,'Number','Nat']])
</span><span class="ansi38-255165000">(: fromNumber 
  (-> Number Nat))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[fromNumber,'$VAR'(n)],[if,[<=,'$VAR'(n),0],'Z',['S',[fromNumber,[-,'$VAR'(n),1]]]]])
</span><span class="ansi38-255165000">(= 
  (fromNumber $n) 
  (if 
    (<= $n 0) Z 
    (S 
      (fromNumber 
        (- $n 1)))))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,fromNat,[->,'Nat','Number']])
</span><span class="ansi38-255165000">(: fromNat 
  (-> Nat Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[fromNat,'Z'],0])
</span><span class="ansi38-255165000">(= 
  (fromNat Z) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[fromNat,['S','$VAR'(k)]],[+,1,[fromNat,'$VAR'(k)]]])
</span><span class="ansi38-255165000">(= 
  (fromNat 
    (S $k)) 
  (+ 1 
    (fromNat $k)))
</span>

;;; Define a generic less than operator, â©», for Nat.  < cannot be used
;;; because it is a built-in, its type is hardwired and cannot be
;;; overloaded.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'â©»',[->,'Nat','Nat','Bool']])
</span><span class="ansi38-255165000">(: â©» 
  (-> Nat Nat Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['â©»',_,'Z'],'False'])
</span><span class="ansi38-255165000">(= 
  (â©» $_ Z) False)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['â©»','Z',['S',_]],'True'])
</span><span class="ansi38-255165000">(= 
  (â©» Z 
    (S $_)) True)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['â©»',['S','$VAR'(x)],['S','$VAR'(y)]],['â©»','$VAR'(x),'$VAR'(y)]])
</span><span class="ansi38-255165000">(= 
  (â©» 
    (S $x) 
    (S $y)) 
  (â©» $x $y))
</span>

;;; Overload â©» for Number.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'â©»',[->,'Number','Number','Bool']])
</span><span class="ansi38-255165000">(: â©» 
  (-> Number Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['â©»','$VAR'(x),'$VAR'(y)],[<,'$VAR'(x),'$VAR'(y)]])
</span><span class="ansi38-255165000">(= 
  (â©» $x $y) 
  (< $x $y))
</span>

;;; Return the ceiling of a non negative number.  If the number is
;;; negative it returns 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,ceil,[->,'Number','Number']])
</span><span class="ansi38-255165000">(: ceil 
  (-> Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[ceil,'$VAR'(n)],[fromNat,[fromNumber,'$VAR'(n)]]])
</span><span class="ansi38-255165000">(= 
  (ceil $n) 
  (fromNat 
    (fromNumber $n)))
</span>

;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'number->bool',[->,'Number','Bool']])
</span><span class="ansi38-255165000">(: number->bool 
  (-> Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['number->bool','$VAR'(x)],[<,0,'$VAR'(x)]])
</span><span class="ansi38-255165000">(= 
  (number->bool $x) 
  (< 0 $x))
</span>

;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'bool->number',[->,'Bool','Number']])
</span><span class="ansi38-255165000">(: bool->number 
  (-> Bool Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['bool->number','False'],0])
</span><span class="ansi38-255165000">(= 
  (bool->number False) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['bool->number','True'],1])
</span><span class="ansi38-255165000">(= 
  (bool->number True) 1)
</span>

;;; Define a less than type.  Note that it is purposefully different
;;; than â©» as it is a type, not an operator.  Inhabitants of (â x y)
;;; are proofs that x â©» y == True.  For now â is only axiomatized for
;;; Nat.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'â\x8D\\x83\',[->,T,T,'Type']])
</span><span class="ansi38-255165000">(: â 
  (-> $T $T Type))
</span>

;;; Zero is always less than the successor of something
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,['zero-lt-succ-axiom'],[->,'Atom']])
</span><span class="ansi38-255165000">(: 
  (zero-lt-succ-axiom) 
  (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['zero-lt-succ-axiom'],[:,'ZeroLTSucc',['â\x8D\\x83\','Z',['S','$VAR'(k)]]]])
</span><span class="ansi38-255165000">(= 
  (zero-lt-succ-axiom) 
  (: ZeroLTSucc 
    (â Z 
      (S $k))))
</span>

;;; If x â y then (S x) â (S y)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,['succ-monotonicity-rule'],[->,'Atom']])
</span><span class="ansi38-255165000">(: 
  (succ-monotonicity-rule) 
  (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['succ-monotonicity-rule'],[:,'SuccMonotonicity',[->,['â\x8D\\x83\','$VAR'(x),'$VAR'(y)],['â\x8D\\x83\',['S','$VAR'(x)],['S','$VAR'(y)]]]]])
</span><span class="ansi38-255165000">(= 
  (succ-monotonicity-rule) 
  (: SuccMonotonicity 
    (-> 
      (â $x $y) 
      (â 
        (S $x) 
        (S $y)))))
</span>

Deterministic: <span class="ansi33">Empty

</span>; Execution took 0.087 secs. (87.22 milliseconds) 
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'TruthValue','Type'])
</span><span class="ansi38-255165000">(: TruthValue Type)
</span>

;;;;;;;;;;;;;;;;;;;
;;; Constructors ;;
;;;;;;;;;;;;;;;;;;;
;;; Boolean TV constructor
;;; TODO: alternatively we could have (: â¤ TruthValue) and (: â¥ TruthValue)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'Bl',[->,'Bool','TruthValue']])
</span><span class="ansi38-255165000">(: Bl 
  (-> Bool TruthValue))
</span>

;;; First order probability TV constructor, i.e. mere probability.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'Pr',[->,'Number','TruthValue']])
</span><span class="ansi38-255165000">(: Pr 
  (-> Number TruthValue))
</span>

;;; Simple Truth Value.  A Second order probability TV constructor,
;;; i.e. probability and confidence.  The probability is in fact the
;;; mode of the corresponding beta distribution.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'STV',[->,'Number','Number','TruthValue']])
</span><span class="ansi38-255165000">(: STV 
  (-> Number Number TruthValue))
</span>

;;;;;;;;;;;;;;;;
;;; Constants ;;
;;;;;;;;;;;;;;;;
;;; For now the underlying beta distributions have a Jeffreys prior,
;;; i.e. the prior alpha and beta are 0.5.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'prior-alpha',[->,'Number']])
</span><span class="ansi38-255165000">(: prior-alpha 
  (-> Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['prior-alpha'],0.5])
</span><span class="ansi38-255165000">(= 
  (prior-alpha) 0.5)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'prior-beta',[->,'Number']])
</span><span class="ansi38-255165000">(: prior-beta 
  (-> Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['prior-beta'],0.5])
</span><span class="ansi38-255165000">(= 
  (prior-beta) 0.5)
</span>

;;; Lookahead
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,lookahead,[->,'Number']])
</span><span class="ansi38-255165000">(: lookahead 
  (-> Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[lookahead],1.0])
</span><span class="ansi38-255165000">(= 
  (lookahead) 1.0)
</span>

;;; Maximum supported count (till +inf is supported, possibly).
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'max-count',[->,'Number']])
</span><span class="ansi38-255165000">(: max-count 
  (-> Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['max-count'],1000000000.0])
</span><span class="ansi38-255165000">(= 
  (max-count) 1000000000.0)
</span>

;;;;;;;;;;;;;;
;;; Methods ;;
;;;;;;;;;;;;;;
;;; Convert count to confidence using the formula
;;;
;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'count->confidence',[->,'Number','Number']])
</span><span class="ansi38-255165000">(: count->confidence 
  (-> Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['count->confidence','$VAR'(cnt)],[/,'$VAR'(cnt),[+,'$VAR'(cnt),[lookahead]]]])
</span><span class="ansi38-255165000">(= 
  (count->confidence $cnt) 
  (/ $cnt 
    (+ $cnt 
      (lookahead))))
</span>

;;; Convert confidence to count using the formula
;;;
;;; count = (confidence * lookahead) / (1 - confidence)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'confidence->count',[->,'Number','Number']])
</span><span class="ansi38-255165000">(: confidence->count 
  (-> Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['confidence->count','$VAR'(conf)],[if,[approxEq,1.0,'$VAR'(conf),1.0e-9],['max-count'],[/,[*,'$VAR'(conf),[lookahead]],[-,1.0,'$VAR'(conf)]]]])
</span><span class="ansi38-255165000">(= 
  (confidence->count $conf) 
  (if 
    (approxEq 1.0 $conf 1.0e-9) 
    (max-count) 
    (/ 
      (* $conf 
        (lookahead)) 
      (- 1.0 $conf))))
</span>

;;; Increment the negative count of a given truth value, by
;;; incrementing its total count without incrementing the positive
;;; count.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'inc-neg-count',[->,'TruthValue','TruthValue']])
</span><span class="ansi38-255165000">(: inc-neg-count 
  (-> TruthValue TruthValue))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['inc-neg-count',['STV','$VAR'(s),'$VAR'(c)]],['let*',[['$VAR'(tot_cnt),['confidence->count','$VAR'(c)]],['$VAR'(pos_cnt),[*,'$VAR'(s),'$VAR'(tot_cnt)]],['$VAR'(new_tot_cnt),[+,'$VAR'(tot_cnt),1]]],['STV',[/,'$VAR'(pos_cnt),'$VAR'(new_tot_cnt)],['count->confidence','$VAR'(new_tot_cnt)]]]])
</span><span class="ansi38-255165000">(= 
  (inc-neg-count 
    (STV $s $c)) 
  (let* 
    ( ($tot_cnt 
        (confidence->count $c)) 
      ($pos_cnt 
        (* $s $tot_cnt)) 
      ($new_tot_cnt 
        (+ $tot_cnt 1))) 
    (STV 
      (/ $pos_cnt $new_tot_cnt) 
      (count->confidence $new_tot_cnt))))
</span>

;;; Increment the positive count of a given truth value, by
;;; incrementing its total count and its positive count.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'inc-pos-count',[->,'TruthValue','TruthValue']])
</span><span class="ansi38-255165000">(: inc-pos-count 
  (-> TruthValue TruthValue))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['inc-pos-count',['STV','$VAR'(s),'$VAR'(c)]],['let*',[['$VAR'(tot_cnt),['confidence->count','$VAR'(c)]],['$VAR'(pos_cnt),[*,'$VAR'(s),'$VAR'(tot_cnt)]],['$VAR'(new_pos_cnt),[+,'$VAR'(pos_cnt),1]],['$VAR'(new_tot_cnt),[+,'$VAR'(tot_cnt),1]]],['STV',[/,'$VAR'(new_pos_cnt),'$VAR'(new_tot_cnt)],['count->confidence','$VAR'(new_tot_cnt)]]]])
</span><span class="ansi38-255165000">(= 
  (inc-pos-count 
    (STV $s $c)) 
  (let* 
    ( ($tot_cnt 
        (confidence->count $c)) 
      ($pos_cnt 
        (* $s $tot_cnt)) 
      ($new_pos_cnt 
        (+ $pos_cnt 1)) 
      ($new_tot_cnt 
        (+ $tot_cnt 1))) 
    (STV 
      (/ $new_pos_cnt $new_tot_cnt) 
      (count->confidence $new_tot_cnt))))
</span>

;;; Return the first order probability mode of the second order
;;; distribution associated to a truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,mode,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: mode 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mode,['Bl','True']],1.0])
</span><span class="ansi38-255165000">(= 
  (mode 
    (Bl True)) 1.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mode,['Bl','False']],0.0])
</span><span class="ansi38-255165000">(= 
  (mode 
    (Bl False)) 0.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mode,['Pr','$VAR'(pr)]],'$VAR'(pr)])
</span><span class="ansi38-255165000">(= 
  (mode 
    (Pr $pr)) $pr)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mode,['STV','$VAR'(pr),_]],'$VAR'(pr)])
</span><span class="ansi38-255165000">(= 
  (mode 
    (STV $pr $_)) $pr)
</span>

;;; Return the total count of a truth value.  For truth values not
;;; capturing a notion of confidence, such as Bl or Pr then the count
;;; is assumed to be a very large number (cause +inf does not seem to
;;; be supported at the moment).
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,count,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: count 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[count,['Bl',_]],['max-count']])
</span><span class="ansi38-255165000">(= 
  (count 
    (Bl $_)) 
  (max-count))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[count,['Pr',_]],['max-count']])
</span><span class="ansi38-255165000">(= 
  (count 
    (Pr $_)) 
  (max-count))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[count,['STV',_,'$VAR'(conf)]],['confidence->count','$VAR'(conf)]])
</span><span class="ansi38-255165000">(= 
  (count 
    (STV $_ $conf)) 
  (confidence->count $conf))
</span>

;;; Return the confidence of a truth value.  For truth values not
;;; capturing a notion of confidence, such as Bl or Pr then the
;;; confidence is assumed to be 1.0.  For truth values capturing a
;;; notion of confidence, such as STV, the formula to convert a count
;;; into confidence is as follows
;;;
;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,confidence,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: confidence 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[confidence,['Bl',_]],1.0])
</span><span class="ansi38-255165000">(= 
  (confidence 
    (Bl $_)) 1.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[confidence,['Pr',_]],1.0])
</span><span class="ansi38-255165000">(= 
  (confidence 
    (Pr $_)) 1.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[confidence,['STV',_,'$VAR'(conf)]],'$VAR'(conf)])
</span><span class="ansi38-255165000">(= 
  (confidence 
    (STV $_ $conf)) $conf)
</span>

;;; Return the positive count of a truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'pos-count',[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: pos-count 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['pos-count','$VAR'(tv)],[*,[mode,'$VAR'(tv)],[count,'$VAR'(tv)]]])
</span><span class="ansi38-255165000">(= 
  (pos-count $tv) 
  (* 
    (mode $tv) 
    (count $tv)))
</span>

;;; Return the negative count of a truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'neg-count',[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: neg-count 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['neg-count','$VAR'(tv)],[*,[-,1,[mode,'$VAR'(tv)]],[count,'$VAR'(tv)]]])
</span><span class="ansi38-255165000">(= 
  (neg-count $tv) 
  (* 
    (- 1 
      (mode $tv)) 
    (count $tv)))
</span>

;;; Return the posterior alpha of a truth value
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'post-alpha',[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: post-alpha 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['post-alpha','$VAR'(tv)],[+,['prior-alpha'],['pos-count','$VAR'(tv)]]])
</span><span class="ansi38-255165000">(= 
  (post-alpha $tv) 
  (+ 
    (prior-alpha) 
    (pos-count $tv)))
</span>

;;; Return the posterior beta of a truth value
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'post-beta',[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: post-beta 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['post-beta','$VAR'(tv)],[+,['prior-beta'],['neg-count','$VAR'(tv)]]])
</span><span class="ansi38-255165000">(= 
  (post-beta $tv) 
  (+ 
    (prior-beta) 
    (neg-count $tv)))
</span>

;;; Return the first order probability mean of the second order
;;; distribution associated to a truth value.  For truth values not
;;; capturing a notion of confidence, such as Bl or Pr then the
;;; confidence is assumed to be 1.0.  For truth values capturing a
;;; notion of confidence, such as STV, a beta distribution is assumed.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,mean,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: mean 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mean,['Bl','True']],1.0])
</span><span class="ansi38-255165000">(= 
  (mean 
    (Bl True)) 1.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mean,['Bl','False']],0.0])
</span><span class="ansi38-255165000">(= 
  (mean 
    (Bl False)) 0.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mean,['Pr','$VAR'(pr)]],'$VAR'(pr)])
</span><span class="ansi38-255165000">(= 
  (mean 
    (Pr $pr)) $pr)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mean,['STV','$VAR'(pr),'$VAR'(conf)]],['let*',[['$VAR'(a),['post-alpha',['STV','$VAR'(pr),'$VAR'(conf)]]],['$VAR'(b),['post-beta',['STV','$VAR'(pr),'$VAR'(conf)]]]],[/,'$VAR'(a),[+,'$VAR'(a),'$VAR'(b)]]]])
</span><span class="ansi38-255165000">(= 
  (mean 
    (STV $pr $conf)) 
  (let* 
    ( ($a 
        (post-alpha 
          (STV $pr $conf))) 
      ($b 
        (post-beta 
          (STV $pr $conf)))) 
    (/ $a 
      (+ $a $b))))
</span>

Last Result(2): <span class="ansi33">Empty

</span>; Execution took 0.328 secs. (327.51 milliseconds) 
<span class="ansi38-013099040">!(import! &self ../Num.metta)

</span>;                                         (load_answer_file /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/Num.metta.answers /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/common/Num.metta)
;; Consistency Conditions
;;; Collection of functions operating on numbers

;;; Define max
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,max,[->,'$VAR'(a),'$VAR'(a),'$VAR'(a)]])
</span><span class="ansi38-255165000">(: max 
  (-> $a $a $a))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[max,'$VAR'(x),'$VAR'(y)],[if,[>,'$VAR'(x),'$VAR'(y)],'$VAR'(x),'$VAR'(y)]])
</span><span class="ansi38-255165000">(= 
  (max $x $y) 
  (if 
    (> $x $y) $x $y))
</span>

;;; Define min
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,min,[->,'$VAR'(a),'$VAR'(a),'$VAR'(a)]])
</span><span class="ansi38-255165000">(: min 
  (-> $a $a $a))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[min,'$VAR'(x),'$VAR'(y)],[if,[<,'$VAR'(x),'$VAR'(y)],'$VAR'(x),'$VAR'(y)]])
</span><span class="ansi38-255165000">(= 
  (min $x $y) 
  (if 
    (< $x $y) $x $y))
</span>

;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,clamp,[->,'$VAR'(a),'$VAR'(a),'$VAR'(a),'$VAR'(a)]])
</span><span class="ansi38-255165000">(: clamp 
  (-> $a $a $a $a))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[clamp,'$VAR'(x),'$VAR'(l),'$VAR'(u)],[max,'$VAR'(l),[min,'$VAR'(u),'$VAR'(x)]]])
</span><span class="ansi38-255165000">(= 
  (clamp $x $l $u) 
  (max $l 
    (min $u $x)))
</span>

;;; Define abs
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,abs,[->,'$VAR'(a),'$VAR'(a)]])
</span><span class="ansi38-255165000">(: abs 
  (-> $a $a))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[abs,'$VAR'(x)],[if,[<,'$VAR'(x),0],[*,-1,'$VAR'(x)],'$VAR'(x)]])
</span><span class="ansi38-255165000">(= 
  (abs $x) 
  (if 
    (< $x 0) 
    (* -1 $x) $x))
</span>

;;; Define <=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,<=,[->,'$VAR'(a),'$VAR'(a),'Bool']])
</span><span class="ansi38-255165000">(: <= 
  (-> $a $a Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[<=,'$VAR'(x),'$VAR'(y)],[or,[<,'$VAR'(x),'$VAR'(y)],[==,'$VAR'(x),'$VAR'(y)]]])
</span><span class="ansi38-255165000">(= 
  (<= $x $y) 
  (or 
    (< $x $y) 
    (== $x $y)))
</span>

;;; Define >=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,>=,[->,'$VAR'(a),'$VAR'(a),'Bool']])
</span><span class="ansi38-255165000">(: >= 
  (-> $a $a Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[>=,'$VAR'(x),'$VAR'(y)],[or,[>,'$VAR'(x),'$VAR'(y)],[==,'$VAR'(x),'$VAR'(y)]]])
</span><span class="ansi38-255165000">(= 
  (>= $x $y) 
  (or 
    (> $x $y) 
    (== $x $y)))
</span>

;;; Define approximately equal
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,approxEq,[->,'$VAR'(a),'$VAR'(a),'$VAR'(a),'Bool']])
</span><span class="ansi38-255165000">(: approxEq 
  (-> $a $a $a Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[approxEq,'$VAR'(x),'$VAR'(y),'$VAR'(epsilon)],[<=,[abs,[-,'$VAR'(x),'$VAR'(y)]],'$VAR'(epsilon)]])
</span><span class="ansi38-255165000">(= 
  (approxEq $x $y $epsilon) 
  (<= 
    (abs 
      (- $x $y)) $epsilon))
</span>

;;; Define Nat
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'Nat','Type'])
</span><span class="ansi38-255165000">(: Nat Type)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'Z','Nat'])
</span><span class="ansi38-255165000">(: Z Nat)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'S',[->,'Nat','Nat']])
</span><span class="ansi38-255165000">(: S 
  (-> Nat Nat))
</span>

;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,fromNumber,[->,'Number','Nat']])
</span><span class="ansi38-255165000">(: fromNumber 
  (-> Number Nat))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[fromNumber,'$VAR'(n)],[if,[<=,'$VAR'(n),0],'Z',['S',[fromNumber,[-,'$VAR'(n),1]]]]])
</span><span class="ansi38-255165000">(= 
  (fromNumber $n) 
  (if 
    (<= $n 0) Z 
    (S 
      (fromNumber 
        (- $n 1)))))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,fromNat,[->,'Nat','Number']])
</span><span class="ansi38-255165000">(: fromNat 
  (-> Nat Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[fromNat,'Z'],0])
</span><span class="ansi38-255165000">(= 
  (fromNat Z) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[fromNat,['S','$VAR'(k)]],[+,1,[fromNat,'$VAR'(k)]]])
</span><span class="ansi38-255165000">(= 
  (fromNat 
    (S $k)) 
  (+ 1 
    (fromNat $k)))
</span>

;;; Define a generic less than operator, â©», for Nat.  < cannot be used
;;; because it is a built-in, its type is hardwired and cannot be
;;; overloaded.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'â©»',[->,'Nat','Nat','Bool']])
</span><span class="ansi38-255165000">(: â©» 
  (-> Nat Nat Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['â©»',_,'Z'],'False'])
</span><span class="ansi38-255165000">(= 
  (â©» $_ Z) False)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['â©»','Z',['S',_]],'True'])
</span><span class="ansi38-255165000">(= 
  (â©» Z 
    (S $_)) True)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['â©»',['S','$VAR'(x)],['S','$VAR'(y)]],['â©»','$VAR'(x),'$VAR'(y)]])
</span><span class="ansi38-255165000">(= 
  (â©» 
    (S $x) 
    (S $y)) 
  (â©» $x $y))
</span>

;;; Overload â©» for Number.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'â©»',[->,'Number','Number','Bool']])
</span><span class="ansi38-255165000">(: â©» 
  (-> Number Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['â©»','$VAR'(x),'$VAR'(y)],[<,'$VAR'(x),'$VAR'(y)]])
</span><span class="ansi38-255165000">(= 
  (â©» $x $y) 
  (< $x $y))
</span>

;;; Return the ceiling of a non negative number.  If the number is
;;; negative it returns 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,ceil,[->,'Number','Number']])
</span><span class="ansi38-255165000">(: ceil 
  (-> Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[ceil,'$VAR'(n)],[fromNat,[fromNumber,'$VAR'(n)]]])
</span><span class="ansi38-255165000">(= 
  (ceil $n) 
  (fromNat 
    (fromNumber $n)))
</span>

;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'number->bool',[->,'Number','Bool']])
</span><span class="ansi38-255165000">(: number->bool 
  (-> Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['number->bool','$VAR'(x)],[<,0,'$VAR'(x)]])
</span><span class="ansi38-255165000">(= 
  (number->bool $x) 
  (< 0 $x))
</span>

;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'bool->number',[->,'Bool','Number']])
</span><span class="ansi38-255165000">(: bool->number 
  (-> Bool Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['bool->number','False'],0])
</span><span class="ansi38-255165000">(= 
  (bool->number False) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['bool->number','True'],1])
</span><span class="ansi38-255165000">(= 
  (bool->number True) 1)
</span>

;;; Define a less than type.  Note that it is purposefully different
;;; than â©» as it is a type, not an operator.  Inhabitants of (â x y)
;;; are proofs that x â©» y == True.  For now â is only axiomatized for
;;; Nat.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'â\x8D\\x83\',[->,T,T,'Type']])
</span><span class="ansi38-255165000">(: â 
  (-> $T $T Type))
</span>

;;; Zero is always less than the successor of something
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,['zero-lt-succ-axiom'],[->,'Atom']])
</span><span class="ansi38-255165000">(: 
  (zero-lt-succ-axiom) 
  (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['zero-lt-succ-axiom'],[:,'ZeroLTSucc',['â\x8D\\x83\','Z',['S','$VAR'(k)]]]])
</span><span class="ansi38-255165000">(= 
  (zero-lt-succ-axiom) 
  (: ZeroLTSucc 
    (â Z 
      (S $k))))
</span>

;;; If x â y then (S x) â (S y)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,['succ-monotonicity-rule'],[->,'Atom']])
</span><span class="ansi38-255165000">(: 
  (succ-monotonicity-rule) 
  (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['succ-monotonicity-rule'],[:,'SuccMonotonicity',[->,['â\x8D\\x83\','$VAR'(x),'$VAR'(y)],['â\x8D\\x83\',['S','$VAR'(x)],['S','$VAR'(y)]]]]])
</span><span class="ansi38-255165000">(= 
  (succ-monotonicity-rule) 
  (: SuccMonotonicity 
    (-> 
      (â $x $y) 
      (â 
        (S $x) 
        (S $y)))))
</span>

Deterministic: <span class="ansi33">Empty

</span>; Execution took 0.087 secs. (86.93 milliseconds) 
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'smallest-intersection-probability',[->,'Number','Number','Number']])
</span><span class="ansi38-255165000">(: smallest-intersection-probability 
  (-> Number Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['smallest-intersection-probability',As,Bs],[clamp,[/,[-,[+,As,Bs],1],As],0,1]])
</span><span class="ansi38-255165000">(= 
  (smallest-intersection-probability $As $Bs) 
  (clamp 
    (/ 
      (- 
        (+ $As $Bs) 1) $As) 0 1))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'largest-intersection-probability',[->,'Number','Number','Number']])
</span><span class="ansi38-255165000">(: largest-intersection-probability 
  (-> Number Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['largest-intersection-probability',As,Bs],[clamp,[/,Bs,As],0,1]])
</span><span class="ansi38-255165000">(= 
  (largest-intersection-probability $As $Bs) 
  (clamp 
    (/ $Bs $As) 0 1))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'conditional-probability-consistency',[->,'Number','Number','Number','Bool']])
</span><span class="ansi38-255165000">(: conditional-probability-consistency 
  (-> Number Number Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['conditional-probability-consistency',As,Bs,ABs],[and,[<,0,As],[and,[<=,['smallest-intersection-probability',As,Bs],ABs],[<=,ABs,['largest-intersection-probability',As,Bs]]]]])
</span><span class="ansi38-255165000">(= 
  (conditional-probability-consistency $As $Bs $ABs) 
  (and 
    (< 0 $As) 
    (and 
      (<= 
        (smallest-intersection-probability $As $Bs) $ABs) 
      (<= $ABs 
        (largest-intersection-probability $As $Bs)))))
</span>

;;; Main Formula
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'simple-deduction-strength-formula',[->,'Number','Number','Number','Number','Number','Number']])
</span><span class="ansi38-255165000">(: simple-deduction-strength-formula 
  (-> Number Number Number Number Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['simple-deduction-strength-formula',As,Bs,Cs,ABs,BCs],[if,[and,['conditional-probability-consistency',As,Bs,ABs],['conditional-probability-consistency',Bs,Cs,BCs]],[if,[<,0.99,Bs],Cs,[+,[*,ABs,BCs],[/,[*,[-,1,ABs],[-,Cs,[*,Bs,BCs]]],[-,1,Bs]]]],0]])
</span><span class="ansi38-255165000">(= 
  (simple-deduction-strength-formula $As $Bs $Cs $ABs $BCs) 
  (if 
    (and 
      (conditional-probability-consistency $As $Bs $ABs) 
      (conditional-probability-consistency $Bs $Cs $BCs)) 
    (if 
      (< 0.99 $Bs) $Cs 
      (+ 
        (* $ABs $BCs) 
        (/ 
          (* 
            (- 1 $ABs) 
            (- $Cs 
              (* $Bs $BCs))) 
          (- 1 $Bs)))) 0))
</span>

;;; Preconditions are met
;;; sB tends to 1
;;; otherwise
;;; Preconditions are not met
;;; Alternate deduction formula hardwired for STV to make it faster.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['deduction-formula',['STV',Ps,Pc],['STV',Qs,Qc],['STV',Rs,Rc],['STV',PQs,PQc],['STV',QRs,QRc]],[if,[and,['conditional-probability-consistency',Ps,Qs,PQs],['conditional-probability-consistency',Qs,Rs,QRs]],['STV',[if,[<,0.9999,Qs],Rs,[+,[*,PQs,QRs],[/,[*,[-,1,PQs],[-,Rs,[*,Qs,QRs]]],[-,1,Qs]]]],[min,Pc,[min,Qc,[min,Rc,[min,PQc,QRc]]]]],['STV',1,0]]])
</span><span class="ansi38-255165000">(= 
  (deduction-formula 
    (STV $Ps $Pc) 
    (STV $Qs $Qc) 
    (STV $Rs $Rc) 
    (STV $PQs $PQc) 
    (STV $QRs $QRc)) 
  (if 
    (and 
      (conditional-probability-consistency $Ps $Qs $PQs) 
      (conditional-probability-consistency $Qs $Rs $QRs)) 
    (STV 
      (if 
        (< 0.9999 $Qs) $Rs 
        (+ 
          (* $PQs $QRs) 
          (/ 
            (* 
              (- 1 $PQs) 
              (- $Rs 
                (* $Qs $QRs))) 
            (- 1 $Qs)))) 
      (min $Pc 
        (min $Qc 
          (min $Rc 
            (min $PQc $QRc))))) 
    (STV 1 0)))
</span>

Last Result(2): <span class="ansi33">Empty

</span>; Execution took 0.462 secs. (461.91 milliseconds) 
;;; Preconditions are met
;; avoid division by 0
;;; Qs tends to 1
;;; Otherwise
;;; Preconditions are not met
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[',',['â\x89\\x9E\','$VAR'(p),'$VAR'(ptv)],['â\x89\\x9E\','$VAR'(q),'$VAR'(qtv)],['â\x89\\x9E\','$VAR'(r),'$VAR'(rtv)],['â\x89\\x9E\',['â\x86\\x92\','$VAR'(p),'$VAR'(q)],'$VAR'(pqtv)],['â\x89\\x9E\',['â\x86\\x92\','$VAR'(q),'$VAR'(r)],'$VAR'(qrtv)]],['â\x89\\x9E\',['â\x86\\x92\','$VAR'(p),'$VAR'(r)],['deduction-formula',['$VAR'(ptv),'$VAR'(qtv),'$VAR'(rtv),'$VAR'(pqtv),'$VAR'(qrtv)]]]])
</span><span class="ansi38-255165000">(= 
  (, 
    (â $p $ptv) 
    (â $q $qtv) 
    (â $r $rtv) 
    (â 
      (â $p $q) $pqtv) 
    (â 
      (â $q $r) $qrtv)) 
  (â 
    (â $p $r) 
    (deduction-formula 
      ($ptv $qtv $rtv $pqtv $qrtv))))
</span>

;;; Backward
;;; Unfortunately this won't work, the interpreter cannot unify the left hand side of
;;; the equality because it contains function calls, as opposed to just constructors.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,['â\x89\\x9E\',['â\x86\\x92\','$VAR'(p),'$VAR'(r)],['deduction-formula','$VAR'(ptv),'$VAR'(qtv),'$VAR'(rtv),'$VAR'(pqtv),'$VAR'(qrtv)]],[',',['â\x89\\x9E\','$VAR'(p),'$VAR'(ptv)],['â\x89\\x9E\','$VAR'(q),'$VAR'(qtv)],['â\x89\\x9E\','$VAR'(r),'$VAR'(rtv)],['â\x89\\x9E\',['â\x86\\x92\','$VAR'(p),'$VAR'(q)],'$VAR'(pqtv)],['â\x89\\x9E\',['â\x86\\x92\','$VAR'(q),'$VAR'(r)],'$VAR'(qrtv)]]])
</span><span class="ansi38-255165000">(= 
  (â 
    (â $p $r) 
    (deduction-formula $ptv $qtv $rtv $pqtv $qrtv)) 
  (, 
    (â $p $ptv) 
    (â $q $qtv) 
    (â $r $rtv) 
    (â 
      (â $p $q) $pqtv) 
    (â 
      (â $q $r) $qrtv)))
</span>

Last Result(3): <span class="ansi33">Empty

</span>; Execution took 0.470 secs. (469.53 milliseconds) 
<span class="ansi38-255165000">;; In file as:  
</span><span class="ansi1 ansi38-255238088">!(, 
  (â P 
    (STV 1 0.1)) 
  (â Q 
    (STV 1 0.1)) 
  (â R 
    (STV 1 0.1)) 
  (â 
    (â P Q) 
    (STV 1 0.5)) 
  (â 
    (â Q R) 
    (STV 1 0.5)))
</span>;; To unit test case:
<span class="ansi38-013099040">!(assertEqualToResult 
  (, 
    (â P 
      (STV 1 0.1)) 
    (â Q 
      (STV 1 0.1)) 
    (â R 
      (STV 1 0.1)) 
    (â 
      (â P Q) 
      (STV 1 0.5)) 
    (â 
      (â Q R) 
      (STV 1 0.5))) 
  ( (≞ 
      (→ P R) 
      (deduction-formula 
        ( (STV 1 0.1) 
          (STV 1 0.1) 
          (STV 1 0.1) 
          (STV 1 0.5) 
          (STV 1 0.5))))))

</span><span class="ansi38-250144246">; !(, (â P (STV 1 0.1)) (â Q (STV 1 0.1)) (â R (STV 1 0.1)) (â (â P Q) (STV 1 0.5)) (â (â Q R) (STV 1 0.5)))
</span>;<h3 id="EQUAL.DEDUCTIONEQUALTEST.01">;; EQUAL.DEDUCTIONEQUALTEST.01</h3>
; 
; EVAL TEST
; took 0.003 secs. (2.68 milliseconds) 
<span class="ansi31">(loonit_failureR 
  (equal_enough_for_test  
    ( (â 
        (â Q R) 
        (STV 1 0.5))) 
    ( (≞ 
        (→ P R) 
        (deduction-formula 
          ( (STV 1 0.1) 
            (STV 1 0.1) 
            (STV 1 0.1) 
            (STV 1 0.5) 
            (STV 1 0.5)))))))
</span>Deterministic: <span class="ansi33">
(got 
  ( (â 
      (â Q R) 
      (STV 1 0.5))) expected 
  ( (≞ 
      (→ P R) 
      (deduction-formula 
        ( (STV 1 0.1) 
          (STV 1 0.1) 
          (STV 1 0.1) 
          (STV 1 0.5) 
          (STV 1 0.5))))))

</span>; Execution took 0.010 secs. (10.24 milliseconds) 
;;; Test 2: Apply deduction rule over the result
;;; we get from test 1 as an input.
<span class="ansi38-255165000">;; In file as:  
</span><span class="ansi1 ansi38-255238088">!(let $PR 
  (, 
    (â P 
      (STV 1 0.1)) 
    (â Q 
      (STV 1 0.1)) 
    (â R 
      (STV 1 0.1)) 
    (â 
      (â P Q) 
      (STV 1 0.5)) 
    (â 
      (â Q R) 
      (STV 1 0.5))) 
  (, 
    (â P 
      (STV 1 0.1)) 
    (â R 
      (STV 1 0.1)) 
    (â S 
      (STV 1 0.1)) $PR 
    (â 
      (â R S) 
      (STV 1 0.5))))
</span>;; To unit test case:
<span class="ansi38-013099040">!(assertEqualToResult 
  (let $PR 
    (, 
      (â P 
        (STV 1 0.1)) 
      (â Q 
        (STV 1 0.1)) 
      (â R 
        (STV 1 0.1)) 
      (â 
        (â P Q) 
        (STV 1 0.5)) 
      (â 
        (â Q R) 
        (STV 1 0.5))) 
    (, 
      (â P 
        (STV 1 0.1)) 
      (â R 
        (STV 1 0.1)) 
      (â S 
        (STV 1 0.1)) $PR 
      (â 
        (â R S) 
        (STV 1 0.5)))) 
  ( (≞ 
      (→ P S) 
      (deduction-formula 
        ( (STV 1 0.1) 
          (STV 1 0.1) 
          (STV 1 0.1) 
          (deduction-formula 
            ( (STV 1 0.1) 
              (STV 1 0.1) 
              (STV 1 0.1) 
              (STV 1 0.5) 
              (STV 1 0.5))) 
          (STV 1 0.5))))))

</span><span class="ansi38-250144246">; !(let $PR (, (â P (STV 1 0.1)) (â Q (STV 1 0.1)) (â R (STV 1 0.1)) (â (â P Q) (STV 1 0.5)) (â (â Q R) (STV 1 0.5))) (, (â P (STV 1 0.1)) (â R (STV 1 0.1)) (â S (STV 1 0.1)) $PR (â (â R S) (STV 1 0.5))))
</span>;<h3 id="EQUAL.DEDUCTIONEQUALTEST.02">;; EQUAL.DEDUCTIONEQUALTEST.02</h3>
; 
; EVAL TEST
; took 0.006 secs. (5.60 milliseconds) 
<span class="ansi31">(loonit_failureR 
  (equal_enough_for_test  
    ( (â 
        (â R S) 
        (STV 1 0.5))) 
    ( (≞ 
        (→ P S) 
        (deduction-formula 
          ( (STV 1 0.1) 
            (STV 1 0.1) 
            (STV 1 0.1) 
            (deduction-formula 
              ( (STV 1 0.1) 
                (STV 1 0.1) 
                (STV 1 0.1) 
                (STV 1 0.5) 
                (STV 1 0.5))) 
            (STV 1 0.5)))))))
</span>Deterministic: <span class="ansi33">
(got 
  ( (â 
      (â R S) 
      (STV 1 0.5))) expected 
  ( (≞ 
      (→ P S) 
      (deduction-formula 
        ( (STV 1 0.1) 
          (STV 1 0.1) 
          (STV 1 0.1) 
          (deduction-formula 
            ( (STV 1 0.1) 
              (STV 1 0.1) 
              (STV 1 0.1) 
              (STV 1 0.5) 
              (STV 1 0.5))) 
          (STV 1 0.5))))))

</span>; Execution took 0.036 secs. (35.77 milliseconds) 
<span class="ansi32">% 1,788,674 inferences, 0.531 CPU in 0.531 seconds (100% CPU, 3368884 Lips)
</span>;                (= /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/equal/DeductionEqualTest.metta 0)
<br/><a href="https://github.com/logicmoo/vspace-metta/blob/main/MeTTaLog.md">Return to Summaries</a><br/>
;       (is_cmd_option halt --halt=true True)
<span class="ansi1">LoonIt Report
</span>------------
<span class="ansi32">Successes: 0
</span><span class="ansi31">Failures: 2
</span><span class="ansi1">LoonIt Report
</span>------------
<span class="ansi32">Successes: 0
</span><span class="ansi31">Failures: 2
</span>
Script done on 2024-01-09 15:23:50-08:00 [COMMAND_EXIT_CODE="7"]

</pre>
</body>

</html>
