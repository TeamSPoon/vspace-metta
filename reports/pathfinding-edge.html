<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>
<style type="text/css">
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content">
 (@ track_load_into_file "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/pathfinding-edge.metta")
; Metta Pathfinding Example
; these examples actually need the compiler!
<span class="ansi38-000068000">!(pragma! compile full)

</span><span class="ansi38-017068017">exec(A) :-
    true,
    ['pragma!', compile, full]=A.

</span>; Evaluation took 0.066 ms. (66.00 microseconds) 
<span class="ansi33"> full

</span>; Define the edge-f function, which represents one-way edges in the graph.
; This function is crucial for specifying connections between nodes.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'edge-f',[->,'Symbol','Symbol']])
</span><span class="ansi38-255165000">  (: edge-f 
    (-> Symbol Symbol))
</span>

; Define the edges in the graph using the edge-f function.
%~ [ convert(Convert),
%~   head_preconds_into_body((['edge-f',a]=_316256:-_316256=b))]
%~ [convert(_317378),head_preconds_into_body((['edge-f',a]=_316256:-_316256=b))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['edge-f',a],b)
</span><span class="ansi38-255165000">  (= 
    (edge-f a) b)
</span><span class="ansi38-000082136">
  ['edge-f', a]=A :-
    A=b.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((['edge-f',b]=_381356:-_381356=c))]
%~ [convert(_382478),head_preconds_into_body((['edge-f',b]=_381356:-_381356=c))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['edge-f',b],c)
</span><span class="ansi38-255165000">  (= 
    (edge-f b) c)
</span><span class="ansi38-000082136">
  ['edge-f', b]=A :-
    A=c.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((['edge-f',c]=_437944:-_437944=d))]
%~ [convert(_439066),head_preconds_into_body((['edge-f',c]=_437944:-_437944=d))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['edge-f',c],d)
</span><span class="ansi38-255165000">  (= 
    (edge-f c) d)
</span><span class="ansi38-000082136">
  ['edge-f', c]=A :-
    A=d.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((['edge-f',e]=_497760:-_497760=f))]
%~ [convert(_2260),head_preconds_into_body((['edge-f',e]=_2224:-_2224=f))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['edge-f',e],f)
</span><span class="ansi38-255165000">  (= 
    (edge-f e) f)
</span><span class="ansi38-000082136">
  ['edge-f', e]=A :-
    A=f.

</span>

; The following code is commented-out and relates to node connectivity checks.
;(= (at $x) (assertTrue $x))
;(= (at-a-b) (at (is-same (edge-f a) b)))
;!(at-a-b)
;(= (a-t-a-b) (assertTrue (is-same (edge-f a) b)))
;!(a-t-a-b)
%~ [ convert(Convert),
%~   head_preconds_into_body((['is-same',X,X]=_37696:-_37696='True'))]
%~ [convert(_38932),head_preconds_into_body((['is-same',X,X]=_37696:-_37696='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['is-same',X,X],'True')
</span><span class="ansi38-255165000">  (= 
    (is-same $X $X) True)
</span><span class="ansi38-000082136">
  ['is-same', X, X]=A :-
    A='True'.

</span>

; Testing the presence of nodes in the graph.
<span class="ansi38-000068000">!(assertTrue (is-same (edge-f a) b))

</span><span class="ansi38-017068017">exec(Exec) :- 
  ['edge-f',a]=_114698 , 
  _114698=_114688 , 
  ['is-same',_114688,b]=_114656 , 
  _114656=_114646 , 
  [assertTrue,_114646]=_113854
</span>
; Evaluation took 0.004 ms. (3.90 microseconds) 
<span class="ansi33">  (assertTrue 
    (is-same 
      (edge-f a) b))

</span>; Node 'a' is connected to 'b'
; Not present
<span class="ansi38-000068000">!(assertFalse (is-same (edge-f a) d))

</span><span class="ansi38-017068017">exec(Exec) :- 
  ['edge-f',a]=_169762 , 
  _169762=_169752 , 
  ['is-same',_169752,d]=_169720 , 
  _169720=_169710 , 
  [assertFalse,_169710]=_168918
</span>
; Evaluation took 0.004 ms. (3.80 microseconds) 
<span class="ansi33">  (assertFalse 
    (is-same 
      (edge-f a) d))

</span>; Node 'a' is not connected to 'd'
; Define the path-f function for pathfinding.
; This function utilizes recursive calls to the edge-f function.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'path-f',[->,'Symbol','Symbol']])
</span><span class="ansi38-255165000">  (: path-f 
    (-> Symbol Symbol))
</span>

; A node is always connected to itself.
%~ /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/metta_vspace/pyswip/metta_interp.pl:1054 
%~ [ convert(Convert),
%~   head_preconds_into_body((['path-f',X]=_229804:-_229804=X))]
%~ [convert(_230970),head_preconds_into_body((['path-f',X]=_229804:-_229804=X))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['path-f',X],X)
</span><span class="ansi38-255165000">  (= 
    (path-f $X) $X)
</span><span class="ansi38-000082136">
  ['path-f', X]=A :-
    A=X.

</span>

; The path-f function follows edges using the edge-f function.
%~ [ convert(Convert),
%~   head_preconds_into_body( ['path-f',X]=List :-
%~                              ['path-f',X]=List1 ,
%~                              List1=_334844 ,
%~                              ['edge-f',_334844]=List)]
%~ [convert(_295170),head_preconds_into_body((['path-f',X]=_294004:-(['path-f',X]=_295476,_295476=_295466),['edge-f',_295466]=_294004))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['path-f',X],['edge-f',['path-f',X]])
</span><span class="ansi38-255165000">  (= 
    (path-f $X) 
    (edge-f 
      (path-f $X)))
</span><span class="ansi38-000082136">
  ['path-f', X]=A :-
    ['path-f', X]=B,
    B=C,
    ['edge-f', C]=A.

</span>

; The following unit tests for the path-f function are currently commented out.
;!(assertTrue (is-same (path-f e) e))
;!(assertTrue (is-same (path-f a) b))
;!(assertTrue (is-same (path-f a) d))
; There should be only one direction
;!(assertFalse (is-same (path-f c) a))
; Not connected
;!(assertFalse (is-same (path-f a) f))
; Define the epath-f function for pathfinding using edges.
; This function also employs recursive calls to the edge-f function.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'epath-f',[->,'Symbol','Symbol']])
</span><span class="ansi38-255165000">  (: epath-f 
    (-> Symbol Symbol))
</span>

; The epath-f function follows edges using the edge-f function.
%~ [ convert(Convert),
%~   head_preconds_into_body( ['epath-f',X]=List :-
%~                              ['edge-f',X]=List1 ,
%~                              List1=_432034 ,
%~                              ['epath-f',_432034]=List)]
%~ [convert(_392250),head_preconds_into_body((['epath-f',X]=_391084:-(['edge-f',X]=_392556,_392556=_392546),['epath-f',_392546]=_391084))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['epath-f',X],['epath-f',['edge-f',X]])
</span><span class="ansi38-255165000">  (= 
    (epath-f $X) 
    (epath-f 
      (edge-f $X)))
</span><span class="ansi38-000082136">
  ['epath-f', X]=A :-
    ['edge-f', X]=B,
    B=C,
    ['epath-f', C]=A.

</span>

; A node is still connected to itself.
%~ [ convert(Convert),
%~   head_preconds_into_body((['epath-f',X]=_471282:-_471282=X))]
%~ [convert(_472448),head_preconds_into_body((['epath-f',X]=_471282:-_471282=X))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['epath-f',X],X)
</span><span class="ansi38-255165000">  (= 
    (epath-f $X) $X)
</span><span class="ansi38-000082136">
  ['epath-f', X]=A :-
    A=X.

</span>

; The following unit tests for the epath-f function are currently commented out.
; Uncomment these unit tests as needed.
;!(assertTrue (is-same (epath-f e) e))
;!(assertTrue (is-same (epath-f a) b))
;!(assertTrue (is-same (epath-f a) d))
; There should be only one direction
;!(assertFalse (is-same (epath-f c) a))
; Not connected
;!(assertFalse (is-same (epath-f a) f))
; Pathfinding with nondeterministic epath-f
<span class="ansi38-000068000">!(assertEqualToResult (epath-f a) (collapse (superpose (a b c d))))

</span><span class="ansi38-017068017">exec(Exec) :- 
  ['epath-f',a]=_17972 , 
  _17972=_17962 , 
  true;_18138=b,_18138=a;_18166=c,_18166=a;_18194=d,_18194=a , 
  a=_18094 , 
  [collapse,_18094]=_18062 , 
  _18062=_18052 , 
  [assertEqualToResult,_17962,_18052]=_17184
</span>
; Evaluation took 0.004 ms. (4.20 microseconds) 
<span class="ansi33">  (assertEqualToResult 
    (epath-f a) 
    (collapse a))

</span>; Define the epath-f-p predicate for pathfinding using edges
%~ [ convert(Convert),
%~   head_preconds_into_body( ['epath-f-p',X,Y]=List :-
%~                              ['epath-f',X]=List1 ,
%~                              List1=_94564 ,
%~                              ['is-same',_94564,Y]=List)]
%~ [convert(_52010),head_preconds_into_body((['epath-f-p',X,Y]=_50774:-(['epath-f',X]=_52316,_52316=_52306),['is-same',_52306,Y]=_50774))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['epath-f-p',X,Y],['is-same',['epath-f',X],Y])
</span><span class="ansi38-255165000">  (= 
    (epath-f-p $X $Y) 
    (is-same 
      (epath-f $X) $Y))
</span><span class="ansi38-000082136">
  ['epath-f-p', X, Y]=A :-
    ['epath-f', X]=B,
    B=C,
    ['is-same', C, Y]=A.

</span>

; Running epath-f in reverse directly via 'is-same'
<span class="ansi38-000068000">!(assertEqual (match &self (is-same (epath-f $X) c) $X) (superpose (a b c)))

</span><span class="ansi38-017068017">exec(Exec) :- 
  ['epath-f',X]=_137094 , 
  _137094=_137084 , 
  ['is-same',_137084,c]=_137052 , 
  _137052=_137042 , 
  [match,'&self',_137042,X]=_136998 , 
  _136998=_136988 , 
  true;_137472=b,_137472=a;_137500=c,_137500=a , 
  a=_137428 , 
  [assertEqual,_136988,_137428]=_135364
</span>
; Evaluation took 0.005 ms. (5.10 microseconds) 
<span class="ansi33">  (assertEqual 
    (match &self 
      (is-same 
        (epath-f $_138206) c) $_138206) a)

</span>; Running epath-f in reverse via the truth predicate
<span class="ansi38-000068000">!(assertEqual (match &self (epath-f-p $X c) $X) (superpose (a b c)))

</span><span class="ansi38-017068017">exec(Exec) :- 
  ['epath-f-p',X,c]=_179550 , 
  _179550=_179540 , 
  [match,'&self',_179540,X]=_179496 , 
  _179496=_179486 , 
  true;_179878=b,_179878=a;_179906=c,_179906=a , 
  a=_179834 , 
  [assertEqual,_179486,_179834]=_178310
</span>
; Evaluation took 0.005 ms. (4.60 microseconds) 
<span class="ansi33">  (assertEqual 
    (match &self 
      (epath-f-p $_180534 c) $_180534) a)

</span>; Redefine the edge function using facts instead of functions.
; The graph is represented as facts: (= (edge A B) True) means there is a one-way edge from A to B.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,edge,[->,'Symbol','Symbol','Bool']])
</span><span class="ansi38-255165000">  (: edge 
    (-> Symbol Symbol Bool))
</span>

; Define the directional edges in the graph using facts.
;a -> b -> c -> d
;     \
;      e -> f
%~ [ convert(Convert),
%~   head_preconds_into_body(([edge,a,b]=_218786:-_218786='True'))]
%~ [convert(_219934),head_preconds_into_body(([edge,a,b]=_218786:-_218786='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[edge,a,b],'True')
</span><span class="ansi38-255165000">  (= 
    (edge a b) True)
</span><span class="ansi38-000082136">
  [edge, a, b]=A :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(([edge,b,c]=_261166:-_261166='True'))]
%~ [convert(_262314),head_preconds_into_body(([edge,b,c]=_261166:-_261166='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[edge,b,c],'True')
</span><span class="ansi38-255165000">  (= 
    (edge b c) True)
</span><span class="ansi38-000082136">
  [edge, b, c]=A :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(([edge,c,d]=_303426:-_303426='True'))]
%~ [convert(_304574),head_preconds_into_body(([edge,c,d]=_303426:-_303426='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[edge,c,d],'True')
</span><span class="ansi38-255165000">  (= 
    (edge c d) True)
</span><span class="ansi38-000082136">
  [edge, c, d]=A :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(([edge,b,e]=_345566:-_345566='True'))]
%~ [convert(_346714),head_preconds_into_body(([edge,b,e]=_345566:-_345566='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[edge,b,e],'True')
</span><span class="ansi38-255165000">  (= 
    (edge b e) True)
</span><span class="ansi38-000082136">
  [edge, b, e]=A :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(([edge,e,f]=_386974:-_386974='True'))]
%~ [convert(_388122),head_preconds_into_body(([edge,e,f]=_386974:-_386974='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[edge,e,f],'True')
</span><span class="ansi38-255165000">  (= 
    (edge e f) True)
</span><span class="ansi38-000082136">
  [edge, e, f]=A :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(([edge,g,h]=_429650:-_429650='True'))]
%~ [convert(_430798),head_preconds_into_body(([edge,g,h]=_429650:-_429650='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[edge,g,h],'True')
</span><span class="ansi38-255165000">  (= 
    (edge g h) True)
</span><span class="ansi38-000082136">
  [edge, g, h]=A :-
    A='True'.

</span>

; Define the path function using facts for pathfinding.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,path,[->,'Symbol','Symbol','Bool']])
</span><span class="ansi38-255165000">  (: path 
    (-> Symbol Symbol Bool))
</span>

; A node is always connected to itself.
%~ [ convert(Convert),
%~   head_preconds_into_body(([path,X,X]=_485024:-_485024='True'))]
%~ [convert(_486260),head_preconds_into_body(([path,X,X]=_485024:-_485024='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[path,X,X],'True')
</span><span class="ansi38-255165000">  (= 
    (path $X $X) True)
</span><span class="ansi38-000082136">
  [path, X, X]=A :-
    A='True'.

</span>

; The path function uses facts to check edge connectivity.
%~ [ convert(Convert),
%~   head_preconds_into_body( [path,X,Y]=List :-
%~                              [edge,X,Z]=List1 ,
%~                              List1=_64190 ,
%~                              [path,Z,Y]=List2 ,
%~                              List2=_64208 ,
%~                              [and,_64190,_64208]=List)]
%~ [convert(_12530),head_preconds_into_body(([path,X,Y]=_11294:-(([edge,X,Z]=_12836,_12836=_12826),[path,Z,Y]=_13040,_13040=_13030),[and,_12826,_13030]=_11294))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[path,X,Y],[and,[edge,X,Z],[path,Z,Y]])
</span><span class="ansi38-255165000">  (= 
    (path $X $Y) 
    (and 
      (edge $X $Z) 
      (path $Z $Y)))
</span><span class="ansi38-000082136">
  [path, X, Y]=A :-
    ( [edge, X, Z]=B,
      B=C
    ),
    [path, Z, Y]=D,
    D=E,
    [and, C, E]=A.

</span>

; Unit tests for the path function.
<span class="ansi38-000068000">!(assertEqual (path a b) True)

</span><span class="ansi38-017068017">exec(Exec) :- 
  [path,a,b]=_89120 , 
  _89120=_89110 , 
  is_True(_89226) , 
  [assertEqual,_89110,_89226]=_88442
</span>
; Evaluation took 0.004 ms. (3.60 microseconds) 
<span class="ansi33">  (assertEqual 
    (path a b) $_89226)

</span><span class="ansi38-000068000">!(assertEqual (path a c) True)

</span><span class="ansi38-017068017">exec(Exec) :- 
  [path,a,c]=_109664 , 
  _109664=_109654 , 
  is_True(_109770) , 
  [assertEqual,_109654,_109770]=_108986
</span>
; Evaluation took 0.003 ms. (2.90 microseconds) 
<span class="ansi33">  (assertEqual 
    (path a c) $_109770)

</span><span class="ansi38-000068000">!(assertEqual (path a d) True)

</span><span class="ansi38-017068017">exec(Exec) :- 
  [path,a,d]=_129838 , 
  _129838=_129828 , 
  is_True(_129944) , 
  [assertEqual,_129828,_129944]=_129160
</span>
; Evaluation took 0.003 ms. (2.80 microseconds) 
<span class="ansi33">  (assertEqual 
    (path a d) $_129944)

</span><span class="ansi38-000068000">!(assertEqual (path a f) True)

</span><span class="ansi38-017068017">exec(Exec) :- 
  [path,a,f]=_149640 , 
  _149640=_149630 , 
  is_True(_149746) , 
  [assertEqual,_149630,_149746]=_148962
</span>
; Evaluation took 0.003 ms. (3.30 microseconds) 
<span class="ansi33">  (assertEqual 
    (path a f) $_149746)

</span><span class="ansi38-000068000">!(assertEqual (path b e) True)

</span><span class="ansi38-017068017">exec(Exec) :- 
  [path,b,e]=_169070 , 
  _169070=_169060 , 
  is_True(_169176) , 
  [assertEqual,_169060,_169176]=_168392
</span>
; Evaluation took 0.003 ms. (3.20 microseconds) 
<span class="ansi33">  (assertEqual 
    (path b e) $_169176)

</span><span class="ansi38-000068000">!(assertEqual (path e f) True)

</span><span class="ansi38-017068017">exec(Exec) :- 
  [path,e,f]=_190962 , 
  _190962=_190952 , 
  is_True(_191068) , 
  [assertEqual,_190952,_191068]=_190284
</span>
; Evaluation took 0.003 ms. (3.20 microseconds) 
<span class="ansi33">  (assertEqual 
    (path e f) $_191068)

</span><span class="ansi32">% 2,766,609 inferences, 0.579 CPU in 0.579 seconds (100% CPU, 4774709 Lips)
</span> (@ = "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/pathfinding-edge.metta" 0)
<br/><a href="https://github.com/logicmoo/vspace-metta/blob/main/MeTTaLog.md">Return to Summaries</a><br/>
doing(ansi2html -u < "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/TEE.ansi" > "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/pathfinding-edge.html" )

</pre>
</body>

</html>
