<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>
<style type="text/css">
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi34 { color: #0000aa; }
.ansi35 { color: #E850A8; }
.ansi36 { color: #00aaaa; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-250144246 { color: #FA90F6; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-250144246 { color: #FA90F6; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-250144246 { color: #FA90F6; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-250144246 { color: #FA90F6; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-250144246 { color: #FA90F6; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-250144246 { color: #FA90F6; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-250144246 { color: #FA90F6; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-250144246 { color: #FA90F6; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-250144246 { color: #FA90F6; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content">
Script started on 2024-01-09 16:02:07-08:00 [TERM="xterm" TTY="/dev/pts/0" COLUMNS="152" LINES="150"]
; init_why(before_boot,after('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/metta_vspace/pyswip/metta_interp.pl')).
; init_phase(after_load).
; init_phase(restore_state).
; libswipl: [/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/Sav.godlike.MeTTaLog,--,--python=enable,--timeout=75,--html,--repl=false,examples/baseline_compat/hyperon-pln_metta/hol/NatStandaloneTest.metta,--halt=true]
;     (compiled_loon default)
%~   (run_vspace_server 3023)
;     (compiled_loon restore)
;    (compiled_loon goal)
; init_why(after_boot,program).
;    (compiled_loon program)
;   (began_loon toplevel)
;      (is_cmd_option python --python=enable enable)
;      (is_cmd_option timeout --timeout=75 75)
;       (is_cmd_option html --html True)
;       (is_cmd_option repl --repl=false False)

; (: user 
  (load_metta_file  &self examples/baseline_compat/hyperon-pln_metta/hol/NatStandaloneTest.metta))
;                (track_load_into_file /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/hol/NatStandaloneTest.metta)
;                              (load_answer_file /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/hol/NatStandaloneTest.metta.answers /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/hol/NatStandaloneTest.metta)
;                              (= 1 "+ '[' 0 -eq 1 ']'")
;                               (= 1 "+ echo 'Doing: timeout --foreground --kill-after=5 --signal=SIGINT 121 time metta /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/hol/NatStandaloneTest.metta'")
;                               (= 1 "Doing: timeout --foreground --kill-after=5 --signal=SIGINT 121 time metta /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/hol/NatStandaloneTest.metta")
;                                (= 1 "+ eval 'timeout --foreground --kill-after=5 --signal=SIGINT 121 time metta /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/hol/NatStandaloneTest.metta'")
;                                (= 1 "++ timeout --foreground --kill-after=5 --signal=SIGINT 121 time metta /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/baseline_compat/hyperon-pln_metta/hol/NatStandaloneTest.metta")
;                                (= 1 "[()]")
;                                 (= 2 "[()]")
;                                 (= 3 "[()]")
;                                  (= 4 "[()]")
;                                  (= 5 "[()]")
;                                  (= 6 "[()]")
;                                   (= 7 "[()]")
;                                   (= 8 "[()]")
;                                    (= 9 "[()]")
;                                    (= 10 "[()]")
;                                    (= 11 "[()]")
;                                     (= 12 "[()]")
;                                     (= 13 "[()]")
;                                      (= 14 "[(let* (((: $prfarg#54187 (plus Z (=== (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))) (bc (: $prfarg#54187 (plus Z (=== (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))) (S (S Z))))) (: (((. Replace0) (Replace0 plusBase)) $prfarg#54187) (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))), (let* (((: $prfarg#54187 (=== (=== (plus (S $x) Z) (S $x)) (=== (plus $x Z) $x))) (bc (: $prfarg#54187 (=== (=== (plus (S $x) Z) (S $x)) (=== (plus $x Z) $x))) (S (S Z))))) (: (((. Replace0) Sym) $prfarg#54187) (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))), (let* (((: $prfarg#54187 (plus Z (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))) (bc (: $prfarg#54187 (plus Z (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))) (S (S Z))))) (: ((Replace0 plusBase) $prfarg#54187) (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))), (: ((. (Trans plusRec)) Cong) (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x)))), (let* (((: $prfarg#54187 (-> (=== (plus $x Z) $x) (plusRightId (S $x)))) (bc (: $prfarg#54187 (-> (=== (plus $x Z) $x) (plusRightId (S $x)))) (S (S Z))))) (: ((. (Replace0 plusRightIdProp)) $prfarg#54187) (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))), (let* (((: $prfarg#54187 (-> (=== (plus $x Z) $x) (plus Z (=== (plus (S $x) Z) (S $x))))) (bc (: $prfarg#54187 (-> (=== (plus $x Z) $x) (plus Z (=== (plus (S $x) Z) (S $x))))) (S (S Z))))) (: ((. (Replace0 plusBase)) $prfarg#54187) (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))), (let* (((: $prfarg#54187 (-> (=== (plus $x Z) $x) (=== (S $x) (plus (S $x) Z)))) (bc (: $prfarg#54187 (-> (=== (plus $x Z) $x) (=== (S $x) (plus (S $x) Z)))) (S (S Z))))) (: ((. Sym) $prfarg#54187) (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))), (let* (((: $prfarg#54187 (=== (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x)))) (bc (: $prfarg#54187 (=== (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x)))) (S (S Z))))) (: (Replace0 $prfarg#54187) (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x)))))]")
;                                      (= 15 "[(: (Replace0 (Cong ((Trans plusRec) ((Trans (Cong plusBase)) (Cong (Sym plusRec)))))) (-> (plusRightId (plus (S Z) $x'#124505)) (plusRightId (S (plus (S Z) $x'#124505))))), (: (Replace0 (Cong ((Trans plusRec) ((Trans (Cong plusBase)) (Cong plusBase))))) (-> (plusRightId (plus (S Z) $x'#124505)) (plusRightId (S (plus (S Z) $x'#124505))))), (: (Replace0 (Cong ((Trans plusRec) ((Trans (Cong plusBase)) (Sym (Cong plusRec)))))) (-> (plusRightId (plus (S Z) $x'#124505)) (plusRightId (S (plus (S Z) $x'#124505))))), (: (Replace0 (Cong ((Trans plusRec) (Cong ((Trans plusBase) (Sym plusRec)))))) (-> (plusRightId (plus (S Z) $y#144144)) (plusRightId (S (plus (S Z) $y#144144))))), (: (Replace0 (Cong ((Trans plusRec) (Cong ((Trans plusBase) plusBase))))) (-> (plusRightId (plus (S Z) $y#144144)) (plusRightId (S (plus (S Z) $y#144144))))), (: (Replace0 (Cong ((Trans plusBase) ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusBase)))))) (-> (plusRightId (plus Z $y#187257)) (plusRightId (S (plus Z $y#187257))))), (: (Replace0 (Cong ((Trans plusBase) ((Trans (Sym plusBase)) ((Trans plusBase) plusRec))))) (-> (plusRightId (plus Z $y#187257)) (plusRightId (S (plus Z $y#187257))))), (: (Replace0 (Cong ((Trans plusBase) ((Trans (Sym plusBase)) ((Trans plusBase) plusBase))))) (-> (plusRightId (plus Z $y#187257)) (plusRightId (S (plus Z $y#187257))))), (: (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusRec)))))) (-> (plusRightId (S (S (plus $x#234949 $y#234950)))) (plusRightId (S (S (S (plus $x#234949 $y#234950))))))), (: (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusRightIdProp)))))) (-> (plusRightId (S (=== (plus $x#234951 Z) $x#234951))) (plusRightId (S (S (=== (plus $x#234951 Z) $x#234951)))))), (: (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusBase)))))) (-> (plusRightId (S $y#234250)) (plusRightId (S (S $y#234250))))), (: (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) plusRec))))) (-> (plusRightId (S (plus $x#235249 $y#235250))) (plusRightId (S (S (plus $x#235249 $y#235250)))))), (: (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) plusBase))))) (-> (plusRightId (S $y#234250)) (plusRightId (S (S $y#234250))))), (: (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusRec))))) (-> (plusRightId (S (plus $x#464500 $y#464501))) (plusRightId (S (S (plus $x#464500 $y#464501)))))), (: (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusRightIdProp))))) (-> (plusRightId (=== (plus $x#464502 Z) $x#464502)) (plusRightId (S (=== (plus $x#464502 Z) $x#464502))))), (: (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusBase))))) (-> (plusRightId $y#463801) (plusRightId (S $y#463801)))), (: (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) plusRec)))) (-> (plusRightId (plus $x#464800 $y#464801)) (plusRightId (S (plus $x#464800 $y#464801))))), (: (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) plusBase)))) (-> (plusRightId $y#463801) (plusRightId (S $y#463801)))), (: ((. (Replace0 (Sym plusRightIdProp))) ((. (Trans plusRec)) ((. Cong) (Replace0 plusRightIdProp)))) (-> (plusRightId $x) (plusRightId (S $x))))]")
;                                      (= 16 "[()]")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Definition of an omnichainer, Nat, plus and some proofs.            ;;
;;;                                                                     ;;
;;; The main proof of interest is that Z is the right identity of plus. ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; The omnichainer is expected to have the following properties:
;;;
;;; - Rules are curried.
;;;
;;; - There is no distinction between axioms and rules.
;;;
;;; - Rule composition, using the traditional composition operator `.`
;;;   is included in the chaining process (whether it is embedded in
;;;   the chainer implementation or is an external rule remains to be
;;;   determined).
;;;
;;; Given such omnichainer, the inductive property that x + 0 = x
;;; implies (S x) + 0 = (S x) should then have the following proof
;;; abstraction:
;;;
;;; ------------------------------------(plusRec)
;;; (=== (plus (S $x) Z) (S (plus $x Z)))
;;; -------------------------------------------------------------(Trans)  -----------------------------------------------------(Cong)
;;; (-> (=== (S (plus $x Z)) (S $x)) (=== (plus (S $x) Z) (S $x)))        (-> (=== (plus $x Z) $x) (=== (S (plus $x Z)) (S $x)))
;;; ---------------------------------------------------------------------------------------------------------------------------(.)
;;;                                  (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x)))
;;;
;;; or in MeTTa format:
;;;
;;; ((. (Trans plusRec)) Cong)

;;;;;;;;;;
;;; Nat ;;
;;;;;;;;;;

;;; Define Nat
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'Nat','Type'])
</span><span class="ansi38-255165000">(: Nat Type)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'Z','Nat'])
</span><span class="ansi38-255165000">(: Z Nat)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,'S',[->,'Nat','Nat']])
</span><span class="ansi38-255165000">(: S 
  (-> Nat Nat))
</span>

;;; Define <=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,<=,[->,'$VAR'(a),'$VAR'(a),'Bool']])
</span><span class="ansi38-255165000">(: <= 
  (-> $a $a Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[<=,'$VAR'(x),'$VAR'(y)],[or,[<,'$VAR'(x),'$VAR'(y)],[==,'$VAR'(x),'$VAR'(y)]]])
</span><span class="ansi38-255165000">(= 
  (<= $x $y) 
  (or 
    (< $x $y) 
    (== $x $y)))
</span>

;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,fromNumber,[->,'Number','Nat']])
</span><span class="ansi38-255165000">(: fromNumber 
  (-> Number Nat))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[fromNumber,'$VAR'(n)],[if,[<=,'$VAR'(n),0],'Z',['S',[fromNumber,[-,'$VAR'(n),1]]]]])
</span><span class="ansi38-255165000">(= 
  (fromNumber $n) 
  (if 
    (<= $n 0) Z 
    (S 
      (fromNumber 
        (- $n 1)))))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[:,fromNat,[->,'Nat','Number']])
</span><span class="ansi38-255165000">(: fromNat 
  (-> Nat Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[fromNat,'Z'],0])
</span><span class="ansi38-255165000">(= 
  (fromNat Z) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[fromNat,['S','$VAR'(k)]],[+,1,[fromNat,'$VAR'(k)]]])
</span><span class="ansi38-255165000">(= 
  (fromNat 
    (S $k)) 
  (+ 1 
    (fromNat $k)))
</span>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Knowledge and rule base ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040">!(bind! &kb 
  (new-space))

</span>Deterministic: <span class="ansi33">Empty

</span>; Execution took 0.000055 secs. (54.61 microseconds) 
;;; Knowledge base
;;; Refl is disabled because not necessary in all examples so far
;;; ;; Equality is reflexive.  We use === instead of == to make sure it
;;; ;; does not get reduced by the MeTTa interpreter.
;;; !(add-atom &kb (: Refl (=== $x $x)))
;;; Equality is transitive
<span class="ansi38-255165000">;; In file as:  
</span><span class="ansi1 ansi38-255238088">!(add-atom &kb 
  (: Trans 
    (-> 
      (=== $x $y) 
      (-> 
        (=== $y $z) 
        (=== $x $z)))))
</span>;; To unit test case:
<span class="ansi38-013099040">!(assertEqualToResult 
  (add-atom &kb 
    (: Trans 
      (-> 
        (=== $x $y) 
        (-> 
          (=== $y $z) 
          (=== $x $z))))) 
  (()))

</span><span class="ansi38-250144246">; !(add-atom &kb (: Trans (-> (=== $x $y) (-> (=== $y $z) (=== $x $z)))))
</span>;<h3 id="HOL.NATSTANDALONETEST.01">;; HOL.NATSTANDALONETEST.01</h3>
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&kb',[:,'Trans',[->,[===,_470744,_470766],[->,[===,_470766,_470838],[===,_470744,_470838]]]])
</span><span class="ansi38-255165000">(: Trans 
  (-> 
    (=== $_470744 $_470766) 
    (-> 
      (=== $_470766 $_470838) 
      (=== $_470744 $_470838))))
</span>

; 
; EVAL TEST
; took 0.000269 secs. (268.83 microseconds) 
<span class="ansi36">(loonit_success 
  (equal_enough_for_test  () 
    (())))
</span>Deterministic: <span class="ansi33">Empty

</span>; Execution took 0.000613 secs. (613.25 microseconds) 
;; Premise 1
;; Premise 2
;; Conclusion
;;; Equality is symmetric
<span class="ansi38-255165000">;; In file as:  
</span><span class="ansi1 ansi38-255238088">!(add-atom &kb 
  (: Sym 
    (-> 
      (=== $x $y) 
      (=== $y $x))))
</span>;; To unit test case:
<span class="ansi38-013099040">!(assertEqualToResult 
  (add-atom &kb 
    (: Sym 
      (-> 
        (=== $x $y) 
        (=== $y $x)))) 
  (()))

</span><span class="ansi38-250144246">; !(add-atom &kb (: Sym (-> (=== $x $y) (=== $y $x))))
</span>;<h3 id="HOL.NATSTANDALONETEST.02">;; HOL.NATSTANDALONETEST.02</h3>
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&kb',[:,'Sym',[->,[===,_73718,_73740],[===,_73740,_73718]]])
</span><span class="ansi38-255165000">(: Sym 
  (-> 
    (=== $_73718 $_73740) 
    (=== $_73740 $_73718)))
</span>

; 
; EVAL TEST
; took 0.000263 secs. (262.55 microseconds) 
<span class="ansi36">(loonit_success 
  (equal_enough_for_test  () 
    (())))
</span>Deterministic: <span class="ansi33">Empty

</span>; Execution took 0.000576 secs. (576.27 microseconds) 
;; Premise
;; Conclusion
;;; Equality respects function application
<span class="ansi38-255165000">;; In file as:  
</span><span class="ansi1 ansi38-255238088">!(add-atom &kb 
  (: Cong 
    (-> 
      (=== $x $x') 
      (=== 
        ($op $x) 
        ($op $x')))))
</span>;; To unit test case:
<span class="ansi38-013099040">!(assertEqualToResult 
  (add-atom &kb 
    (: Cong 
      (-> 
        (=== $x $x') 
        (=== 
          ($op $x) 
          ($op $x'))))) 
  (()))

</span><span class="ansi38-250144246">; !(add-atom &kb (: Cong (-> (=== $x $x') (=== ($op $x) ($op $x')))))
</span>;<h3 id="HOL.NATSTANDALONETEST.03">;; HOL.NATSTANDALONETEST.03</h3>
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&kb',[:,'Cong',[->,[===,_173364,_173386],[===,[_173432,_173364],[_173432,_173386]]]])
</span><span class="ansi38-255165000">(: Cong 
  (-> 
    (=== $_173364 $_173386) 
    (=== 
      ($_173432 $_173364) 
      ($_173432 $_173386))))
</span>

; 
; EVAL TEST
; took 0.000273 secs. (272.93 microseconds) 
<span class="ansi36">(loonit_success 
  (equal_enough_for_test  () 
    (())))
</span>Deterministic: <span class="ansi33">Empty

</span>; Execution took 0.000539 secs. (539.49 microseconds) 
;; Premise
;; Conclusion
;;; Rule of replacement (nullary operator)
;;; TODO: could use Replace1 combine with identity function instead.
<span class="ansi38-255165000">;; In file as:  
</span><span class="ansi1 ansi38-255238088">!(add-atom &kb 
  (: Replace0 
    (-> 
      (=== $x $x') 
      (-> $x $x'))))
</span>;; To unit test case:
<span class="ansi38-013099040">!(assertEqualToResult 
  (add-atom &kb 
    (: Replace0 
      (-> 
        (=== $x $x') 
        (-> $x $x')))) 
  (()))

</span><span class="ansi38-250144246">; !(add-atom &kb (: Replace0 (-> (=== $x $x') (-> $x $x'))))
</span>;<h3 id="HOL.NATSTANDALONETEST.04">;; HOL.NATSTANDALONETEST.04</h3>
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&kb',[:,'Replace0',[->,[===,_280868,_280890],[->,_280868,_280890]]])
</span><span class="ansi38-255165000">(: Replace0 
  (-> 
    (=== $_280868 $_280890) 
    (-> $_280868 $_280890)))
</span>

; 
; EVAL TEST
; took 0.000253 secs. (253.21 microseconds) 
<span class="ansi36">(loonit_success 
  (equal_enough_for_test  () 
    (())))
</span>Deterministic: <span class="ansi33">Empty

</span>; Execution took 0.000558 secs. (557.58 microseconds) 
;; Premise 1
;; Premise 2
;; Conclusion
;;; The following replacement rules are disabled because not necessary
;;; in the examples so far
;;; ;; Rule of replacement (unary operator)
;;; !(add-atom &kb (: Replace1 (-> (=== $x $x')      ; Premise 1
;;;                                (-> ($op $x)      ; Premise 2
;;;                                    ($op $x'))))) ; Conclusion
;;; ;; Rule of replacement (binary operator)
;;; !(add-atom &kb (: Replace2 (-> (=== $x $x')               ; Premise 1
;;;                                (-> (=== $y $y')           ; Premise 2
;;;                                    (-> ($op $x $y)        ; Premise 3
;;;                                        ($op $x' $y')))))) ; Conclusion
;;; Structural induction on Nat
<span class="ansi38-255165000">;; In file as:  
</span><span class="ansi1 ansi38-255238088">!(add-atom &kb 
  (: NatInd 
    (-> 
      ($p Z) 
      (-> 
        (-> 
          ($p $x) 
          ($p 
            (S $x))) 
        ($p $x')))))
</span>;; To unit test case:
<span class="ansi38-013099040">!(assertEqualToResult 
  (add-atom &kb 
    (: NatInd 
      (-> 
        ($p Z) 
        (-> 
          (-> 
            ($p $x) 
            ($p 
              (S $x))) 
          ($p $x'))))) 
  (()))

</span><span class="ansi38-250144246">; !(add-atom &kb (: NatInd (-> ($p Z) (-> (-> ($p $x) ($p (S $x))) ($p $x')))))
</span>;<h3 id="HOL.NATSTANDALONETEST.05">;; HOL.NATSTANDALONETEST.05</h3>
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&kb',[:,'NatInd',[->,[_377622,'Z'],[->,[->,[_377622,_377710],[_377622,['S',_377710]]],[_377622,_377818]]]])
</span><span class="ansi38-255165000">(: NatInd 
  (-> 
    ($_377622 Z) 
    (-> 
      (-> 
        ($_377622 $_377710) 
        ($_377622 
          (S $_377710))) 
      ($_377622 $_377818))))
</span>

; 
; EVAL TEST
; took 0.000309 secs. (309.29 microseconds) 
<span class="ansi36">(loonit_success 
  (equal_enough_for_test  () 
    (())))
</span>Deterministic: <span class="ansi33">Empty

</span>; Execution took 0.000615 secs. (615.06 microseconds) 
;; Premise 1 (base case)
;; Premise 2 (inductive step)
;; Conclusion
;;; Definition of plus (base case)
<span class="ansi38-255165000">;; In file as:  
</span><span class="ansi1 ansi38-255238088">!(add-atom &kb 
  (: plusBase 
    (=== 
      (plus Z $y) $y)))
</span>;; To unit test case:
<span class="ansi38-013099040">!(assertEqualToResult 
  (add-atom &kb 
    (: plusBase 
      (=== 
        (plus Z $y) $y))) 
  (()))

</span><span class="ansi38-250144246">; !(add-atom &kb (: plusBase (=== (plus Z $y) $y)))
</span>;<h3 id="HOL.NATSTANDALONETEST.06">;; HOL.NATSTANDALONETEST.06</h3>
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&kb',[:,plusBase,[===,[plus,'Z',_465916],_465916]])
</span><span class="ansi38-255165000">(: plusBase 
  (=== 
    (plus Z $_465916) $_465916))
</span>

; 
; EVAL TEST
; took 0.000233 secs. (232.65 microseconds) 
<span class="ansi36">(loonit_success 
  (equal_enough_for_test  () 
    (())))
</span>Deterministic: <span class="ansi33">Empty

</span>; Execution took 0.000491 secs. (490.73 microseconds) 
;;; Definition of plus (recursive step)
<span class="ansi38-255165000">;; In file as:  
</span><span class="ansi1 ansi38-255238088">!(add-atom &kb 
  (: plusRec 
    (=== 
      (plus 
        (S $x) $y) 
      (S 
        (plus $x $y)))))
</span>;; To unit test case:
<span class="ansi38-013099040">!(assertEqualToResult 
  (add-atom &kb 
    (: plusRec 
      (=== 
        (plus 
          (S $x) $y) 
        (S 
          (plus $x $y))))) 
  (()))

</span><span class="ansi38-250144246">; !(add-atom &kb (: plusRec (=== (plus (S $x) $y) (S (plus $x $y)))))
</span>;<h3 id="HOL.NATSTANDALONETEST.07">;; HOL.NATSTANDALONETEST.07</h3>
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&kb',[:,plusRec,[===,[plus,['S',_64412],_64434],['S',[plus,_64412,_64434]]]])
</span><span class="ansi38-255165000">(: plusRec 
  (=== 
    (plus 
      (S $_64412) $_64434) 
    (S 
      (plus $_64412 $_64434))))
</span>

; 
; EVAL TEST
; took 0.000265 secs. (264.59 microseconds) 
<span class="ansi36">(loonit_success 
  (equal_enough_for_test  () 
    (())))
</span>Deterministic: <span class="ansi33">Empty

</span>; Execution took 0.000527 secs. (526.94 microseconds) 
;;; ;; If Z is the right identity of plus for x then it is the right
;;; ;; identity of plus for (S x).  NEXT: prove it.
;;; !(add-atom &kb (: plusRightIdInd
;;;                   (-> (plusRightId $x)        ; Premise
;;;                       (plusRightId (S $x))))) ; Conclusion
;;; Property expressing that for any natural, Z is the right identity
;;; of plus.  Note that the property definition is the axiom, not the
;;; property itself as it is what we attempt to prove.
<span class="ansi38-255165000">;; In file as:  
</span><span class="ansi1 ansi38-255238088">!(add-atom &kb 
  (: plusRightIdProp 
    (=== 
      (plusRightId $x) 
      (=== 
        (plus $x Z) $x))))
</span>;; To unit test case:
<span class="ansi38-013099040">!(assertEqualToResult 
  (add-atom &kb 
    (: plusRightIdProp 
      (=== 
        (plusRightId $x) 
        (=== 
          (plus $x Z) $x)))) 
  (()))

</span><span class="ansi38-250144246">; !(add-atom &kb (: plusRightIdProp (=== (plusRightId $x) (=== (plus $x Z) $x))))
</span>;<h3 id="HOL.NATSTANDALONETEST.08">;; HOL.NATSTANDALONETEST.08</h3>
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&kb',[:,plusRightIdProp,[===,[plusRightId,_149064],[===,[plus,_149064,'Z'],_149064]]])
</span><span class="ansi38-255165000">(: plusRightIdProp 
  (=== 
    (plusRightId $_149064) 
    (=== 
      (plus $_149064 Z) $_149064)))
</span>

; 
; EVAL TEST
; took 0.000261 secs. (261.34 microseconds) 
<span class="ansi36">(loonit_success 
  (equal_enough_for_test  () 
    (())))
</span>Deterministic: <span class="ansi33">Empty

</span>; Execution took 0.000528 secs. (528.34 microseconds) 
;;; Composition operator
<span class="ansi38-255165000">;; In file as:  
</span><span class="ansi1 ansi38-255238088">!(add-atom &kb 
  (: -> 
    (-> $b $c) 
    (-> 
      (-> $a $b) 
      (-> $a $c))))
</span>;; To unit test case:
<span class="ansi38-013099040">!(assertEqualToResult 
  (add-atom &kb 
    (: -> 
      (-> $b $c) 
      (-> 
        (-> $a $b) 
        (-> $a $c)))) 
  (()))

</span><span class="ansi38-250144246">; !(add-atom &kb (: -> (-> $b $c) (-> (-> $a $b) (-> $a $c))))
</span>;<h3 id="HOL.NATSTANDALONETEST.09">;; HOL.NATSTANDALONETEST.09</h3>
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&kb',[:,->,[->,_240236,_240258,[->,[->,_240312,_240236],[->,_240312,_240258]]]])
</span><span class="ansi38-255165000">(: -> 
  (-> $_240236 $_240258) 
  (-> 
    (-> $_240312 $_240236) 
    (-> $_240312 $_240258)))
</span>

; error( resource_error(stack),
;   stack_overflow{choicepoints:57,depth:20647112,environments:113,globalused:967843,localused:18,stack:[frame(20647112,user:arg_types(_49882,[1],Types),[]),frame(185,system:once('<garbage_collected>'),[]),frame(184,system:call('<garbage_collected>','<garbage_collected>'),[]),frame(183,system:catch(: / 2,_49924,: / 2),[]),frame(180,system:'<meta-call>'('<garbage_collected>'),[])],stack_limit:1048576,trailused:0}) =
;   user: call( user:once,
;           user: arg_types( [->,_69906,_69912],
;                   [ [ ->,
;                       [->,_101458,_101464],
;                       [->,_101458,_101488]]],
;                   Types3)).
^  <span class="ansi1 ansi32">Call: </span>(190) [user] call(user:once, user:arg_types([->, _2496, _2514], [[->, [->, _2556, _2496], [->, _2556|...]]], _4720))
^  <span class="ansi1 ansi34">Unify: </span>(190) [system] call(user:once, user:arg_types([->, _2496, _2514], [[->, [->, _2556, _2496], [->, _2556|...]]], _4720))
^  <span class="ansi1 ansi35">Exception: </span>(190) [system] call(user:once, user:arg_types([->, _2496, _2514], [[->, [->, _2556, _2496], [->, _2556|...]]], _4720)) ? 
Script done on 2024-01-09 16:03:22-08:00 [COMMAND_EXIT_CODE="143"]

</pre>
</body>

</html>
