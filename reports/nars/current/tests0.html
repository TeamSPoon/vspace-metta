<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>
<style type="text/css">
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi36 { color: #00aaaa; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content">
 (@ track_load_into_file "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/hyperon-experimental/python/sandbox/numpy/nm_test.metta")
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/hyperon-experimental/python/sandbox/numpy/nm_test.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/hyperon-experimental/python/sandbox/numpy/nm_test.metta')
1=[]
2=[()]
3=[()]
4=[()]
5=[()]
6=[array(['1', 'S'], dtype='<U21')]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['RevisionAndChoice',['Event',[Term1,[F1,C1]],[eternal,Ev1,EPrio1]],['Event',[Term2,[F2,C2]],[eternal,Ev2,EPrio2]]],[let,ConclusionStamp,['TupleConcat',Ev1,Ev2],['If',['StampDisjoint',ConclusionStamp],['Event',[Term1,['Truth_Revision',[F1,C1],[F2,C2]]],[eternal,ConclusionStamp,[0,0.0]]],['If',[>,C1,C2],['Event',[Term1,[F1,C1]],[eternal,Ev1,[0,0.0]]],['Event',[Term2,[F2,C2]],[eternal,Ev2,[0,0.0]]]]]])
</span><span class="ansi38-255165000">  (= 
    (RevisionAndChoice 
      (Event 
        ($Term1 
          ($F1 $C1)) 
        (eternal $Ev1 $EPrio1)) 
      (Event 
        ($Term2 
          ($F2 $C2)) 
        (eternal $Ev2 $EPrio2))) 
    (let $ConclusionStamp 
      (TupleConcat $Ev1 $Ev2) 
      (If 
        (StampDisjoint $ConclusionStamp) 
        (Event 
          ($Term1 
            (Truth_Revision 
              ($F1 $C1) 
              ($F2 $C2))) 
          (eternal $ConclusionStamp 
            (0 0.0))) 
        (If 
          (> $C1 $C2) 
          (Event 
            ($Term1 
              ($F1 $C1)) 
            (eternal $Ev1 
              (0 0.0))) 
          (Event 
            ($Term2 
              ($F2 $C2)) 
            (eternal $Ev2 
              (0 0.0)))))))
</span>

;update beliefs in existing concept with the new event or create new concept to enter the new evidence
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['UpdateConcept',NewEvent,True],['let*',[[['Event',[Term,TV],[Time,Evidence,EPrio]],NewEvent],[NewEventEternalized,['Eternalize',NewEvent]],[MatchConcept,['Concept',Term,Belief,BeliefEvent,CPrio]]],[sequential,[[case,[match,'&attentional_focus',MatchConcept,MatchConcept],[[MatchConcept,[sequential,[['remove-atom','&attentional_focus',MatchConcept],['let*',[[['Event',RevSentence,Metadata],['RevisionAndChoice',Belief,NewEventEternalized]],[RevisedBelief,['Event',['trace!',[@,RevSentence],RevSentence],Metadata]],[MaxPrio,['If',[>,['EventPriorityNow',EPrio,True],['ConceptPriorityNow',CPrio,True]],EPrio,CPrio]]],['add-atom','&attentional_focus',['Concept',Term,RevisedBelief,NewEvent,MaxPrio]]]]]],['%void%',[case,[match,'&concepts',MatchConcept,MatchConcept],[[MatchConcept,[sequential,[['remove-atom','&concepts',MatchConcept],['add-atom','&attentional_focus',MatchConcept],['UpdateConcept',NewEvent,True]]]],['%void%',['add-atom','&attentional_focus',['Concept',Term,NewEventEternalized,NewEvent,EPrio]]]]]]]]]]])
</span><span class="ansi38-255165000">  (= 
    (UpdateConcept $NewEvent $True) 
    (let* 
      ( ( (Event 
            ($Term $TV) 
            ($Time $Evidence $EPrio)) $NewEvent) 
        ($NewEventEternalized 
          (Eternalize $NewEvent)) 
        ($MatchConcept 
          (Concept $Term $Belief $BeliefEvent $CPrio))) 
      (sequential 
        ( (case 
            (match &attentional_focus $MatchConcept $MatchConcept) 
            ( ($MatchConcept 
                (sequential 
                  ( (remove-atom &attentional_focus $MatchConcept) 
                    (let* 
                      ( ( (Event $RevSentence $Metadata) 
                          (RevisionAndChoice $Belief $NewEventEternalized)) 
                        ($RevisedBelief 
                          (Event 
                            (trace! 
                              (@ $RevSentence) $RevSentence) $Metadata)) 
                        ($MaxPrio 
                          (If 
                            (> 
                              (EventPriorityNow $EPrio $True) 
                              (ConceptPriorityNow $CPrio $True)) $EPrio $CPrio))) 
                      (add-atom &attentional_focus 
                        (Concept $Term $RevisedBelief $NewEvent $MaxPrio)))))) 
              (%void% 
                (case 
                  (match &concepts $MatchConcept $MatchConcept) 
                  ( ($MatchConcept 
                      (sequential 
                        ( (remove-atom &concepts $MatchConcept) 
                          (add-atom &attentional_focus $MatchConcept) 
                          (UpdateConcept $NewEvent $True)))) 
                    (%void% 
                      (add-atom &attentional_focus 
                        (Concept $Term $NewEventEternalized $NewEvent $EPrio))))))))))))
</span>

;bound the size of attentional focus of concepts
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['BoundAttention',Threshold,Increment,TargetAmount,True],[sequential,[[do,['let*',[[C,['get-atoms','&attentional_focus']],[['Concept',Term,['Event',Sentence,Metadata],BeliefEvent,CPrio],C]],['If',[<,['ConceptPriorityNow',CPrio,True],Threshold],[sequential,[['remove-atom','&attentional_focus',C],['add-atom','&concepts',C]]]]]],[let,CurrentAmount,['CollapseCardinality',['get-atoms','&attentional_focus']],['If',[>,CurrentAmount,TargetAmount],['BoundAttention',[+,Threshold,Increment],Increment,TargetAmount,True]]]]])
</span><span class="ansi38-255165000">  (= 
    (BoundAttention $Threshold $Increment $TargetAmount $True) 
    (sequential 
      ( (do 
          (let* 
            ( ($C 
                (get-atoms &attentional_focus)) 
              ( (Concept $Term 
                  (Event $Sentence $Metadata) $BeliefEvent $CPrio) $C)) 
            (If 
              (< 
                (ConceptPriorityNow $CPrio $True) $Threshold) 
              (sequential 
                ( (remove-atom &attentional_focus $C) 
                  (add-atom &concepts $C)))))) 
        (let $CurrentAmount 
          (CollapseCardinality 
            (get-atoms &attentional_focus)) 
          (If 
            (> $CurrentAmount $TargetAmount) 
            (BoundAttention 
              (+ $Threshold $Increment) $Increment $TargetAmount $True))))))
</span>

;get eternal belief of concept
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'EternalQuestion',[->,'Expression',True]])
</span><span class="ansi38-255165000">  (: EternalQuestion 
    (-> Expression $True))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['EternalQuestion',Term],[case,[match,[superpose,['&attentional_focus','&concepts']],['Concept',Term,Belief,BeliefEvent,CPrio],Belief],[[Ev,Ev],['%void%',['Event',['None',[0.5,0.0]],[eternal,[],0.0]]]]])
</span><span class="ansi38-255165000">  (= 
    (EternalQuestion $Term) 
    (case 
      (match 
        (superpose 
          (&attentional_focus &concepts)) 
        (Concept $Term $Belief $BeliefEvent $CPrio) $Belief) 
      ( ($Ev $Ev) 
        (%void% 
          (Event 
            (None 
              (0.5 0.0)) 
            (eternal () 0.0))))))
</span>

;get event belief of concept
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'EventQuestion',[->,'Expression',True]])
</span><span class="ansi38-255165000">  (: EventQuestion 
    (-> Expression $True))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['EventQuestion',Term],[case,[match,[superpose,['&attentional_focus','&concepts']],['Concept',Term,Belief,BeliefEvent,CPrio],BeliefEvent],[[Ev,Ev],['%void%',['Event',['None',[0.5,0.0]],[0,[],0.0]]]]])
</span><span class="ansi38-255165000">  (= 
    (EventQuestion $Term) 
    (case 
      (match 
        (superpose 
          (&attentional_focus &concepts)) 
        (Concept $Term $Belief $BeliefEvent $CPrio) $BeliefEvent) 
      ( ($Ev $Ev) 
        (%void% 
          (Event 
            (None 
              (0.5 0.0)) 
            (0 () 0.0))))))
</span>

;;Declarative inference (deriving events and knowledge from observed events)
;Derived belief event priority
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['ConclusionPriority',EPrio,CPrio,ConcTV],[*,[*,EPrio,CPrio],['Truth_Expectation',ConcTV]])
</span><span class="ansi38-255165000">  (= 
    (ConclusionPriority $EPrio $CPrio $ConcTV) 
    (* 
      (* $EPrio $CPrio) 
      (Truth_Expectation $ConcTV)))
</span>

;making declarative inferences on two events (task from PQ and belief from concept)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['Conclude',['Event',S1,[Time1,Ev1,Prio1]],['Event',S2,[Time2,Ev2,Prio2]],CPrio,True],[let,ConclusionStamp,['TupleConcat',Ev1,Ev2],['If',['StampDisjoint',ConclusionStamp],[let,[ConcTerm,ConcTV],[superpose,[['|-',S1,S2],['|-',S2,S1]]],['Event',[ConcTerm,ConcTV],[Time1,ConclusionStamp,[True,['ConclusionPriority',['EventPriorityNow',Prio1,True],['ConceptPriorityNow',CPrio,True],ConcTV]]]]]]])
</span><span class="ansi38-255165000">  (= 
    (Conclude 
      (Event $S1 
        ($Time1 $Ev1 $Prio1)) 
      (Event $S2 
        ($Time2 $Ev2 $Prio2)) $CPrio $True) 
    (let $ConclusionStamp 
      (TupleConcat $Ev1 $Ev2) 
      (If 
        (StampDisjoint $ConclusionStamp) 
        (let 
          ($ConcTerm $ConcTV) 
          (superpose 
            ( (|- $S1 $S2) 
              (|- $S2 $S1))) 
          (Event 
            ($ConcTerm $ConcTV) 
            ($Time1 $ConclusionStamp 
              ($True 
                (ConclusionPriority 
                  (EventPriorityNow $Prio1 $True) 
                  (ConceptPriorityNow $CPrio $True) $ConcTV))))))))
</span>

;find a belief for the task to generate conclusions with
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['ReasonWithTask',['Event',S1,[Time1,Ev1,Prio1]],True],[let,[Belief,CPrio],[case,['get-atoms','&attentional_focus'],[[['Concept',Term,['Event',SE2,[TimeE2,EvE2,PrioE2]],['Event',S2,[Time2,Ev2,Prio2]],CPrio],['If',[and,[not,[==,Time1,eternal]],[>,[abs,[-,Time1,Time2]],20]],[['Event',SE2,[TimeE2,EvE2,PrioE2]],Cprio],[['Event',S2,[Time2,Ev2,Prio2]],CPrio]]]]],[case,['Conclude',['Event',S1,[Time1,Ev1,Prio1]],['TemporallyAlignedBelief',Time1,Belief],CPrio,True],[[['Event',Num1,Num2],['ProcessBeliefEvent',['Event',['trace!',['.',Num1],Num1],Num2],True]]]]])
</span><span class="ansi38-255165000">  (= 
    (ReasonWithTask 
      (Event $S1 
        ($Time1 $Ev1 $Prio1)) $True) 
    (let 
      ($Belief $CPrio) 
      (case 
        (get-atoms &attentional_focus) 
        ( ( (Concept $Term 
              (Event $SE2 
                ($TimeE2 $EvE2 $PrioE2)) 
              (Event $S2 
                ($Time2 $Ev2 $Prio2)) $CPrio) 
            (If 
              (and 
                (not 
                  (== $Time1 eternal)) 
                (> 
                  (abs 
                    (- $Time1 $Time2)) 20)) 
              ( (Event $SE2 
                  ($TimeE2 $EvE2 $PrioE2)) $Cprio) 
              ( (Event $S2 
                  ($Time2 $Ev2 $Prio2)) $CPrio))))) 
      (case 
        (Conclude 
          (Event $S1 
            ($Time1 $Ev1 $Prio1)) 
          (TemporallyAlignedBelief $Time1 $Belief) $CPrio $True) 
        ( ( (Event $Num1 $Num2) 
            (ProcessBeliefEvent 
              (Event 
                (trace! 
                  (. $Num1) $Num1) $Num2) $True))))))
</span>

;select the highest priority belief event from the PQ and use it for reasoning
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['BeliefCycle',True],[do,[sequential,[[let,Ev,['SelectHighestPriorityEvent','&belief_events',True],[sequential,[['remove-atom','&belief_events',Ev],['ReasonWithTask',Ev,True]]]],['UpdateReasonerState'],['BoundEvents','&belief_events',0.0,0.1,['BeliefEventsMax'],True],['BoundAttention',0.0,0.1,['AttentionalFocusConceptsMax'],True]]]])
</span><span class="ansi38-255165000">  (= 
    (BeliefCycle $True) 
    (do 
      (sequential 
        ( (let $Ev 
            (SelectHighestPriorityEvent &belief_events $True) 
            (sequential 
              ( (remove-atom &belief_events $Ev) 
                (ReasonWithTask $Ev $True)))) 
          (UpdateReasonerState) 
          (BoundEvents &belief_events 0.0 0.1 
            (BeliefEventsMax) $True) 
          (BoundAttention 0.0 0.1 
            (AttentionalFocusConceptsMax) $True)))))
</span>

;;Temporal inference (sequence and implication formation based on FIFO)
;use the event's evidence to induce a time-independent belief which can be used in the future
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['Eternalize',Ev],[let,['Event',[Term,TV],[Time,Evidence,EPrio]],Ev,['If',[==,Time,eternal],Ev,['Event',[Term,['Truth_Eternalize',TV]],[eternal,Evidence,[0,0.0]]]]])
</span><span class="ansi38-255165000">  (= 
    (Eternalize $Ev) 
    (let 
      (Event 
        ($Term $TV) 
        ($Time $Evidence $EPrio)) $Ev 
      (If 
        (== $Time eternal) $Ev 
        (Event 
          ($Term 
            (Truth_Eternalize $TV)) 
          (eternal $Evidence 
            (0 0.0))))))
</span>

;use evidence of an event at a slightly different moment in time
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['Projection',['Event',[Term,[False,C]],[Time,Evidence,EPrio]],TargetTime],['Event',[Term,[False,[*,C,[min,1,[/,1,[abs,[-,Time,TargetTime]]]]]]],[TargetTime,Evidence,EPrio]])
</span><span class="ansi38-255165000">  (= 
    (Projection 
      (Event 
        ($Term 
          ($False $C)) 
        ($Time $Evidence $EPrio)) $TargetTime) 
    (Event 
      ($Term 
        ($False 
          (* $C 
            (min 1 
              (/ 1 
                (abs 
                  (- $Time $TargetTime))))))) 
      ($TargetTime $Evidence $EPrio)))
</span>

;make the belief occurrence time compatible with the task's
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['TemporallyAlignedBelief',TaskTime,Belief],['If',[==,TaskTime,eternal],['Eternalize',Belief],['Projection',Belief,TaskTime]])
</span><span class="ansi38-255165000">  (= 
    (TemporallyAlignedBelief $TaskTime $Belief) 
    (If 
      (== $TaskTime eternal) 
      (Eternalize $Belief) 
      (Projection $Belief $TaskTime)))
</span>

;FIFO max. size bound
<span class="ansi38-000068000">!(bind! &FIFO 
  (new-state ()))

</span><span class="ansi33"> Empty

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['EventWithFIFO3',New,[Num1,Num2,Num3]],[New,Num1,Num2])
</span><span class="ansi38-255165000">  (= 
    (EventWithFIFO3 $New 
      ($Num1 $Num2 $Num3)) 
    ($New $Num1 $Num2))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['EventWithFIFO3',New,[Num1,Num2]],[New,Num1,Num2])
</span><span class="ansi38-255165000">  (= 
    (EventWithFIFO3 $New 
      ($Num1 $Num2)) 
    ($New $Num1 $Num2))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['EventWithFIFO3',New,[Num1]],[New,Num1])
</span><span class="ansi38-255165000">  (= 
    (EventWithFIFO3 $New 
      ($Num1)) 
    ($New $Num1))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['EventWithFIFO3',New,[]],[New])
</span><span class="ansi38-255165000">  (= 
    (EventWithFIFO3 $New ()) 
    ($New))
</span>

;Add event to FIFO
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['EventToFIFO',Ev],[let,Newlist,['EventWithFIFO3',Ev,['get-state','&FIFO']],['change-state!','&FIFO',Newlist]])
</span><span class="ansi38-255165000">  (= 
    (EventToFIFO $Ev) 
    (let $Newlist 
      (EventWithFIFO3 $Ev 
        (get-state &FIFO)) 
      (change-state! &FIFO $Newlist)))
</span>

;Form a sequence of two events
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['TemporalSequence',Ev1,['Event',[Term2,Truth2],[Time2,Evidence2,EPrio2]]],[let,['Event',[Term1,Truth1],[Time1,Evidence1,EPrio1]],['Projection',Ev1,Time2],['Event',[[Term1,&/,Term2],['Truth_Intersection',Truth1,Truth2]],[Time2,['TupleConcat',Evidence1,Evidence2],[0,0.0]]]])
</span><span class="ansi38-255165000">  (= 
    (TemporalSequence $Ev1 
      (Event 
        ($Term2 $Truth2) 
        ($Time2 $Evidence2 $EPrio2))) 
    (let 
      (Event 
        ($Term1 $Truth1) 
        ($Time1 $Evidence1 $EPrio1)) 
      (Projection $Ev1 $Time2) 
      (Event 
        ( ($Term1 &/ $Term2) 
          (Truth_Intersection $Truth1 $Truth2)) 
        ($Time2 
          (TupleConcat $Evidence1 $Evidence2) 
          (0 0.0)))))
</span>

;Form a temporal implication between two events
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['TemporalImplication',Ev1,['Event',[Term2,Truth2],[Time2,Evidence2,EPrio2]]],[let,['Event',[Term1,Truth1],[Time1,Evidence1,EPrio1]],['Projection',Ev1,Time2],['trace!',['.',[[Term1,=/>,Term2],['Truth_Induction',Truth1,Truth2]]],['Event',[[Term1,=/>,Term2],['Truth_Induction',Truth1,Truth2]],[Time2,['TupleConcat',Evidence1,Evidence2],[0,0.0]]]]])
</span><span class="ansi38-255165000">  (= 
    (TemporalImplication $Ev1 
      (Event 
        ($Term2 $Truth2) 
        ($Time2 $Evidence2 $EPrio2))) 
    (let 
      (Event 
        ($Term1 $Truth1) 
        ($Time1 $Evidence1 $EPrio1)) 
      (Projection $Ev1 $Time2) 
      (trace! 
        (. 
          ( ($Term1 =/> $Term2) 
            (Truth_Induction $Truth1 $Truth2))) 
        (Event 
          ( ($Term1 =/> $Term2) 
            (Truth_Induction $Truth1 $Truth2)) 
          ($Time2 
            (TupleConcat $Evidence1 $Evidence2) 
            (0 0.0))))))
</span>

;Whether an event's term is an operation
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['IsOp',['Event',[Term,Truth],Metadata]],[case,Term,[[[^,Opname],'True'],[Otherwise,'False']]])
</span><span class="ansi38-255165000">  (= 
    (IsOp 
      (Event 
        ($Term $Truth) $Metadata)) 
    (case $Term 
      ( ( (^ $Opname) True) 
        ($Otherwise False))))
</span>

;Find implications in the event FIFO:
;procedural implications
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['TemporalImplicationInduction',[Cons,Op,Prec]],['If',[and,['IsOp',Op],[and,[not,['IsOp',Cons]],[not,['IsOp',Prec]]]],[let,PrecOp,['TemporalSequence',Prec,Op],['TemporalImplication',PrecOp,Cons]]])
</span><span class="ansi38-255165000">  (= 
    (TemporalImplicationInduction 
      ($Cons $Op $Prec)) 
    (If 
      (and 
        (IsOp $Op) 
        (and 
          (not 
            (IsOp $Cons)) 
          (not 
            (IsOp $Prec)))) 
      (let $PrecOp 
        (TemporalSequence $Prec $Op) 
        (TemporalImplication $PrecOp $Cons))))
</span>

;and temporal without operation
;(= (TemporalImplicationInduction ($Cons $Prec $Trail))
;   (If (and (not (IsOp $Prec)) (not (IsOp $Cons)))
;       (TemporalImplication $Prec $Cons)))
;Add negative evidence for implications which predicted the input unsuccessfully
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['NegConfirmation',PrecTerm,ObservedCons,True],[let,['Event',[[PrecTerm,=/>,PredictedCons],ImpTV],ImpMetadata],['EternalQuestion',[PrecTerm,=/>,PredictedCons]],['If',[not,[==,ObservedCons,PredictedCons]],['UpdateConcept',['Event',[[PrecTerm,=/>,PredictedCons],[0.0,0.1]],[True,[],[0,0.0]]],True]]])
</span><span class="ansi38-255165000">  (= 
    (NegConfirmation $PrecTerm $ObservedCons $True) 
    (let 
      (Event 
        ( ($PrecTerm =/> $PredictedCons) $ImpTV) $ImpMetadata) 
      (EternalQuestion 
        ($PrecTerm =/> $PredictedCons)) 
      (If 
        (not 
          (== $ObservedCons $PredictedCons)) 
        (UpdateConcept 
          (Event 
            ( ($PrecTerm =/> $PredictedCons) 
              (0.0 0.1)) 
            ($True () 
              (0 0.0))) $True))))
</span>

;Check if the implication's preconditions are met to anticipate the by the implication predicted outcome
;(= (Anticipate ($Pos $Pre $Trail) $t)
;   (let* (((Event ($PreTerm $PreTV) $PreMetadata) $Pre)
;          ((Event ($PosTerm $PosTV) $PosMetadata) $Pos))
;         (If (not (IsOp $Pre))
;             (NegConfirmation $PreTerm $PosTerm $t))))
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['Anticipate',[Pos,Op,Pre],True],['let*',[[['Event',[PreTerm,PreTV],PreMetadata],Pre],[['Event',[OpTerm,OpTV],OpMetadata],Op],[['Event',[PosTerm,PosTV],PosMetadata],Pos],[Sequence,[Pre,&/,'Pos']]],['If',[and,['IsOp',Op],[not,['IsOp',Pre]]],['NegConfirmation',[PreTerm,&/,OpTerm],PosTerm,True]]])
</span><span class="ansi38-255165000">  (= 
    (Anticipate 
      ($Pos $Op $Pre) $True) 
    (let* 
      ( ( (Event 
            ($PreTerm $PreTV) $PreMetadata) $Pre) 
        ( (Event 
            ($OpTerm $OpTV) $OpMetadata) $Op) 
        ( (Event 
            ($PosTerm $PosTV) $PosMetadata) $Pos) 
        ($Sequence 
          ($Pre &/ Pos))) 
      (If 
        (and 
          (IsOp $Op) 
          (not 
            (IsOp $Pre))) 
        (NegConfirmation 
          ($PreTerm &/ $OpTerm) $PosTerm $True))))
</span>

;Input procedure
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['AddBeliefEvent',Sentence],['let*',[[[True,EvidentialBase],['GetReasonerState']],[InputEvent,['Event',['trace!',['.',Sentence],Sentence],[True,EvidentialBase,[True,1.0]]]],[NotAnOperation,[not,['IsOp',InputEvent]]]],[do,[sequential,[['EventToFIFO',InputEvent],['Anticipate',['get-state','&FIFO'],True],['If',NotAnOperation,[sequential,[[let,InducedHypothesis,['TemporalImplicationInduction',['get-state','&FIFO']],['UpdateConcept',InducedHypothesis,True]],['ProcessBeliefEvent',InputEvent,True],['BeliefCycle',True]]],['UpdateReasonerState']]]]]])
</span><span class="ansi38-255165000">  (= 
    (AddBeliefEvent $Sentence) 
    (let* 
      ( ( ($True $EvidentialBase) 
          (GetReasonerState)) 
        ($InputEvent 
          (Event 
            (trace! 
              (. $Sentence) $Sentence) 
            ($True $EvidentialBase 
              ($True 1.0)))) 
        ($NotAnOperation 
          (not 
            (IsOp $InputEvent)))) 
      (do 
        (sequential 
          ( (EventToFIFO $InputEvent) 
            (Anticipate 
              (get-state &FIFO) $True) 
            (If $NotAnOperation 
              (sequential 
                ( (let $InducedHypothesis 
                    (TemporalImplicationInduction 
                      (get-state &FIFO)) 
                    (UpdateConcept $InducedHypothesis $True)) 
                  (ProcessBeliefEvent $InputEvent $True) 
                  (BeliefCycle $True))) 
              (UpdateReasonerState)))))))
</span>

;;Procedural inference (decision making with operation execution and subgoaling)
;Derived goal event priority
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['SubgoalPriority',EPrio,ConcTV],[*,EPrio,['Truth_Expectation',ConcTV]])
</span><span class="ansi38-255165000">  (= 
    (SubgoalPriority $EPrio $ConcTV) 
    (* $EPrio 
      (Truth_Expectation $ConcTV)))
</span>

;Expectation of an operation is the truth expectation of its desire value
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['OpExpectation',['Decision',[Opname,DVOp],Subgoal],True],['Truth_Expectation',DVOp])
</span><span class="ansi38-255165000">  (= 
    (OpExpectation 
      (Decision 
        ($Opname $DVOp) $Subgoal) $True) 
    (Truth_Expectation $DVOp))
</span>

;Inject executed operation as an event and return its name
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['Execute',Opname],[superpose,[['AddBeliefEvent',[Opname,[1.0,0.9]]],Opname]])
</span><span class="ansi38-255165000">  (= 
    (Execute $Opname) 
    (superpose 
      ( (AddBeliefEvent 
          ($Opname 
            (1.0 0.9))) $Opname)))
</span>

;Add subgoals to the PQ
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['DeriveSubgoals',Options],[do,[let,['Decision',Op,['Event',S,Metadata]],[superpose,Options],[let,Subgoal,['Event',['trace!',[!,S],S],Metadata],['add-atom','&goal_events',Subgoal]]]])
</span><span class="ansi38-255165000">  (= 
    (DeriveSubgoals $Options) 
    (do 
      (let 
        (Decision $Op 
          (Event $S $Metadata)) 
        (superpose $Options) 
        (let $Subgoal 
          (Event 
            (trace! 
              (! $S) $S) $Metadata) 
          (add-atom &goal_events $Subgoal)))))
</span>

;execute the operation which most likely gets the goal achieved in current contexts, and if contexts are not yet fulfilled, derive them as subgoals
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['BestDecision',True,['Event',[Term,DV],[GoalTime,GoalEvBase,GoalPrio]],FIFO],[let,Options,[collapse,['let*',[[['Event',[[[Prec,&/,[^,Op]],=/>,Term],ImpTV],[ImpTime,ImpEvBase,ImpPrio]],['EternalQuestion',[[Prec,&/,[^,Op]],=/>,Term]]],[DVPrecOp,['Truth_Deduction',DV,ImpTV]],[['Event',[PrecTerm,PrecTV],PrecMetadata],['Projection',['EventQuestion',Prec],True]],[DVOp,['Truth_Deduction',PrecTV,DVPrecOp]],[DVPrec,['Truth_StructuralDeduction',DVPrecOp]],[SubgoalStamp,['TupleConcat',GoalEvBase,ImpEvBase]]],['If',['StampDisjoint',SubgoalStamp],['Decision',[[^,Op],DVOp],['Event',[Prec,['Truth_StructuralDeduction',DVPrecOp]],[True,SubgoalStamp,[True,['SubgoalPriority',['EventPriorityNow',GoalPrio,True],DVPrec]]]]]]]],[let,['Decision',[Opname,DVOp],Subgoal],['BestCandidate',Options,'OpExpectation',True],['If',[>,['Truth_Expectation',DVOp],0.5],['Execute',Opname],['DeriveSubgoals',Options]]]])
</span><span class="ansi38-255165000">  (= 
    (BestDecision $True 
      (Event 
        ($Term $DV) 
        ($GoalTime $GoalEvBase $GoalPrio)) $FIFO) 
    (let $Options 
      (collapse 
        (let* 
          ( ( (Event 
                ( ( ($Prec &/ 
                      (^ $Op)) =/> $Term) $ImpTV) 
                ($ImpTime $ImpEvBase $ImpPrio)) 
              (EternalQuestion 
                ( ($Prec &/ 
                    (^ $Op)) =/> $Term))) 
            ($DVPrecOp 
              (Truth_Deduction $DV $ImpTV)) 
            ( (Event 
                ($PrecTerm $PrecTV) $PrecMetadata) 
              (Projection 
                (EventQuestion $Prec) $True)) 
            ($DVOp 
              (Truth_Deduction $PrecTV $DVPrecOp)) 
            ($DVPrec 
              (Truth_StructuralDeduction $DVPrecOp)) 
            ($SubgoalStamp 
              (TupleConcat $GoalEvBase $ImpEvBase))) 
          (If 
            (StampDisjoint $SubgoalStamp) 
            (Decision 
              ( (^ $Op) $DVOp) 
              (Event 
                ($Prec 
                  (Truth_StructuralDeduction $DVPrecOp)) 
                ($True $SubgoalStamp 
                  ($True 
                    (SubgoalPriority 
                      (EventPriorityNow $GoalPrio $True) $DVPrec)))))))) 
      (let 
        (Decision 
          ($Opname $DVOp) $Subgoal) 
        (BestCandidate $Options OpExpectation $True) 
        (If 
          (> 
            (Truth_Expectation $DVOp) 0.5) 
          (Execute $Opname) 
          (DeriveSubgoals $Options)))))
</span>

;select the highest priority goal event from the PQ and use it for decision making
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['GoalCycle',True],[sequential,[[let,Ev,['SelectHighestPriorityEvent','&goal_events',True],[sequential,[[do,['remove-atom','&goal_events',Ev]],['BestDecision',True,Ev,['get-state','&FIFO']]]]],[do,['UpdateReasonerState']],[do,['BoundEvents','&goal_events',0.0,0.1,['GoalEventsMax'],True]]]])
</span><span class="ansi38-255165000">  (= 
    (GoalCycle $True) 
    (sequential 
      ( (let $Ev 
          (SelectHighestPriorityEvent &goal_events $True) 
          (sequential 
            ( (do 
                (remove-atom &goal_events $Ev)) 
              (BestDecision $True $Ev 
                (get-state &FIFO))))) 
        (do 
          (UpdateReasonerState)) 
        (do 
          (BoundEvents &goal_events 0.0 0.1 
            (GoalEventsMax) $True)))))
</span>

;Input procedure
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['AddGoalEvent',Sentence],['let*',[[[True,EvidentialBase],['GetReasonerState']],[InputEvent,['Event',['trace!',[!,Sentence],Sentence],[True,EvidentialBase,[True,1.0]]]]],[sequential,[[do,['add-atom','&goal_events',InputEvent]],['GoalCycle',True]]]])
</span><span class="ansi38-255165000">  (= 
    (AddGoalEvent $Sentence) 
    (let* 
      ( ( ($True $EvidentialBase) 
          (GetReasonerState)) 
        ($InputEvent 
          (Event 
            (trace! 
              (! $Sentence) $Sentence) 
            ($True $EvidentialBase 
              ($True 1.0))))) 
      (sequential 
        ( (do 
            (add-atom &goal_events $InputEvent)) 
          (GoalCycle $True)))))
</span>

;; !(import! &self NARS.metta)
;;MeTTaLog only: !(pragma! trace-on-load True)
; debug
<span class="ansi38-000068000">!(assertEqual 
  (TupleCount 
    (get-atoms &belief_events)) 0)

</span><h3 id="CURRENT.TESTS0.01">;; CURRENT.TESTS0.01</h3>
; 
; EVAL TEST
; took 0.569 ms. (568.70 microseconds) 
<span class="ansi36">(@ loonit_success 
  (equal_enough_for_test  
    (0 0) 
    (0)))
</span><span class="ansi33"> Empty

</span>;;NAL tests
<span class="ansi38-000068000">!(assertEqualToResult 
  (|- 
    ( (Garfield --> cat) 
      (1.0 0.9)) 
    ( (cat --> animal) 
      (1.0 0.9))) 
  ( ( (animal --> Garfield) 
      (1.0 0.44751381215469616)) 
    ( (Garfield --> animal) 
      (1.0 0.81))))

</span><h3 id="CURRENT.TESTS0.02">;; CURRENT.TESTS0.02</h3>
; 
; EVAL TEST
; took 7.11 ms.
<span class="ansi36">(@ loonit_success 
  (equal_enough_for_test  
    ( ( (Garfield --> animal) 
        (1.0 0.81)) 
      ( (animal --> Garfield) 
        (1.0 0.44751381215469616))) 
    ( ( (animal --> Garfield) 
        (1.0 0.44751381215469616)) 
      ( (Garfield --> animal) 
        (1.0 0.81)))))
</span><span class="ansi33"> Empty

</span>;expected:
<span class="ansi38-000068000">!(assertEqualToResult 
  (|- 
    ( (Garfield --> carnivore) 
      (1.0 0.9)) 
    ( ( (Garfield --> cat) ==> 
        (Garfield --> carnivore)) 
      (1.0 0.9))) 
  ( ( (Garfield --> cat) 
      (1.0 0.44751381215469616))))

</span><h3 id="CURRENT.TESTS0.03">;; CURRENT.TESTS0.03</h3>
; 
; EVAL TEST
; took 2.98 ms.
<span class="ansi36">(@ loonit_success 
  (equal_enough_for_test  
    ( ( (Garfield --> cat) 
        (1.0 0.44751381215469616))) 
    ( ( (Garfield --> cat) 
        (1.0 0.44751381215469616)))))
</span><span class="ansi33"> Empty

</span>;expected:
<span class="ansi38-000068000">!(assertEqualToResult 
  (|- 
    ( ( { a b } --> mwawa) 
          (1.0 0.9))) 
          ( ( ( { a } --> mwawa) 
                  (1.0 0.81)) 
                  ( ( { b } --> mwawa) 
                        (1.0 0.81))))

</span><h3 id="CURRENT.TESTS0.04">;; CURRENT.TESTS0.04</h3>
; 
; EVAL TEST
; took 6.06 ms.
<span class="ansi36">(@ loonit_success 
  (equal_enough_for_test  
    ( ( ( { a } --> mwawa) 
            (1.0 0.81)) 
            ( ( { b } --> mwawa) 
                  (1.0 0.81))) 
                  ( ( ( { a } --> mwawa) 
                          (1.0 0.81)) 
                          ( ( { b } --> mwawa) 
                                (1.0 0.81)))))
</span><span class="ansi33"> Empty

</span>;expected:
<span class="ansi38-000068000">!(assertEqualToResult 
  (|- 
    ( ( (a * b) --> R) 
      (1.0 0.9))) 
  ( ( (a --> 
        (R /1 b)) 
      (1.0 0.81)) 
    ( (b --> 
        (R /2 a)) 
      (1.0 0.81))))

</span><h3 id="CURRENT.TESTS0.05">;; CURRENT.TESTS0.05</h3>
; 
; EVAL TEST
; took 2.98 ms.
<span class="ansi36">(@ loonit_success 
  (equal_enough_for_test  
    ( ( (a --> 
          (R /1 b)) 
        (1.0 0.81)) 
      ( (b --> 
          (R /2 a)) 
        (1.0 0.81))) 
    ( ( (a --> 
          (R /1 b)) 
        (1.0 0.81)) 
      ( (b --> 
          (R /2 a)) 
        (1.0 0.81)))))
</span><span class="ansi33"> Empty

</span>;expected:
<span class="ansi38-000068000">!(assertEqualToResult 
  (|- 
    ( (R --> 
        (a * b)) 
      (1.0 0.9))) 
  ( ( ( (R \1 b) --> a) 
      (1.0 0.81)) 
    ( ( (R \2 a) --> b) 
      (1.0 0.81))))

</span><h3 id="CURRENT.TESTS0.06">;; CURRENT.TESTS0.06</h3>
; 
; EVAL TEST
; took 2.68 ms.
<span class="ansi36">(@ loonit_success 
  (equal_enough_for_test  
    ( ( ( (R \1 b) --> a) 
        (1.0 0.81)) 
      ( ( (R \2 a) --> b) 
        (1.0 0.81))) 
    ( ( ( (R \1 b) --> a) 
        (1.0 0.81)) 
      ( ( (R \2 a) --> b) 
        (1.0 0.81)))))
</span><span class="ansi33"> Empty

</span>;expected:
<span class="ansi38-000068000">!(assertEqualToResult 
  (|- 
    ( (A --> cat) 
      (1.0 0.9)) 
    ( (B --> cat) 
      (1.0 0.9))) 
  ( ( (B --> A) 
      (1.0 0.44751381215469616)) 
    ( ( (A ~ B) --> cat) 
      (0.0 0.81)) 
    ( ( (A | B) --> cat) 
      (1.0 0.81)) 
    ( (B <-> A) 
      (1.0 0.44751381215469616)) 
    ( ( (A & B) --> cat) 
      (1.0 0.81))))

</span><h3 id="CURRENT.TESTS0.07">;; CURRENT.TESTS0.07</h3>
; 
; EVAL TEST
; took 34.83 ms.
<span class="ansi31">(@ loonit_failureR 
  (equal_enough_for_test  
    ( ( (B --> A) 
        (1.0 0.44751381215469616)) 
      ( (B <-> A) 
        (1.0 0.44751381215469616)) 
      ( (B <-> A) 
        (1.0 0.44751381215469616)) 
      ( (B <-> A) 
        (1.0 0.44751381215469616)) 
      ( (B <-> A) 
        (1.0 0.44751381215469616)) 
      ( (B <-> A) 
        (1.0 0.44751381215469616)) 
      ( (B <-> A) 
        (1.0 0.44751381215469616)) 
      ( (B <-> A) 
        (1.0 0.44751381215469616)) 
      ( (B <-> A) 
        (1.0 0.44751381215469616)) 
      ( (B <-> A) 
        (1.0 0.44751381215469616)) 
      ( (B <-> A) 
        (1.0 0.44751381215469616))) 
    ( ( (B --> A) 
        (1.0 0.44751381215469616)) 
      ( ( (A ~ B) --> cat) 
        (0.0 0.81)) 
      ( ( (A | B) --> cat) 
        (1.0 0.81)) 
      ( (B <-> A) 
        (1.0 0.44751381215469616)) 
      ( ( (A & B) --> cat) 
        (1.0 0.81)))))
</span>; Trace took 25.14 ms.
<span class="ansi33">  (got 
    ( ( (B --> A) 
        (1.0 0.44751381215469616)) 
      ( (B <-> A) 
        (1.0 0.44751381215469616)) 
      ( (B <-> A) 
        (1.0 0.44751381215469616)) 
      ( (B <-> A) 
        (1.0 0.44751381215469616)) 
      ( (B <-> A) 
        (1.0 0.44751381215469616)) 
      ( (B <-> A) 
        (1.0 0.44751381215469616)) 
      ( (B <-> A) 
        (1.0 0.44751381215469616)) 
      ( (B <-> A) 
        (1.0 0.44751381215469616)) 
      ( (B <-> A) 
        (1.0 0.44751381215469616)) 
      ( (B <-> A) 
        (1.0 0.44751381215469616)) 
      ( (B <-> A) 
        (1.0 0.44751381215469616))) expected 
    ( ( (B --> A) 
        (1.0 0.44751381215469616)) 
      ( ( (A ~ B) --> cat) 
        (0.0 0.81)) 
      ( ( (A | B) --> cat) 
        (1.0 0.81)) 
      ( (B <-> A) 
        (1.0 0.44751381215469616)) 
      ( ( (A & B) --> cat) 
        (1.0 0.81))))

</span>;expected:
<span class="ansi38-000068000">!(assertEqualToResult 
  (|- 
    (|- 
      ( (Garfield --> cat) 
        (1.0 0.9)) 
      ( (cat --> animal) 
        (1.0 0.9))) 
    ( (animal --> being) 
      (1.0 0.9))) 
  ( ( (animal --> 
        (Garfield | being)) 
      (1.0 0.40276243093922653)) 
    ( (animal --> 
        (Garfield & being)) 
      (1.0 0.40276243093922653)) 
    ( (animal --> 
        (Garfield - being)) 
      (0.0 0.40276243093922653)) 
    ( (being <-> Garfield) 
      (1.0 0.28712091374556914)) 
    ( (being --> Garfield) 
      (1.0 0.28712091374556914)) 
    ( (being --> Garfield) 
      (1.0 0.42163100057836905)) 
    ( (Garfield --> being) 
      (1.0 0.7290000000000001))))

</span><h3 id="CURRENT.TESTS0.08">;; CURRENT.TESTS0.08</h3>
; 
; EVAL TEST
; took 38.90 ms.
<span class="ansi31">(@ loonit_failureR 
  (equal_enough_for_test  
    ( ( (Garfield --> being) 
        (1.0 0.7290000000000001)) 
      ( (being --> Garfield) 
        (1.0 0.42163100057836905)) 
      ( (being --> Garfield) 
        (1.0 0.28712091374556914)) 
      ( (being <-> Garfield) 
        (1.0 0.28712091374556914)) 
      ( (being <-> Garfield) 
        (1.0 0.28712091374556914)) 
      ( (being <-> Garfield) 
        (1.0 0.28712091374556914)) 
      ( (being <-> Garfield) 
        (1.0 0.28712091374556914)) 
      ( (being <-> Garfield) 
        (1.0 0.28712091374556914)) 
      ( (being <-> Garfield) 
        (1.0 0.28712091374556914)) 
      ( (being <-> Garfield) 
        (1.0 0.28712091374556914)) 
      ( (being <-> Garfield) 
        (1.0 0.28712091374556914)) 
      ( (being <-> Garfield) 
        (1.0 0.28712091374556914)) 
      ( (being <-> Garfield) 
        (1.0 0.28712091374556914))) 
    ( ( (animal --> 
          (Garfield | being)) 
        (1.0 0.40276243093922653)) 
      ( (animal --> 
          (Garfield & being)) 
        (1.0 0.40276243093922653)) 
      ( (animal --> 
          (Garfield - being)) 
        (0.0 0.40276243093922653)) 
      ( (being <-> Garfield) 
        (1.0 0.28712091374556914)) 
      ( (being --> Garfield) 
        (1.0 0.28712091374556914)) 
      ( (being --> Garfield) 
        (1.0 0.42163100057836905)) 
      ( (Garfield --> being) 
        (1.0 0.7290000000000001)))))
</span>; Trace took 36.81 ms.
<span class="ansi33">  (got 
    ( ( (Garfield --> being) 
        (1.0 0.7290000000000001)) 
      ( (being --> Garfield) 
        (1.0 0.42163100057836905)) 
      ( (being --> Garfield) 
        (1.0 0.28712091374556914)) 
      ( (being <-> Garfield) 
        (1.0 0.28712091374556914)) 
      ( (being <-> Garfield) 
        (1.0 0.28712091374556914)) 
      ( (being <-> Garfield) 
        (1.0 0.28712091374556914)) 
      ( (being <-> Garfield) 
        (1.0 0.28712091374556914)) 
      ( (being <-> Garfield) 
        (1.0 0.28712091374556914)) 
      ( (being <-> Garfield) 
        (1.0 0.28712091374556914)) 
      ( (being <-> Garfield) 
        (1.0 0.28712091374556914)) 
      ( (being <-> Garfield) 
        (1.0 0.28712091374556914)) 
      ( (being <-> Garfield) 
        (1.0 0.28712091374556914)) 
      ( (being <-> Garfield) 
        (1.0 0.28712091374556914))) expected 
    ( ( (animal --> 
          (Garfield | being)) 
        (1.0 0.40276243093922653)) 
      ( (animal --> 
          (Garfield & being)) 
        (1.0 0.40276243093922653)) 
      ( (animal --> 
          (Garfield - being)) 
        (0.0 0.40276243093922653)) 
      ( (being <-> Garfield) 
        (1.0 0.28712091374556914)) 
      ( (being --> Garfield) 
        (1.0 0.28712091374556914)) 
      ( (being --> Garfield) 
        (1.0 0.42163100057836905)) 
      ( (Garfield --> being) 
        (1.0 0.7290000000000001))))

</span><span class="ansi32">% 10,039,310 inferences, 16.559 CPU in 16.560 seconds (100% CPU, 606277 Lips)
</span> (@ = "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/nars/current/tests0.metta" 0)
<span class="ansi1">LoonIt Report
</span>------------
<span class="ansi32">Successes: 6
</span><span class="ansi31">Failures: 2
</span>doing(ansi2html -u < "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/TEE.ansi" > "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/nars/current/tests0.html" )

</pre>
</body>

</html>
