<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>
<style type="text/css">
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi36 { color: #00aaaa; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content">
 (@ track_load_into_file "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/synthesis/experiments/synthesize-via-type-checking.metta")
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/synthesis/experiments/synthesize-via-type-checking.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/synthesis/experiments/synthesize-via-type-checking.metta')
1=(synthesize= (Cons f (Cons g Nil)) (S Z) (Cons f (Cons g Nil)))
1=(info (variables (prgs (Cons f (Cons g Nil))) (cmbs (Cons (. f f) (Cons (. f g) (Cons (. g f) (Cons (. g g) Nil)))))) (synthesize= (Cons f (Cons g Nil)) (S (S Z)) (Cons (. f f) (Cons (. f g) (Cons (. g f) (Cons (. g g) Nil))))))
1=[()]
2=[("Unit Tests")]
3=[(Cons 3 (Cons 4 (Cons 2 Nil)))]
4=[(Cons 2 Nil)]
5=[Nil]
6=[(Cons 1 (Cons "a" (Cons 2 (Cons "b" Nil))))]
7=[Nil]
8=[Nil]
9=[(Cons 2 Nil)]
10=[(Cons 3 (Cons 4 (Cons 6 (Cons 8 Nil))))]
11=[(Cons (. g f) Nil)]
12=[(Cons (. f g) Nil)]
13=[(Cons (. f f) (Cons (. f g) (Cons (. g f) (Cons (. g g) Nil))))]
14=[(Cons (. f f) (Cons (. f g) (Cons (. g f) (Cons (. g g) Nil))))]
15=9.91user 0.02system 0:09.94elapsed 99%CPU (0avgtext+0avgdata 39604maxresident)k
15=0inputs+0outputs (0major+5122minor)pagefaults 0swaps
:- dynamic file_answers/3.

file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/synthesis/experiments/synthesize-via-type-checking.metta', 1, [[]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/synthesis/experiments/synthesize-via-type-checking.metta', 2, [["Unit Tests"]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/synthesis/experiments/synthesize-via-type-checking.metta', 3, [['Cons', 3, ['Cons', 4, ['Cons', 2, []]]]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/synthesis/experiments/synthesize-via-type-checking.metta', 4, [['Cons', 2, []]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/synthesis/experiments/synthesize-via-type-checking.metta', 5, [[]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/synthesis/experiments/synthesize-via-type-checking.metta', 6, [['Cons', 1, ['Cons', "a", ['Cons', 2, ['Cons', "b", []]]]]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/synthesis/experiments/synthesize-via-type-checking.metta', 7, [[]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/synthesis/experiments/synthesize-via-type-checking.metta', 8, [[]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/synthesis/experiments/synthesize-via-type-checking.metta', 9, [['Cons', 2, []]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/synthesis/experiments/synthesize-via-type-checking.metta', 10, [['Cons', 3, ['Cons', 4, ['Cons', 6, ['Cons', 8, []]]]]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/synthesis/experiments/synthesize-via-type-checking.metta', 11, [['Cons', ['.', g, f], []]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/synthesis/experiments/synthesize-via-type-checking.metta', 12, [['Cons', ['.', f, g], []]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/synthesis/experiments/synthesize-via-type-checking.metta', 13, [['Cons', ['.', f, f], ['Cons', ['.', f, g], ['Cons', ['.', g, f], ['Cons', ['.', g, g], []]]]]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/synthesis/experiments/synthesize-via-type-checking.metta', 14, [['Cons', ['.', f, f], ['Cons', ['.', f, g], ['Cons', ['.', g, f], ['Cons', ['.', g, g], []]]]]]).

;;; Import modules
<span class="ansi38-000068000">!(import! &self "../../common/Num.metta")

</span>      -->(0,'&self',['import!','&self','../../common/Num.metta'],depth(1))
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/synthesis/experiments/synthesize-via-type-checking.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/synthesis/experiments/synthesize-via-type-checking.metta')
;; ;; Type definitions checker
;; !(pragma! type-check auto)
;; ;; Equality type definition
;; (: = (-> $t $t Type))
;; Define an heterogeneous list.
;;; Collection of functions operating on numbers
;; Define max
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,max,[->,A,A,A]])
</span><span class="ansi38-255165000">  (: max 
    (-> $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[max,X,Y],[if,[>,X,Y],X,Y])
</span><span class="ansi38-255165000">  (= 
    (max $X $Y) 
    (if 
      (> $X $Y) $X $Y))
</span>

;; Define min
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,min,[->,A,A,A]])
</span><span class="ansi38-255165000">  (: min 
    (-> $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[min,X,Y],[if,[<,X,Y],X,Y])
</span><span class="ansi38-255165000">  (= 
    (min $X $Y) 
    (if 
      (< $X $Y) $X $Y))
</span>

;; Clamp a number to be within a certain range
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,clamp,[->,A,A,A,A]])
</span><span class="ansi38-255165000">  (: clamp 
    (-> $A $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[clamp,X,L,U],[max,L,[min,U,X]])
</span><span class="ansi38-255165000">  (= 
    (clamp $X $L $U) 
    (max $L 
      (min $U $X)))
</span>

;; Define abs
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,abs,[->,A,A]])
</span><span class="ansi38-255165000">  (: abs 
    (-> $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[abs,X],[if,[<,X,0],[*,-1,X],X])
</span><span class="ansi38-255165000">  (= 
    (abs $X) 
    (if 
      (< $X 0) 
      (* -1 $X) $X))
</span>

;; Define <=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,<=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: <= 
    (-> $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[<=,X,Y],[or,[<,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">  (= 
    (<= $X $Y) 
    (or 
      (< $X $Y) 
      (== $X $Y)))
</span>

;; Define >=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,>=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: >= 
    (-> $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[>=,X,Y],[or,[>,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">  (= 
    (>= $X $Y) 
    (or 
      (> $X $Y) 
      (== $X $Y)))
</span>

;; Define approximately equal
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,approxEq,[->,A,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: approxEq 
    (-> $A $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[approxEq,X,Y,Epsilon],[<=,[abs,[-,X,Y]],Epsilon])
</span><span class="ansi38-255165000">  (= 
    (approxEq $X $Y $Epsilon) 
    (<= 
      (abs 
        (- $X $Y)) $Epsilon))
</span>

;; Define Nat
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Nat','Type'])
</span><span class="ansi38-255165000">  (: Nat Type)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Z','Nat'])
</span><span class="ansi38-255165000">  (: Z Nat)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'S',[->,'Nat','Nat']])
</span><span class="ansi38-255165000">  (: S 
    (-> Nat Nat))
</span>

;; Define cast functions between Nat and Number
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNumber,[->,'Number','Nat']])
</span><span class="ansi38-255165000">  (: fromNumber 
    (-> Number Nat))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNumber,N],[if,[<=,N,0],'Z',['S',[fromNumber,[-,N,1]]]])
</span><span class="ansi38-255165000">  (= 
    (fromNumber $N) 
    (if 
      (<= $N 0) Z 
      (S 
        (fromNumber 
          (- $N 1)))))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNat,[->,'Nat','Number']])
</span><span class="ansi38-255165000">  (: fromNat 
    (-> Nat Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,'Z'],0)
</span><span class="ansi38-255165000">  (= 
    (fromNat Z) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,['S',K]],[+,1,[fromNat,K]])
</span><span class="ansi38-255165000">  (= 
    (fromNat 
      (S $K)) 
    (+ 1 
      (fromNat $K)))
</span>

;; Define a generic less than operator, â©», for Nat.  < cannot be used
;; because it is a built-in, its type is hardwired and cannot be
;; overloaded.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Nat','Nat','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Nat Nat Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',_,'Z'],'False')
</span><span class="ansi38-255165000">  (= 
    (â©» $_ Z) False)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»','Z',['S',_]],'True')
</span><span class="ansi38-255165000">  (= 
    (â©» Z 
      (S $_)) True)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',['S',X],['S',Y]],['â©»',X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» 
      (S $X) 
      (S $Y)) 
    (â©» $X $Y))
</span>

;; Overload â©» for Number.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Number','Number','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Number Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',X,Y],[<,X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» $X $Y) 
    (< $X $Y))
</span>

;; Return the ceiling of a non negative number.  If the number is
;; negative it returns 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,ceil,[->,'Number','Number']])
</span><span class="ansi38-255165000">  (: ceil 
    (-> Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[ceil,N],[fromNat,[fromNumber,N]])
</span><span class="ansi38-255165000">  (= 
    (ceil $N) 
    (fromNat 
      (fromNumber $N)))
</span>

;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'number->bool',[->,'Number','Bool']])
</span><span class="ansi38-255165000">  (: number->bool 
    (-> Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['number->bool',X],[<,0,X])
</span><span class="ansi38-255165000">  (= 
    (number->bool $X) 
    (< 0 $X))
</span>

;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'bool->number',[->,'Bool','Number']])
</span><span class="ansi38-255165000">  (: bool->number 
    (-> Bool Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','False'],0)
</span><span class="ansi38-255165000">  (= 
    (bool->number False) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','True'],1)
</span><span class="ansi38-255165000">  (= 
    (bool->number True) 1)
</span>

;; Define a less than type.  Note that it is purposefully different
;; than â©» as it is a type, not an operator.  Inhabitants of (â x y)
;; are proofs that x â©» y == True.  For now â is only axiomatized for
;; Nat.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â\x8D\\x83\',[->,True,True,'Type']])
</span><span class="ansi38-255165000">  (: â 
    (-> $True $True Type))
</span>

;; Zero is always less than the successor of something
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['zero-lt-succ-axiom'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['zero-lt-succ-axiom'],[:,'ZeroLTSucc',['â\x8D\\x83\','Z',['S',K]]])
</span><span class="ansi38-255165000">  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (â Z 
        (S $K))))
</span>

;; If x â y then (S x) â (S y)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['succ-monotonicity-rule'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['succ-monotonicity-rule'],[:,'SuccMonotonicity',[->,['â\x8D\\x83\',X,Y],['â\x8D\\x83\',['S',X],['S',Y]]]])
</span><span class="ansi38-255165000">  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (â $X $Y) 
        (â 
          (S $X) 
          (S $Y)))))
</span>

      <--(0,retval('Empty'))
<span class="ansi33"> Empty

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'List','Type'])
</span><span class="ansi38-255165000">  (: List Type)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,[],'List'])
</span><span class="ansi38-255165000">  (: () List)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Cons',[->,A,'List','List']])
</span><span class="ansi38-255165000">  (: Cons 
    (-> $A List List))
</span>

;; Define map, a map implementation operating on List
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,map,[->,[->,A,B],'List','List']])
</span><span class="ansi38-255165000">  (: map 
    (-> 
      (-> $A $B) List List))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[map,Fn,[]],[])
</span><span class="ansi38-255165000">  (= 
    (map $Fn ()) ())
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[map,Fn,['Cons',Head,Tail]],['Cons',[Fn,Head],[map,Fn,Tail]])
</span><span class="ansi38-255165000">  (= 
    (map $Fn 
      (Cons $Head $Tail)) 
    (Cons 
      ($Fn $Head) 
      (map $Fn $Tail)))
</span>

;; Define filter, a filter implementation operating on List
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,filter,[->,[->,A,'Bool'],'List','List']])
</span><span class="ansi38-255165000">  (: filter 
    (-> 
      (-> $A Bool) List List))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[filter,Prd,[]],[])
</span><span class="ansi38-255165000">  (= 
    (filter $Prd ()) ())
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[filter,Prd,['Cons',Head,Tail]],[if,[Prd,Head],['Cons',Head,[filter,Prd,Tail]],[filter,Prd,Tail]])
</span><span class="ansi38-255165000">  (= 
    (filter $Prd 
      (Cons $Head $Tail)) 
    (if 
      ($Prd $Head) 
      (Cons $Head 
        (filter $Prd $Tail)) 
      (filter $Prd $Tail)))
</span>

;; Define lambda (essentially lambda is curried let)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,lambda,[->,A,True,[->,A,True]]])
</span><span class="ansi38-255165000">  (: lambda 
    (-> $A $True 
      (-> $A $True)))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[[lambda,Var,Body],Arg],[let,Var,Arg,Body])
</span><span class="ansi38-255165000">  (= 
    ( (lambda $Var $Body) $Arg) 
    (let $Var $Arg $Body))
</span>

;; Define curry.  Given a binary function, and its first argument,
;; return a unary function corresponding to the partial evaluation of
;; the binary function over the first argument.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,curry,[->,[->,A,B,C],A,[->,B,C]]])
</span><span class="ansi38-255165000">  (: curry 
    (-> 
      (-> $A $B $C) $A 
      (-> $B $C)))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[[curry,False,X],Y],[False,X,Y])
</span><span class="ansi38-255165000">  (= 
    ( (curry $False $X) $Y) 
    ($False $X $Y))
</span>

;; Interleave two lists
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,interleave,[->,'List','List','List']])
</span><span class="ansi38-255165000">  (: interleave 
    (-> List List List))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[interleave,[],Ys],Ys)
</span><span class="ansi38-255165000">  (= 
    (interleave () $Ys) $Ys)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[interleave,['Cons',Head,Tail],Ys],['Cons',Head,[interleave,Ys,Tail]])
</span><span class="ansi38-255165000">  (= 
    (interleave 
      (Cons $Head $Tail) $Ys) 
    (Cons $Head 
      (interleave $Ys $Tail)))
</span>

;; Cartesian product with a given operator on List
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,prodWith,[->,[->,A,B,C],'List','List','List']])
</span><span class="ansi38-255165000">  (: prodWith 
    (-> 
      (-> $A $B $C) List List List))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[prodWith,Op,[],[]],[])
</span><span class="ansi38-255165000">  (= 
    (prodWith $Op () ()) ())
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[prodWith,Op,[],['Cons',Head,Tail]],[])
</span><span class="ansi38-255165000">  (= 
    (prodWith $Op () 
      (Cons $Head $Tail)) ())
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[prodWith,Op,['Cons',Head,Tail],[]],[])
</span><span class="ansi38-255165000">  (= 
    (prodWith $Op 
      (Cons $Head $Tail) ()) ())
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[prodWith,Op,['Cons',Xhd,Xtl],['Cons',Yhd,Ytl]],['Cons',[Op,Xhd,Yhd],[interleave,[map,[curry,Op,Xhd],Ytl],[prodWith,Op,Xtl,['Cons',Yhd,Ytl]]]])
</span><span class="ansi38-255165000">  (= 
    (prodWith $Op 
      (Cons $Xhd $Xtl) 
      (Cons $Yhd $Ytl)) 
    (Cons 
      ($Op $Xhd $Yhd) 
      (interleave 
        (map 
          (curry $Op $Xhd) $Ytl) 
        (prodWith $Op $Xtl 
          (Cons $Yhd $Ytl)))))
</span>

;; Define composition operator
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,->,[->,B,C],[->,A,D],[->,A,C]])
</span><span class="ansi38-255165000">  (: -> 
    (-> $B $C) 
    (-> $A $D) 
    (-> $A $C))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[['.',G,False],X],[G,[False,X]])
</span><span class="ansi38-255165000">  (= 
    ( (. $G $False) $X) 
    ($G 
      ($False $X)))
</span>

;; Define well-typed.  Returns True iff its argument is well typed.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'well-typed',[->,'Atom','Bool']])
</span><span class="ansi38-255165000">  (: well-typed 
    (-> Atom Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['well-typed',X],[case,X,[[['Error',V,M],'False'],[_,'True']]])
</span><span class="ansi38-255165000">  (= 
    (well-typed $X) 
    (case $X 
      ( ( (Error $V $M) False) 
        ($_ True))))
</span>

;; Program synthesizer.  It takes a list of functions, a depth, and
;; returns a list of programs composing these functions up to the
;; given depth.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,synthesize,[->,'List','Nat','List']])
</span><span class="ansi38-255165000">  (: synthesize 
    (-> List Nat List))
</span>

; TODO: add type signature as argument
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Fns,'Z'],['trace!',['synthesize=',Fns,'Z',[]],[]])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Fns Z) 
    (trace! 
      (synthesize= $Fns Z ()) ()))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Fns,['S','Z']],['trace!',['synthesize=',Fns,['S','Z'],Fns],Fns])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Fns 
      (S Z)) 
    (trace! 
      (synthesize= $Fns 
        (S Z) $Fns) $Fns))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Fns,['S',['S',K]]],['let*',[[Prgs,[synthesize,Fns,['S',K]]],[Cmbs,[prodWith,'.',Fns,Prgs]],[Vld,[filter,'well-typed',Cmbs]]],['trace!',[info,[variables,[prgs,Prgs],[cmbs,Cmbs]],['synthesize=',Fns,['S',['S',K]],Vld]],Vld]])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Fns 
      (S 
        (S $K))) 
    (let* 
      ( ($Prgs 
          (synthesize $Fns 
            (S $K))) 
        ($Cmbs 
          (prodWith . $Fns $Prgs)) 
        ($Vld 
          (filter well-typed $Cmbs))) 
      (trace! 
        (info 
          (variables 
            (prgs $Prgs) 
            (cmbs $Cmbs)) 
          (synthesize= $Fns 
            (S 
              (S $K)) $Vld)) $Vld)))
</span>

; TODO: should be concatenated with $prgs?
;;;;;;;;;;;;;;;;
;; Unit tests ;;
;;;;;;;;;;;;;;;;
<span class="ansi38-000068000">!("Unit Tests")

</span>      -->(1,'&self',["Unit Tests"],depth(1))
<span class="ansi33">  ("Unit Tests")

</span><span class="ansi36">
! (assertEqualToResult 
    ("Unit Tests") 
    ( ("Unit Tests")))
(@ ! 
  (assertEqual 
    ( ("Unit Tests")) 
    ( ("Unit Tests"))))
write_pass_fail_result("EXPERIMENTS.SYNTHESIZE-VIA-TYPE-CHECKING.102",exec,["Unit Tests"],'PASS',[["Unit Tests"]],[["Unit Tests"]])

</span>

--------------------------------------------------------------------------
;; Test map
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,inc,[->,'Number','Number']])
</span><span class="ansi38-255165000">  (: inc 
    (-> Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[inc,N],[+,N,1])
</span><span class="ansi38-255165000">  (= 
    (inc $N) 
    (+ $N 1))
</span>

<span class="ansi38-000068000">!(map inc 
  (Cons 2 
    (Cons 3 
      (Cons 1 ()))))

</span>      -->(2,'&self',[map,inc,['Cons',2,['Cons',3,['Cons',1,[]]]]],depth(1))
          -->(3,'&self',['Cons',1,[]],depth(3))
        -->(4,'&self',['Cons',[inc,2],[map,inc,['Cons',3,['Cons',1,[]]]]],depth(2))
            -->(5,'&self',[inc,2],depth(4))
              -->(6,'&self',[+,2,1],depth(5))
              <--(6,retval(3))
            -->(7,'&self',[map,inc,['Cons',3,['Cons',1,[]]]],depth(4))
                -->(8,'&self',['Cons',1,[]],depth(6))
              -->(9,'&self',['Cons',[inc,3],[map,inc,['Cons',1,[]]]],depth(5))
                  -->(10,'&self',[inc,3],depth(7))
                    -->(11,'&self',[+,3,1],depth(8))
                    <--(11,retval(4))
                  -->(12,'&self',[map,inc,['Cons',1,[]]],depth(7))
                      -->(13,'&self',['Cons',1,[]],depth(9))
                    -->(14,'&self',['Cons',[inc,1],[map,inc,[]]],depth(8))
                        -->(15,'&self',[inc,1],depth(10))
                          -->(16,'&self',[+,1,1],depth(11))
                          <--(16,retval(2))
                        -->(17,'&self',[map,inc,[]],depth(10))
                      -->(18,'&self',['Cons',2,[]],depth(9))
                -->(19,'&self',['Cons',4,['Cons',2,[]]],depth(6))
                    -->(20,'&self',['Cons',2,[]],depth(8))
          -->(21,'&self',['Cons',3,['Cons',4,['Cons',2,[]]]],depth(3))
              -->(22,'&self',['Cons',4,['Cons',2,[]]],depth(5))
                  -->(23,'&self',['Cons',2,[]],depth(7))
<span class="ansi33">  (Cons 3 
    (Cons 4 
      (Cons 2 ())))

</span>                        <--(17,retval([]))
                        <--(15,retval([+,1,1]))
                    <--(14,retval(['Cons',2,[]]))
                  <--(12,retval(['Cons',[inc,1],[map,inc,[]]]))
                  <--(10,retval([+,3,1]))
              <--(9,retval(['Cons',4,['Cons',2,[]]]))
            <--(7,retval(['Cons',[inc,3],[map,inc,['Cons',1,[]]]]))
            <--(5,retval([+,2,1]))
        <--(4,retval(['Cons',3,['Cons',4,['Cons',2,[]]]]))
      <--(2,retval(['Cons',[inc,2],[map,inc,['Cons',3,['Cons',1,[]]]]]))
<span class="ansi36">
! (assertEqualToResult 
    (map inc 
      (Cons 2 
        (Cons 3 
          (Cons 1 ())))) 
    ( (Cons 3 
        (Cons 4 
          (Cons 2 ())))))
(@ ! 
  (assertEqual 
    ( (Cons 3 
        (Cons 4 
          (Cons 2 ())))) 
    ( (Cons 3 
        (Cons 4 
          (Cons 2 ()))))))
write_pass_fail_result("EXPERIMENTS.SYNTHESIZE-VIA-TYPE-CHECKING.103",exec,[map,inc,['Cons',2,['Cons',3,['Cons',1,[]]]]],'PASS',[['Cons',3,['Cons',4,['Cons',2,[]]]]],[['Cons',3,['Cons',4,['Cons',2,[]]]]])

</span>

--------------------------------------------------------------------------
; (Cons 3 (Cons 4 (Cons 2 Nil)))
;; Test filter
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,even,[->,'Number','Bool']])
</span><span class="ansi38-255165000">  (: even 
    (-> Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[even,N],[==,[*,[ceil,[/,N,2]],2],N])
</span><span class="ansi38-255165000">  (= 
    (even $N) 
    (== 
      (* 
        (ceil 
          (/ $N 2)) 2) $N))
</span>

<span class="ansi38-000068000">!(filter even 
  (Cons 2 
    (Cons 3 
      (Cons 1 ()))))

</span>      -->(24,'&self',[filter,even,['Cons',2,['Cons',3,['Cons',1,[]]]]],depth(1))
          -->(25,'&self',['Cons',1,[]],depth(3))
        -->(26,'&self',[if,[even,2],['Cons',2,[filter,even,['Cons',3,['Cons',1,[]]]]],[filter,even,['Cons',3,['Cons',1,[]]]]],depth(2))
            -->(27,'&self',[even,2],depth(4))
              -->(28,'&self',[==,[*,[ceil,[/,2,2]],2],2],depth(5))
                  -->(29,'&self',[/,2,2],depth(7))
                  <--(29,retval(1))
                  -->(30,'&self',[==,[*,[ceil,1],2],2],depth(7))
                      -->(31,'&self',[ceil,1],depth(9))
                        -->(32,'&self',[fromNat,[fromNumber,1]],depth(10))
                            -->(33,'&self',[fromNumber,1],depth(12))
                              -->(34,'&self',[if,[<=,1,0],'Z',['S',[fromNumber,[-,1,1]]]],depth(13))
                                  -->(35,'&self',[<=,1,0],depth(15))
                                    -->(36,'&self',[or,[<,1,0],[==,1,0]],depth(16))
                                        -->(37,'&self',[<,1,0],depth(18))
                                        <--(37,retval('False'))
                                        -->(38,'&self',[==,1,0],depth(18))
                                        <--(38,retval('False'))
                                    <--(36,retval('False'))
                                  -->(39,'&self',['S',[fromNumber,[-,1,1]]],depth(15))
                                      -->(40,'&self',[fromNumber,[-,1,1]],depth(17))
                                          -->(41,'&self',[-,1,1],depth(19))
                                          <--(41,retval(0))
                                          -->(42,'&self',[fromNumber,0],depth(19))
                                            -->(43,'&self',[if,[<=,0,0],'Z',['S',[fromNumber,[-,0,1]]]],depth(20))
                                                -->(44,'&self',[<=,0,0],depth(22))
                                                  -->(45,'&self',[or,[<,0,0],[==,0,0]],depth(23))
                                                      -->(46,'&self',[<,0,0],depth(25))
                                                      <--(46,retval('False'))
                                                      -->(47,'&self',[==,0,0],depth(25))
                                                      <--(47,retval('True'))
                                                  <--(45,retval('True'))
                                    -->(48,'&self',['S','Z'],depth(16))
                                -->(49,'&self',['S','Z'],depth(14))
                            -->(50,'&self',[fromNat,['S','Z']],depth(12))
                                -->(51,'&self',['S','Z'],depth(14))
                              -->(52,'&self',[+,1,[fromNat,'Z']],depth(13))
                                  -->(53,'&self',[fromNat,'Z'],depth(15))
                      -->(54,'&self',[==,[*,1,2],2],depth(9))
                          -->(55,'&self',[*,1,2],depth(11))
                          <--(55,retval(2))
                          -->(56,'&self',[==,2,2],depth(11))
                          <--(56,retval('True'))
            -->(57,'&self',['Cons',2,[filter,even,['Cons',3,['Cons',1,[]]]]],depth(4))
                -->(58,'&self',[filter,even,['Cons',3,['Cons',1,[]]]],depth(6))
                    -->(59,'&self',['Cons',1,[]],depth(8))
                  -->(60,'&self',[if,[even,3],['Cons',3,[filter,even,['Cons',1,[]]]],[filter,even,['Cons',1,[]]]],depth(7))
                      -->(61,'&self',[even,3],depth(9))
                        -->(62,'&self',[==,[*,[ceil,[/,3,2]],2],3],depth(10))
                            -->(63,'&self',[/,3,2],depth(12))
                            <--(63,retval(1.5))
                            -->(64,'&self',[==,[*,[ceil,1.5],2],3],depth(12))
                                -->(65,'&self',[ceil,1.5],depth(14))
                                  -->(66,'&self',[fromNat,[fromNumber,1.5]],depth(15))
                                      -->(67,'&self',[fromNumber,1.5],depth(17))
                                        -->(68,'&self',[if,[<=,1.5,0],'Z',['S',[fromNumber,[-,1.5,1]]]],depth(18))
                                            -->(69,'&self',[<=,1.5,0],depth(20))
                                              -->(70,'&self',[or,[<,1.5,0],[==,1.5,0]],depth(21))
                                                  -->(71,'&self',[<,1.5,0],depth(23))
                                                  <--(71,retval('False'))
                                                  -->(72,'&self',[==,1.5,0],depth(23))
                                                  <--(72,retval('False'))
                                              <--(70,retval('False'))
                                            -->(73,'&self',['S',[fromNumber,[-,1.5,1]]],depth(20))
                                                -->(74,'&self',[fromNumber,[-,1.5,1]],depth(22))
                                                    -->(75,'&self',[-,1.5,1],depth(24))
                                                    <--(75,retval(0.5))
                                                    -->(76,'&self',[fromNumber,0.5],depth(24))
                                                      -->(77,'&self',[if,[<=,0.5,0],'Z',['S',[fromNumber,[-,0.5,1]]]],depth(25))
                                                          -->(78,'&self',[<=,0.5,0],depth(27))
                                                            -->(79,'&self',[or,[<,0.5,0],[==,0.5,0]],depth(28))
                                                                -->(80,'&self',[<,0.5,0],depth(30))
                                                                <--(80,retval('False'))
                                                                -->(81,'&self',[==,0.5,0],depth(30))
                                                                <--(81,retval('False'))
                                                            <--(79,retval('False'))
                                                          -->(82,'&self',['S',[fromNumber,[-,0.5,1]]],depth(27))
                                                              -->(83,'&self',[fromNumber,[-,0.5,1]],depth(29))
                                                                  -->(84,'&self',[-,0.5,1],depth(31))
                                                                  <--(84,retval(-0.5))
                                                                  -->(85,'&self',[fromNumber,-0.5],depth(31))
                                                                    -->(86,'&self',[if,[<=,-0.5,0],'Z',['S',[fromNumber,[-,-0.5,1]]]],depth(32))
                                                                        -->(87,'&self',[<=,-0.5,0],depth(34))
                                                                          -->(88,'&self',[or,[<,-0.5,0],[==,-0.5,0]],depth(35))
                                                                              -->(89,'&self',[<,-0.5,0],depth(37))
                                                                              <--(89,retval('True'))
                                                                          <--(88,retval('True'))
                                                            -->(90,'&self',['S','Z'],depth(28))
                                                        -->(91,'&self',['S','Z'],depth(26))
                                                  -->(92,'&self',['S','Z'],depth(23))
                                              -->(93,'&self',['S',['S','Z']],depth(21))
                                                  -->(94,'&self',['S','Z'],depth(23))
                                          -->(95,'&self',['S',['S','Z']],depth(19))
                                              -->(96,'&self',['S','Z'],depth(21))
                                      -->(97,'&self',[fromNat,['S',['S','Z']]],depth(17))
                                          -->(98,'&self',['S','Z'],depth(19))
                                        -->(99,'&self',[+,1,[fromNat,['S','Z']]],depth(18))
                                            -->(100,'&self',[fromNat,['S','Z']],depth(20))
Switched off tracing. For a longer trace !(pragma! tracelen 101))<span class="ansi33">
  (Cons 2 ())

</span><span class="ansi36">
! (assertEqualToResult 
    (filter even 
      (Cons 2 
        (Cons 3 
          (Cons 1 ())))) 
    ( (Cons 2 ())))
(@ ! 
  (assertEqual 
    ( (Cons 2 ())) 
    ( (Cons 2 ()))))
write_pass_fail_result("EXPERIMENTS.SYNTHESIZE-VIA-TYPE-CHECKING.104",exec,[filter,even,['Cons',2,['Cons',3,['Cons',1,[]]]]],'PASS',[['Cons',2,[]]],[['Cons',2,[]]])

</span>

--------------------------------------------------------------------------
; (Cons 2 Nil)
;; Test interleave
<span class="ansi38-000068000">!(interleave () ())

</span>      -->(0,'&self',[interleave,[],[]],depth(1))
<span class="ansi33"> ()

</span>      <--(0,retval([]))
<span class="ansi36">
! (assertEqualToResult 
    (interleave () ()) 
    (()))
(@ ! 
  (assertEqual 
    (()) 
    (())))
write_pass_fail_result("EXPERIMENTS.SYNTHESIZE-VIA-TYPE-CHECKING.105",exec,[interleave,[],[]],'PASS',[[]],[[]])

</span>

--------------------------------------------------------------------------
; Nil
<span class="ansi38-000068000">!(interleave 
  (Cons 1 
    (Cons 2 ())) 
  (Cons "a" 
    (Cons "b" ())))

</span>      -->(1,'&self',[interleave,['Cons',1,['Cons',2,[]]],['Cons',"a",['Cons',"b",[]]]],depth(1))
          -->(2,'&self',['Cons',2,[]],depth(3))
        -->(3,'&self',['Cons',1,[interleave,['Cons',"a",['Cons',"b",[]]],['Cons',2,[]]]],depth(2))
            -->(4,'&self',[interleave,['Cons',"a",['Cons',"b",[]]],['Cons',2,[]]],depth(4))
                -->(5,'&self',['Cons',"b",[]],depth(6))
              -->(6,'&self',['Cons',"a",[interleave,['Cons',2,[]],['Cons',"b",[]]]],depth(5))
                  -->(7,'&self',[interleave,['Cons',2,[]],['Cons',"b",[]]],depth(7))
                      -->(8,'&self',['Cons',2,[]],depth(9))
                    -->(9,'&self',['Cons',2,[interleave,['Cons',"b",[]],[]]],depth(8))
                        -->(10,'&self',[interleave,['Cons',"b",[]],[]],depth(10))
                            -->(11,'&self',['Cons',"b",[]],depth(12))
                          -->(12,'&self',['Cons',"b",[interleave,[],[]]],depth(11))
                              -->(13,'&self',[interleave,[],[]],depth(13))
                            -->(14,'&self',['Cons',"b",[]],depth(12))
                      -->(15,'&self',['Cons',2,['Cons',"b",[]]],depth(9))
                          -->(16,'&self',['Cons',"b",[]],depth(11))
                -->(17,'&self',['Cons',"a",['Cons',2,['Cons',"b",[]]]],depth(6))
                    -->(18,'&self',['Cons',2,['Cons',"b",[]]],depth(8))
                        -->(19,'&self',['Cons',"b",[]],depth(10))
          -->(20,'&self',['Cons',1,['Cons',"a",['Cons',2,['Cons',"b",[]]]]],depth(3))
              -->(21,'&self',['Cons',"a",['Cons',2,['Cons',"b",[]]]],depth(5))
                  -->(22,'&self',['Cons',2,['Cons',"b",[]]],depth(7))
                      -->(23,'&self',['Cons',"b",[]],depth(9))
<span class="ansi33">  (Cons 1 
    (Cons "a" 
      (Cons 2 
        (Cons "b" ()))))

</span>                              <--(13,retval([]))
                          <--(12,retval(['Cons',"b",[]]))
                        <--(10,retval(['Cons',"b",[interleave,[],[]]]))
                    <--(9,retval(['Cons',2,['Cons',"b",[]]]))
                  <--(7,retval(['Cons',2,[interleave,['Cons',"b",[]],[]]]))
              <--(6,retval(['Cons',"a",['Cons',2,['Cons',"b",[]]]]))
            <--(4,retval(['Cons',"a",[interleave,['Cons',2,[]],['Cons',"b",[]]]]))
        <--(3,retval(['Cons',1,['Cons',"a",['Cons',2,['Cons',"b",[]]]]]))
      <--(1,retval(['Cons',1,[interleave,['Cons',"a",['Cons',"b",[]]],['Cons',2,[]]]]))
<span class="ansi36">
! (assertEqualToResult 
    (interleave 
      (Cons 1 
        (Cons 2 ())) 
      (Cons "a" 
        (Cons "b" ()))) 
    ( (Cons 1 
        (Cons "a" 
          (Cons 2 
            (Cons "b" ()))))))
(@ ! 
  (assertEqual 
    ( (Cons 1 
        (Cons "a" 
          (Cons 2 
            (Cons "b" ()))))) 
    ( (Cons 1 
        (Cons "a" 
          (Cons 2 
            (Cons "b" ())))))))
write_pass_fail_result("EXPERIMENTS.SYNTHESIZE-VIA-TYPE-CHECKING.106",exec,[interleave,['Cons',1,['Cons',2,[]]],['Cons',"a",['Cons',"b",[]]]],'PASS',[['Cons',1,['Cons',"a",['Cons',2,['Cons',"b",[]]]]]],[['Cons',1,['Cons',"a",['Cons',2,['Cons',"b",[]]]]]])

</span>

--------------------------------------------------------------------------
; (Cons 1 (Cons "a" (Cons 2 (Cons "b" Nil))))
;; Test prodWith
<span class="ansi38-000068000">!(prodWith * () 
  (Cons 2 ()))

</span>      -->(24,'&self',[prodWith,*,[],['Cons',2,[]]],depth(1))
          -->(25,'&self',['Cons',2,[]],depth(3))
<span class="ansi33"> ()

</span>      <--(24,retval([]))
<span class="ansi36">
! (assertEqualToResult 
    (prodWith * () 
      (Cons 2 ())) 
    (()))
(@ ! 
  (assertEqual 
    (()) 
    (())))
write_pass_fail_result("EXPERIMENTS.SYNTHESIZE-VIA-TYPE-CHECKING.107",exec,[prodWith,*,[],['Cons',2,[]]],'PASS',[[]],[[]])

</span>

--------------------------------------------------------------------------
; Nil
<span class="ansi38-000068000">!(prodWith * 
  (Cons 1 ()) ())

</span>      -->(26,'&self',[prodWith,*,['Cons',1,[]],[]],depth(1))
          -->(27,'&self',['Cons',1,[]],depth(3))
<span class="ansi33"> ()

</span>      <--(26,retval([]))
<span class="ansi36">
! (assertEqualToResult 
    (prodWith * 
      (Cons 1 ()) ()) 
    (()))
(@ ! 
  (assertEqual 
    (()) 
    (())))
write_pass_fail_result("EXPERIMENTS.SYNTHESIZE-VIA-TYPE-CHECKING.108",exec,[prodWith,*,['Cons',1,[]],[]],'PASS',[[]],[[]])

</span>

--------------------------------------------------------------------------
; Nil
<span class="ansi38-000068000">!(prodWith * 
  (Cons 1 ()) 
  (Cons 2 ()))

</span>      -->(28,'&self',[prodWith,*,['Cons',1,[]],['Cons',2,[]]],depth(1))
          -->(29,'&self',['Cons',1,[]],depth(3))
        -->(30,'&self',['Cons',[*,1,2],[interleave,[map,[curry,*,1],[]],[prodWith,*,[],['Cons',2,[]]]]],depth(2))
            -->(31,'&self',[*,1,2],depth(4))
            <--(31,retval(2))
            -->(32,'&self',[interleave,[map,[curry,*,1],[]],[prodWith,*,[],['Cons',2,[]]]],depth(4))
                -->(33,'&self',[curry,*,1],depth(6))
                -->(34,'&self',[curry,*,1],depth(6))
                -->(35,'&self',['Cons',2,[]],depth(6))
                -->(36,'&self',[map,[curry,*,1],[]],depth(6))
                    -->(37,'&self',[curry,*,1],depth(8))
                -->(38,'&self',[prodWith,*,[],['Cons',2,[]]],depth(6))
                    -->(39,'&self',['Cons',2,[]],depth(8))
              -->(40,'&self',[interleave,[],[]],depth(5))
          -->(41,'&self',['Cons',2,[]],depth(3))
<span class="ansi33">  (Cons 2 ())

</span>              <--(40,retval([]))
                <--(38,retval([]))
                <--(36,retval([]))
            <--(32,retval([interleave,[],[]]))
        <--(30,retval(['Cons',2,[]]))
      <--(28,retval(['Cons',[*,1,2],[interleave,[map,[curry,*,1],[]],[prodWith,*,[],['Cons',2,[]]]]]))
<span class="ansi36">
! (assertEqualToResult 
    (prodWith * 
      (Cons 1 ()) 
      (Cons 2 ())) 
    ( (Cons 2 ())))
(@ ! 
  (assertEqual 
    ( (Cons 2 ())) 
    ( (Cons 2 ()))))
write_pass_fail_result("EXPERIMENTS.SYNTHESIZE-VIA-TYPE-CHECKING.109",exec,[prodWith,*,['Cons',1,[]],['Cons',2,[]]],'PASS',[['Cons',2,[]]],[['Cons',2,[]]])

</span>

--------------------------------------------------------------------------
; (Cons 2 Nil)
<span class="ansi38-000068000">!(prodWith * 
  (Cons 1 
    (Cons 2 ())) 
  (Cons 3 
    (Cons 4 ())))

</span>      -->(42,'&self',[prodWith,*,['Cons',1,['Cons',2,[]]],['Cons',3,['Cons',4,[]]]],depth(1))
          -->(43,'&self',['Cons',2,[]],depth(3))
        -->(44,'&self',['Cons',[*,1,3],[interleave,[map,[curry,*,1],['Cons',4,[]]],[prodWith,*,['Cons',2,[]],['Cons',3,['Cons',4,[]]]]]],depth(2))
            -->(45,'&self',[*,1,3],depth(4))
            <--(45,retval(3))
            -->(46,'&self',[interleave,[map,[curry,*,1],['Cons',4,[]]],[prodWith,*,['Cons',2,[]],['Cons',3,['Cons',4,[]]]]],depth(4))
                -->(47,'&self',[curry,*,1],depth(6))
                -->(48,'&self',[curry,*,1],depth(6))
                -->(49,'&self',['Cons',4,[]],depth(6))
                -->(50,'&self',['Cons',2,[]],depth(6))
                -->(51,'&self',['Cons',4,[]],depth(6))
                -->(52,'&self',[map,[curry,*,1],['Cons',4,[]]],depth(6))
                    -->(53,'&self',[curry,*,1],depth(8))
                  -->(54,'&self',['Cons',[[curry,*,1],4],[map,[curry,*,1],[]]],depth(7))
                      -->(55,'&self',[[curry,*,1],4],depth(9))
                        -->(56,'&self',[*,1,4],depth(10))
                        <--(56,retval(4))
                      -->(57,'&self',[map,[curry,*,1],[]],depth(9))
                          -->(58,'&self',[curry,*,1],depth(11))
                    -->(59,'&self',['Cons',4,[]],depth(8))
                -->(60,'&self',[prodWith,*,['Cons',2,[]],['Cons',3,['Cons',4,[]]]],depth(6))
                    -->(61,'&self',['Cons',2,[]],depth(8))
                  -->(62,'&self',['Cons',[*,2,3],[interleave,[map,[curry,*,2],['Cons',4,[]]],[prodWith,*,[],['Cons',3,['Cons',4,[]]]]]],depth(7))
                      -->(63,'&self',[*,2,3],depth(9))
                      <--(63,retval(6))
                      -->(64,'&self',[interleave,[map,[curry,*,2],['Cons',4,[]]],[prodWith,*,[],['Cons',3,['Cons',4,[]]]]],depth(9))
                          -->(65,'&self',[curry,*,2],depth(11))
                          -->(66,'&self',[curry,*,2],depth(11))
                          -->(67,'&self',['Cons',4,[]],depth(11))
                          -->(68,'&self',['Cons',4,[]],depth(11))
                          -->(69,'&self',[map,[curry,*,2],['Cons',4,[]]],depth(11))
                              -->(70,'&self',[curry,*,2],depth(13))
                            -->(71,'&self',['Cons',[[curry,*,2],4],[map,[curry,*,2],[]]],depth(12))
                                -->(72,'&self',[[curry,*,2],4],depth(14))
                                  -->(73,'&self',[*,2,4],depth(15))
                                  <--(73,retval(8))
                                -->(74,'&self',[map,[curry,*,2],[]],depth(14))
                                    -->(75,'&self',[curry,*,2],depth(16))
                              -->(76,'&self',['Cons',8,[]],depth(13))
                          -->(77,'&self',[prodWith,*,[],['Cons',3,['Cons',4,[]]]],depth(11))
                              -->(78,'&self',['Cons',4,[]],depth(13))
                        -->(79,'&self',[interleave,['Cons',8,[]],[]],depth(10))
                            -->(80,'&self',['Cons',8,[]],depth(12))
                          -->(81,'&self',['Cons',8,[interleave,[],[]]],depth(11))
                              -->(82,'&self',[interleave,[],[]],depth(13))
                            -->(83,'&self',['Cons',8,[]],depth(12))
                    -->(84,'&self',['Cons',6,['Cons',8,[]]],depth(8))
                        -->(85,'&self',['Cons',8,[]],depth(10))
              -->(86,'&self',[interleave,['Cons',4,[]],['Cons',6,['Cons',8,[]]]],depth(5))
                  -->(87,'&self',['Cons',4,[]],depth(7))
                -->(88,'&self',['Cons',4,[interleave,['Cons',6,['Cons',8,[]]],[]]],depth(6))
                    -->(89,'&self',[interleave,['Cons',6,['Cons',8,[]]],[]],depth(8))
                        -->(90,'&self',['Cons',8,[]],depth(10))
                      -->(91,'&self',['Cons',6,[interleave,[],['Cons',8,[]]]],depth(9))
                          -->(92,'&self',[interleave,[],['Cons',8,[]]],depth(11))
                              -->(93,'&self',['Cons',8,[]],depth(13))
                            -->(94,'&self',['Cons',8,[]],depth(12))
                        -->(95,'&self',['Cons',6,['Cons',8,[]]],depth(10))
                            -->(96,'&self',['Cons',8,[]],depth(12))
                  -->(97,'&self',['Cons',4,['Cons',6,['Cons',8,[]]]],depth(7))
                      -->(98,'&self',['Cons',6,['Cons',8,[]]],depth(9))
                          -->(99,'&self',['Cons',8,[]],depth(11))
          -->(100,'&self',['Cons',3,['Cons',4,['Cons',6,['Cons',8,[]]]]],depth(3))
Switched off tracing. For a longer trace !(pragma! tracelen 101))<span class="ansi33">
  (Cons 3 
    (Cons 4 
      (Cons 6 
        (Cons 8 ()))))

</span><span class="ansi36">
! (assertEqualToResult 
    (prodWith * 
      (Cons 1 
        (Cons 2 ())) 
      (Cons 3 
        (Cons 4 ()))) 
    ( (Cons 3 
        (Cons 4 
          (Cons 6 
            (Cons 8 ()))))))
(@ ! 
  (assertEqual 
    ( (Cons 3 
        (Cons 4 
          (Cons 6 
            (Cons 8 ()))))) 
    ( (Cons 3 
        (Cons 4 
          (Cons 6 
            (Cons 8 ())))))))
write_pass_fail_result("EXPERIMENTS.SYNTHESIZE-VIA-TYPE-CHECKING.110",exec,[prodWith,*,['Cons',1,['Cons',2,[]]],['Cons',3,['Cons',4,[]]]],'PASS',[['Cons',3,['Cons',4,['Cons',6,['Cons',8,[]]]]]],[['Cons',3,['Cons',4,['Cons',6,['Cons',8,[]]]]]])

</span>

--------------------------------------------------------------------------
; (Cons 3 (Cons 4 (Cons 6 (Cons 8 Nil))))
;; Test synthesize
;; Define collection of functions to compose
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,f,[->,'Number','String']])
</span><span class="ansi38-255165000">  (: f 
    (-> Number String))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[f,X],[if,[==,X,42],"42","Not-42"])
</span><span class="ansi38-255165000">  (= 
    (f $X) 
    (if 
      (== $X 42) "42" "Not-42"))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,g,[->,'String','Bool']])
</span><span class="ansi38-255165000">  (: g 
    (-> String Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[g,X],[==,X,"42"])
</span><span class="ansi38-255165000">  (= 
    (g $X) 
    (== $X "42"))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,h,[->,'Bool','Atom']])
</span><span class="ansi38-255165000">  (: h 
    (-> Bool Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[h,X],[if,X,'TrueAtom','FalseAtom'])
</span><span class="ansi38-255165000">  (= 
    (h $X) 
    (if $X TrueAtom FalseAtom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,functions,[->,'List']])
</span><span class="ansi38-255165000">  (: functions 
    (-> List))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[functions],['Cons',f,['Cons',g,[]]])
</span><span class="ansi38-255165000">  (= 
    (functions) 
    (Cons f 
      (Cons g ())))
</span>

;; Uncomment to try `synthesize` with more functions
;; (= (functions) (Cons f (Cons g (Cons h Nil))))
<span class="ansi38-000068000">!(prodWith . 
  (Cons g ()) 
  (Cons f ()))

</span>      -->(0,'&self',[prodWith,'.',['Cons',g,[]],['Cons',f,[]]],depth(1))
          -->(1,'&self',['Cons',g,[]],depth(3))
        -->(2,'&self',['Cons',['.',g,f],[interleave,[map,[curry,'.',g],[]],[prodWith,'.',[],['Cons',f,[]]]]],depth(2))
            -->(3,'&self',['.',g,f],depth(4))
            -->(4,'&self',[interleave,[map,[curry,'.',g],[]],[prodWith,'.',[],['Cons',f,[]]]],depth(4))
                -->(5,'&self',[curry,'.',g],depth(6))
                -->(6,'&self',[curry,'.',g],depth(6))
                -->(7,'&self',['Cons',f,[]],depth(6))
                -->(8,'&self',[map,[curry,'.',g],[]],depth(6))
                    -->(9,'&self',[curry,'.',g],depth(8))
                -->(10,'&self',[prodWith,'.',[],['Cons',f,[]]],depth(6))
                    -->(11,'&self',['Cons',f,[]],depth(8))
              -->(12,'&self',[interleave,[],[]],depth(5))
          -->(13,'&self',['Cons',['.',g,f],[]],depth(3))
              -->(14,'&self',['.',g,f],depth(5))
<span class="ansi33">  (Cons 
    (. g f) ())

</span>              <--(12,retval([]))
                <--(10,retval([]))
                <--(8,retval([]))
            <--(4,retval([interleave,[],[]]))
        <--(2,retval(['Cons',['.',g,f],[]]))
      <--(0,retval(['Cons',['.',g,f],[interleave,[map,[curry,'.',g],[]],[prodWith,'.',[],['Cons',f,[]]]]]))
<span class="ansi36">
! (assertEqualToResult 
    (prodWith . 
      (Cons g ()) 
      (Cons f ())) 
    ( (Cons 
        (. g f) ())))
(@ ! 
  (assertEqual 
    ( (Cons 
        (. g f) ())) 
    ( (Cons 
        (. g f) ()))))
write_pass_fail_result("EXPERIMENTS.SYNTHESIZE-VIA-TYPE-CHECKING.111",exec,[prodWith,'.',['Cons',g,[]],['Cons',f,[]]],'PASS',[['Cons',['.',g,f],[]]],[['Cons',['.',g,f],[]]])

</span>

--------------------------------------------------------------------------
; (Cons (. g f) Nil)
<span class="ansi38-000068000">!(prodWith . 
  (Cons f ()) 
  (Cons g ()))

</span>      -->(15,'&self',[prodWith,'.',['Cons',f,[]],['Cons',g,[]]],depth(1))
          -->(16,'&self',['Cons',f,[]],depth(3))
        -->(17,'&self',['Cons',['.',f,g],[interleave,[map,[curry,'.',f],[]],[prodWith,'.',[],['Cons',g,[]]]]],depth(2))
            -->(18,'&self',['.',f,g],depth(4))
            -->(19,'&self',[interleave,[map,[curry,'.',f],[]],[prodWith,'.',[],['Cons',g,[]]]],depth(4))
                -->(20,'&self',[curry,'.',f],depth(6))
                -->(21,'&self',[curry,'.',f],depth(6))
                -->(22,'&self',['Cons',g,[]],depth(6))
                -->(23,'&self',[map,[curry,'.',f],[]],depth(6))
                    -->(24,'&self',[curry,'.',f],depth(8))
                -->(25,'&self',[prodWith,'.',[],['Cons',g,[]]],depth(6))
                    -->(26,'&self',['Cons',g,[]],depth(8))
              -->(27,'&self',[interleave,[],[]],depth(5))
          -->(28,'&self',['Cons',['.',f,g],[]],depth(3))
              -->(29,'&self',['.',f,g],depth(5))
<span class="ansi33">  (Cons 
    (. f g) ())

</span>              <--(27,retval([]))
                <--(25,retval([]))
                <--(23,retval([]))
            <--(19,retval([interleave,[],[]]))
        <--(17,retval(['Cons',['.',f,g],[]]))
      <--(15,retval(['Cons',['.',f,g],[interleave,[map,[curry,'.',f],[]],[prodWith,'.',[],['Cons',g,[]]]]]))
<span class="ansi36">
! (assertEqualToResult 
    (prodWith . 
      (Cons f ()) 
      (Cons g ())) 
    ( (Cons 
        (. f g) ())))
(@ ! 
  (assertEqual 
    ( (Cons 
        (. f g) ())) 
    ( (Cons 
        (. f g) ()))))
write_pass_fail_result("EXPERIMENTS.SYNTHESIZE-VIA-TYPE-CHECKING.112",exec,[prodWith,'.',['Cons',f,[]],['Cons',g,[]]],'PASS',[['Cons',['.',f,g],[]]],[['Cons',['.',f,g],[]]])

</span>

--------------------------------------------------------------------------
; (Cons (. f g) Nil)
<span class="ansi38-000068000">!(prodWith . 
  (Cons f 
    (Cons g ())) 
  (Cons f 
    (Cons g ())))

</span>      -->(30,'&self',[prodWith,'.',['Cons',f,['Cons',g,[]]],['Cons',f,['Cons',g,[]]]],depth(1))
          -->(31,'&self',['Cons',g,[]],depth(3))
        -->(32,'&self',['Cons',['.',f,f],[interleave,[map,[curry,'.',f],['Cons',g,[]]],[prodWith,'.',['Cons',g,[]],['Cons',f,['Cons',g,[]]]]]],depth(2))
            -->(33,'&self',['.',f,f],depth(4))
            -->(34,'&self',[interleave,[map,[curry,'.',f],['Cons',g,[]]],[prodWith,'.',['Cons',g,[]],['Cons',f,['Cons',g,[]]]]],depth(4))
                -->(35,'&self',[curry,'.',f],depth(6))
                -->(36,'&self',[curry,'.',f],depth(6))
                -->(37,'&self',['Cons',g,[]],depth(6))
                -->(38,'&self',['Cons',g,[]],depth(6))
                -->(39,'&self',['Cons',g,[]],depth(6))
                -->(40,'&self',[map,[curry,'.',f],['Cons',g,[]]],depth(6))
                    -->(41,'&self',[curry,'.',f],depth(8))
                  -->(42,'&self',['Cons',[[curry,'.',f],g],[map,[curry,'.',f],[]]],depth(7))
                      -->(43,'&self',[[curry,'.',f],g],depth(9))
                        -->(44,'&self',['.',f,g],depth(10))
                      -->(45,'&self',[map,[curry,'.',f],[]],depth(9))
                          -->(46,'&self',[curry,'.',f],depth(11))
                    -->(47,'&self',['Cons',['.',f,g],[]],depth(8))
                        -->(48,'&self',['.',f,g],depth(10))
                -->(49,'&self',[prodWith,'.',['Cons',g,[]],['Cons',f,['Cons',g,[]]]],depth(6))
                    -->(50,'&self',['Cons',g,[]],depth(8))
                  -->(51,'&self',['Cons',['.',g,f],[interleave,[map,[curry,'.',g],['Cons',g,[]]],[prodWith,'.',[],['Cons',f,['Cons',g,[]]]]]],depth(7))
                      -->(52,'&self',['.',g,f],depth(9))
                      -->(53,'&self',[interleave,[map,[curry,'.',g],['Cons',g,[]]],[prodWith,'.',[],['Cons',f,['Cons',g,[]]]]],depth(9))
                          -->(54,'&self',[curry,'.',g],depth(11))
                          -->(55,'&self',[curry,'.',g],depth(11))
                          -->(56,'&self',['Cons',g,[]],depth(11))
                          -->(57,'&self',['Cons',g,[]],depth(11))
                          -->(58,'&self',[map,[curry,'.',g],['Cons',g,[]]],depth(11))
                              -->(59,'&self',[curry,'.',g],depth(13))
                            -->(60,'&self',['Cons',[[curry,'.',g],g],[map,[curry,'.',g],[]]],depth(12))
                                -->(61,'&self',[[curry,'.',g],g],depth(14))
                                  -->(62,'&self',['.',g,g],depth(15))
                                -->(63,'&self',[map,[curry,'.',g],[]],depth(14))
                                    -->(64,'&self',[curry,'.',g],depth(16))
                              -->(65,'&self',['Cons',['.',g,g],[]],depth(13))
                                  -->(66,'&self',['.',g,g],depth(15))
                          -->(67,'&self',[prodWith,'.',[],['Cons',f,['Cons',g,[]]]],depth(11))
                              -->(68,'&self',['Cons',g,[]],depth(13))
                        -->(69,'&self',[interleave,['Cons',['.',g,g],[]],[]],depth(10))
                            -->(70,'&self',['.',g,g],depth(12))
                          -->(71,'&self',['Cons',['.',g,g],[interleave,[],[]]],depth(11))
                              -->(72,'&self',['.',g,g],depth(13))
                              -->(73,'&self',[interleave,[],[]],depth(13))
                            -->(74,'&self',['Cons',['.',g,g],[]],depth(12))
                                -->(75,'&self',['.',g,g],depth(14))
                    -->(76,'&self',['Cons',['.',g,f],['Cons',['.',g,g],[]]],depth(8))
                        -->(77,'&self',['.',g,f],depth(10))
                        -->(78,'&self',['Cons',['.',g,g],[]],depth(10))
                            -->(79,'&self',['.',g,g],depth(12))
              -->(80,'&self',[interleave,['Cons',['.',f,g],[]],['Cons',['.',g,f],['Cons',['.',g,g],[]]]],depth(5))
                  -->(81,'&self',['.',f,g],depth(7))
                -->(82,'&self',['Cons',['.',f,g],[interleave,['Cons',['.',g,f],['Cons',['.',g,g],[]]],[]]],depth(6))
                    -->(83,'&self',['.',f,g],depth(8))
                    -->(84,'&self',[interleave,['Cons',['.',g,f],['Cons',['.',g,g],[]]],[]],depth(8))
                        -->(85,'&self',['.',g,f],depth(10))
                      -->(86,'&self',['Cons',['.',g,f],[interleave,[],['Cons',['.',g,g],[]]]],depth(9))
                          -->(87,'&self',['.',g,f],depth(11))
                          -->(88,'&self',[interleave,[],['Cons',['.',g,g],[]]],depth(11))
                              -->(89,'&self',['.',g,g],depth(13))
                            -->(90,'&self',['Cons',['.',g,g],[]],depth(12))
                                -->(91,'&self',['.',g,g],depth(14))
                        -->(92,'&self',['Cons',['.',g,f],['Cons',['.',g,g],[]]],depth(10))
                            -->(93,'&self',['.',g,f],depth(12))
                            -->(94,'&self',['Cons',['.',g,g],[]],depth(12))
                                -->(95,'&self',['.',g,g],depth(14))
                  -->(96,'&self',['Cons',['.',f,g],['Cons',['.',g,f],['Cons',['.',g,g],[]]]],depth(7))
                      -->(97,'&self',['.',f,g],depth(9))
                      -->(98,'&self',['Cons',['.',g,f],['Cons',['.',g,g],[]]],depth(9))
                          -->(99,'&self',['.',g,f],depth(11))
                          -->(100,'&self',['Cons',['.',g,g],[]],depth(11))
Switched off tracing. For a longer trace !(pragma! tracelen 101))<span class="ansi33">
  (Cons 
    (. f f) 
    (Cons 
      (. f g) 
      (Cons 
        (. g f) 
        (Cons 
          (. g g) ()))))

</span><span class="ansi36">
! (assertEqualToResult 
    (prodWith . 
      (Cons f 
        (Cons g ())) 
      (Cons f 
        (Cons g ()))) 
    ( (Cons 
        (. f f) 
        (Cons 
          (. f g) 
          (Cons 
            (. g f) 
            (Cons 
              (. g g) ()))))))
(@ ! 
  (assertEqual 
    ( (Cons 
        (. f f) 
        (Cons 
          (. f g) 
          (Cons 
            (. g f) 
            (Cons 
              (. g g) ()))))) 
    ( (Cons 
        (. f f) 
        (Cons 
          (. f g) 
          (Cons 
            (. g f) 
            (Cons 
              (. g g) ())))))))
write_pass_fail_result("EXPERIMENTS.SYNTHESIZE-VIA-TYPE-CHECKING.113",exec,[prodWith,'.',['Cons',f,['Cons',g,[]]],['Cons',f,['Cons',g,[]]]],'PASS',[['Cons',['.',f,f],['Cons',['.',f,g],['Cons',['.',g,f],['Cons',['.',g,g],[]]]]]],[['Cons',['.',f,f],['Cons',['.',f,g],['Cons',['.',g,f],['Cons',['.',g,g],[]]]]]])

</span>

--------------------------------------------------------------------------
; (Cons (. f f) (Cons (. f g) (Cons (. g f) (Cons (. g g) Nil))))
<span class="ansi38-000068000">!(synthesize 
  (functions) 
  (fromNumber 2))

</span>      -->(0,'&self',[synthesize,[functions],[fromNumber,2]],depth(1))
          -->(1,'&self',[functions],depth(3))
            -->(2,'&self',['Cons',f,['Cons',g,[]]],depth(4))
                -->(3,'&self',['Cons',g,[]],depth(6))
          -->(4,'&self',[synthesize,['Cons',f,['Cons',g,[]]],[fromNumber,2]],depth(3))
              -->(5,'&self',['Cons',g,[]],depth(5))
              -->(6,'&self',['Cons',g,[]],depth(5))
              -->(7,'&self',[fromNumber,2],depth(5))
                -->(8,'&self',[if,[<=,2,0],'Z',['S',[fromNumber,[-,2,1]]]],depth(6))
                    -->(9,'&self',[<=,2,0],depth(8))
                      -->(10,'&self',[or,[<,2,0],[==,2,0]],depth(9))
                          -->(11,'&self',[<,2,0],depth(11))
                          <--(11,retval('False'))
                          -->(12,'&self',[==,2,0],depth(11))
                          <--(12,retval('False'))
                      <--(10,retval('False'))
                    -->(13,'&self',['S',[fromNumber,[-,2,1]]],depth(8))
                        -->(14,'&self',[fromNumber,[-,2,1]],depth(10))
                            -->(15,'&self',[-,2,1],depth(12))
                            <--(15,retval(1))
                            -->(16,'&self',[fromNumber,1],depth(12))
                              -->(17,'&self',[if,[<=,1,0],'Z',['S',[fromNumber,[-,1,1]]]],depth(13))
                                  -->(18,'&self',[<=,1,0],depth(15))
                                    -->(19,'&self',[or,[<,1,0],[==,1,0]],depth(16))
                                        -->(20,'&self',[<,1,0],depth(18))
                                        <--(20,retval('False'))
                                        -->(21,'&self',[==,1,0],depth(18))
                                        <--(21,retval('False'))
                                    <--(19,retval('False'))
                                  -->(22,'&self',['S',[fromNumber,[-,1,1]]],depth(15))
                                      -->(23,'&self',[fromNumber,[-,1,1]],depth(17))
                                          -->(24,'&self',[-,1,1],depth(19))
                                          <--(24,retval(0))
                                          -->(25,'&self',[fromNumber,0],depth(19))
                                            -->(26,'&self',[if,[<=,0,0],'Z',['S',[fromNumber,[-,0,1]]]],depth(20))
                                                -->(27,'&self',[<=,0,0],depth(22))
                                                  -->(28,'&self',[or,[<,0,0],[==,0,0]],depth(23))
                                                      -->(29,'&self',[<,0,0],depth(25))
                                                      <--(29,retval('False'))
                                                      -->(30,'&self',[==,0,0],depth(25))
                                                      <--(30,retval('True'))
                                                  <--(28,retval('True'))
                                    -->(31,'&self',['S','Z'],depth(16))
                                -->(32,'&self',['S','Z'],depth(14))
                          -->(33,'&self',['S','Z'],depth(11))
                      -->(34,'&self',['S',['S','Z']],depth(9))
                          -->(35,'&self',['S','Z'],depth(11))
                  -->(36,'&self',['S',['S','Z']],depth(7))
                      -->(37,'&self',['S','Z'],depth(9))
            -->(38,'&self',['let*',[[_51612,[synthesize,['Cons',f,['Cons',g,[]]],['S','Z']]],[_51660,[prodWith,'.',['Cons',f,['Cons',g,[]]],_51612]],[_51702,[filter,'well-typed',_51660]]],['trace!',[info,[variables,[prgs,_51612],[cmbs,_51660]],['synthesize=',['Cons',f,['Cons',g,[]]],['S',['S','Z']],_51702]],_51702]],depth(4))
                -->(39,'&self',[synthesize,['Cons',f,['Cons',g,[]]],['S','Z']],depth(6))
                    -->(40,'&self',['Cons',g,[]],depth(8))
                  -->(41,'&self',['trace!',['synthesize=',['Cons',f,['Cons',g,[]]],['S','Z'],['Cons',f,['Cons',g,[]]]],['Cons',f,['Cons',g,[]]]],depth(7))
                      -->(42,'&self',['Cons',g,[]],depth(9))
                      -->(43,'&self',['synthesize=',['Cons',f,['Cons',g,[]]],['S','Z'],['Cons',f,['Cons',g,[]]]],depth(9))
                          -->(44,'&self',['Cons',g,[]],depth(11))
                          -->(45,'&self',['Cons',f,['Cons',g,[]]],depth(11))
                              -->(46,'&self',['Cons',g,[]],depth(13))
                          -->(47,'&self',['S','Z'],depth(11))
                          -->(48,'&self',['Cons',f,['Cons',g,[]]],depth(11))
                              -->(49,'&self',['Cons',g,[]],depth(13))
                          -->(50,'&self',['Cons',f,['Cons',g,[]]],depth(11))
                              -->(51,'&self',['Cons',g,[]],depth(13))
                          -->(52,'&self',['S','Z'],depth(11))
                          -->(53,'&self',['Cons',f,['Cons',g,[]]],depth(11))
                              -->(54,'&self',['Cons',g,[]],depth(13))
                      -->(55,'&self',['Cons',f,['Cons',g,[]]],depth(9))
                          -->(56,'&self',['Cons',g,[]],depth(11))
                      -->(57,'&self',['synthesize=',['Cons',f,['Cons',g,[]]],['S','Z'],['Cons',f,['Cons',g,[]]]],depth(9))
                          -->(58,'&self',['Cons',g,[]],depth(11))
                          -->(59,'&self',['Cons',f,['Cons',g,[]]],depth(11))
                              -->(60,'&self',['Cons',g,[]],depth(13))
                          -->(61,'&self',['S','Z'],depth(11))
                          -->(62,'&self',['Cons',f,['Cons',g,[]]],depth(11))
                              -->(63,'&self',['Cons',g,[]],depth(13))
                          -->(64,'&self',['Cons',f,['Cons',g,[]]],depth(11))
                              -->(65,'&self',['Cons',g,[]],depth(13))
                          -->(66,'&self',['S','Z'],depth(11))
                          -->(67,'&self',['Cons',f,['Cons',g,[]]],depth(11))
                              -->(68,'&self',['Cons',g,[]],depth(13))
                      -->(69,'&self',['Cons',f,['Cons',g,[]]],depth(9))
                          -->(70,'&self',['Cons',g,[]],depth(11))
                -->(71,'&self',['let*',[[_51660,[prodWith,'.',['Cons',f,['Cons',g,[]]],['trace!',['synthesize=',['Cons',f,['Cons',g,[]]],['S','Z'],['Cons',f,['Cons',g,[]]]],['Cons',f,['Cons',g,[]]]]]],[_51702,[filter,'well-typed',_51660]]],['trace!',[info,[variables,[prgs,['trace!',['synthesize=',['Cons',f,['Cons',g,[]]],['S','Z'],['Cons',f,['Cons',g,[]]]],['Cons',f,['Cons',g,[]]]]],[cmbs,_51660]],['synthesize=',['Cons',f,['Cons',g,[]]],['S',['S','Z']],_51702]],_51702]],depth(6))
                    -->(72,'&self',[prodWith,'.',['Cons',f,['Cons',g,[]]],['trace!',['synthesize=',['Cons',f,['Cons',g,[]]],['S','Z'],['Cons',f,['Cons',g,[]]]],['Cons',f,['Cons',g,[]]]]],depth(8))
                        -->(73,'&self',['Cons',g,[]],depth(10))
                        -->(74,'&self',['Cons',g,[]],depth(10))
                        -->(75,'&self',['Cons',g,[]],depth(10))
                        -->(76,'&self',['S','Z'],depth(10))
                        -->(77,'&self',['Cons',g,[]],depth(10))
                        -->(78,'&self',['Cons',g,[]],depth(10))
                        -->(79,'&self',['Cons',f,['Cons',g,[]]],depth(10))
                            -->(80,'&self',['Cons',g,[]],depth(12))
                        -->(81,'&self',['trace!',['synthesize=',['Cons',f,['Cons',g,[]]],['S','Z'],['Cons',f,['Cons',g,[]]]],['Cons',f,['Cons',g,[]]]],depth(10))
                            -->(82,'&self',['Cons',g,[]],depth(12))
                            -->(83,'&self',['synthesize=',['Cons',f,['Cons',g,[]]],['S','Z'],['Cons',f,['Cons',g,[]]]],depth(12))
                                -->(84,'&self',['Cons',g,[]],depth(14))
                                -->(85,'&self',['Cons',f,['Cons',g,[]]],depth(14))
                                    -->(86,'&self',['Cons',g,[]],depth(16))
                                -->(87,'&self',['S','Z'],depth(14))
                                -->(88,'&self',['Cons',f,['Cons',g,[]]],depth(14))
                                    -->(89,'&self',['Cons',g,[]],depth(16))
                                -->(90,'&self',['Cons',f,['Cons',g,[]]],depth(14))
                                    -->(91,'&self',['Cons',g,[]],depth(16))
                                -->(92,'&self',['S','Z'],depth(14))
                                -->(93,'&self',['Cons',f,['Cons',g,[]]],depth(14))
                                    -->(94,'&self',['Cons',g,[]],depth(16))
                            -->(95,'&self',['Cons',f,['Cons',g,[]]],depth(12))
                                -->(96,'&self',['Cons',g,[]],depth(14))
                            -->(97,'&self',['synthesize=',['Cons',f,['Cons',g,[]]],['S','Z'],['Cons',f,['Cons',g,[]]]],depth(12))
                                -->(98,'&self',['Cons',g,[]],depth(14))
                                -->(99,'&self',['Cons',f,['Cons',g,[]]],depth(14))
                                    -->(100,'&self',['Cons',g,[]],depth(16))
Switched off tracing. For a longer trace !(pragma! tracelen 101))<span class="ansi33">
  (trace! 
    (info 
      (variables 
        (prgs 
          (trace! 
            (synthesize= 
              (Cons f 
                (Cons g ())) 
              (S Z) 
              (Cons f 
                (Cons g ()))) 
            (Cons f 
              (Cons g ())))) 
        (cmbs 
          (prodWith . 
            (Cons f 
              (Cons g ())) 
            (trace! 
              (synthesize= 
                (Cons f 
                  (Cons g ())) 
                (S Z) 
                (Cons f 
                  (Cons g ()))) 
              (Cons f 
                (Cons g ())))))) 
      (synthesize= 
        (Cons f 
          (Cons g ())) 
        (S 
          (S Z)) 
        (filter well-typed 
          (prodWith . 
            (Cons f 
              (Cons g ())) 
            (trace! 
              (synthesize= 
                (Cons f 
                  (Cons g ())) 
                (S Z) 
                (Cons f 
                  (Cons g ()))) 
              (Cons f 
                (Cons g ()))))))) 
    (filter well-typed 
      (prodWith . 
        (Cons f 
          (Cons g ())) 
        (trace! 
          (synthesize= 
            (Cons f 
              (Cons g ())) 
            (S Z) 
            (Cons f 
              (Cons g ()))) 
          (Cons f 
            (Cons g ()))))))

</span><span class="ansi33">  (trace! 
    (info 
      (variables 
        (prgs 
          (trace! 
            (synthesize= 
              (Cons f 
                (Cons g ())) 
              (S Z) 
              (Cons f 
                (Cons g ()))) 
            (Cons f 
              (Cons g ())))) 
        (cmbs 
          (prodWith . 
            (Cons f 
              (Cons g ())) 
            (trace! 
              (synthesize= 
                (Cons f 
                  (Cons g ())) 
                (S Z) 
                (Cons f 
                  (Cons g ()))) 
              (Cons f 
                (Cons g ())))))) 
      (synthesize= 
        (Cons f 
          (Cons g ())) 
        (S 
          (S Z)) 
        (filter well-typed 
          (prodWith . 
            (Cons f 
              (Cons g ())) 
            (trace! 
              (synthesize= 
                (Cons f 
                  (Cons g ())) 
                (S Z) 
                (Cons f 
                  (Cons g ()))) 
              (Cons f 
                (Cons g ()))))))) 
    (filter well-typed 
      (prodWith . 
        (Cons f 
          (Cons g ())) 
        (trace! 
          (synthesize= 
            (Cons f 
              (Cons g ())) 
            (S Z) 
            (Cons f 
              (Cons g ()))) 
          (Cons f 
            (Cons g ()))))))

</span><span class="ansi33">  (trace! 
    (info 
      (variables 
        (prgs 
          (trace! 
            (synthesize= 
              (Cons f 
                (Cons g ())) 
              (S Z) 
              (Cons f 
                (Cons g ()))) 
            (Cons f 
              (Cons g ())))) 
        (cmbs 
          (prodWith . 
            (Cons f 
              (Cons g ())) 
            (trace! 
              (synthesize= 
                (Cons f 
                  (Cons g ())) 
                (S Z) 
                (Cons f 
                  (Cons g ()))) 
              (Cons f 
                (Cons g ())))))) 
      (synthesize= 
        (Cons f 
          (Cons g ())) 
        (S 
          (S Z)) 
        (filter well-typed 
          (prodWith . 
            (Cons f 
              (Cons g ())) 
            (trace! 
              (synthesize= 
                (Cons f 
                  (Cons g ())) 
                (S Z) 
                (Cons f 
                  (Cons g ()))) 
              (Cons f 
                (Cons g ()))))))) 
    (filter well-typed 
      (prodWith . 
        (Cons f 
          (Cons g ())) 
        (trace! 
          (synthesize= 
            (Cons f 
              (Cons g ())) 
            (S Z) 
            (Cons f 
              (Cons g ()))) 
          (Cons f 
            (Cons g ()))))))

</span><span class="ansi33">  (trace! 
    (info 
      (variables 
        (prgs 
          (trace! 
            (synthesize= 
              (Cons f 
                (Cons g ())) 
              (S Z) 
              (Cons f 
                (Cons g ()))) 
            (Cons f 
              (Cons g ())))) 
        (cmbs 
          (prodWith . 
            (Cons f 
              (Cons g ())) 
            (trace! 
              (synthesize= 
                (Cons f 
                  (Cons g ())) 
                (S Z) 
                (Cons f 
                  (Cons g ()))) 
              (Cons f 
                (Cons g ())))))) 
      (synthesize= 
        (Cons f 
          (Cons g ())) 
        (S 
          (S Z)) 
        (filter well-typed 
          (prodWith . 
            (Cons f 
              (Cons g ())) 
            (trace! 
              (synthesize= 
                (Cons f 
                  (Cons g ())) 
                (S Z) 
                (Cons f 
                  (Cons g ()))) 
              (Cons f 
                (Cons g ()))))))) 
    (filter well-typed 
      (prodWith . 
        (Cons f 
          (Cons g ())) 
        (trace! 
          (synthesize= 
            (Cons f 
              (Cons g ())) 
            (S Z) 
            (Cons f 
              (Cons g ()))) 
          (Cons f 
            (Cons g ()))))))

</span><span class="ansi31">
! (assertEqualToResult 
    (synthesize 
      (functions) 
      (fromNumber 2)) 
    ( (Cons 
        (. f f) 
        (Cons 
          (. f g) 
          (Cons 
            (. g f) 
            (Cons 
              (. g g) ()))))))
(@ ! 
  (assertEqual 
    ( (trace! 
        (info 
          (variables 
            (prgs 
              (trace! 
                (synthesize= 
                  (Cons f 
                    (Cons g ())) 
                  (S Z) 
                  (Cons f 
                    (Cons g ()))) 
                (Cons f 
                  (Cons g ())))) 
            (cmbs 
              (prodWith . 
                (Cons f 
                  (Cons g ())) 
                (trace! 
                  (synthesize= 
                    (Cons f 
                      (Cons g ())) 
                    (S Z) 
                    (Cons f 
                      (Cons g ()))) 
                  (Cons f 
                    (Cons g ())))))) 
          (synthesize= 
            (Cons f 
              (Cons g ())) 
            (S 
              (S Z)) 
            (filter well-typed 
              (prodWith . 
                (Cons f 
                  (Cons g ())) 
                (trace! 
                  (synthesize= 
                    (Cons f 
                      (Cons g ())) 
                    (S Z) 
                    (Cons f 
                      (Cons g ()))) 
                  (Cons f 
                    (Cons g ()))))))) 
        (filter well-typed 
          (prodWith . 
            (Cons f 
              (Cons g ())) 
            (trace! 
              (synthesize= 
                (Cons f 
                  (Cons g ())) 
                (S Z) 
                (Cons f 
                  (Cons g ()))) 
              (Cons f 
                (Cons g ())))))) 
      (trace! 
        (info 
          (variables 
            (prgs 
              (trace! 
                (synthesize= 
                  (Cons f 
                    (Cons g ())) 
                  (S Z) 
                  (Cons f 
                    (Cons g ()))) 
                (Cons f 
                  (Cons g ())))) 
            (cmbs 
              (prodWith . 
                (Cons f 
                  (Cons g ())) 
                (trace! 
                  (synthesize= 
                    (Cons f 
                      (Cons g ())) 
                    (S Z) 
                    (Cons f 
                      (Cons g ()))) 
                  (Cons f 
                    (Cons g ())))))) 
          (synthesize= 
            (Cons f 
              (Cons g ())) 
            (S 
              (S Z)) 
            (filter well-typed 
              (prodWith . 
                (Cons f 
                  (Cons g ())) 
                (trace! 
                  (synthesize= 
                    (Cons f 
                      (Cons g ())) 
                    (S Z) 
                    (Cons f 
                      (Cons g ()))) 
                  (Cons f 
                    (Cons g ()))))))) 
        (filter well-typed 
          (prodWith . 
            (Cons f 
              (Cons g ())) 
            (trace! 
              (synthesize= 
                (Cons f 
                  (Cons g ())) 
                (S Z) 
                (Cons f 
                  (Cons g ()))) 
              (Cons f 
                (Cons g ())))))) 
      (trace! 
        (info 
          (variables 
            (prgs 
              (trace! 
                (synthesize= 
                  (Cons f 
                    (Cons g ())) 
                  (S Z) 
                  (Cons f 
                    (Cons g ()))) 
                (Cons f 
                  (Cons g ())))) 
            (cmbs 
              (prodWith . 
                (Cons f 
                  (Cons g ())) 
                (trace! 
                  (synthesize= 
                    (Cons f 
                      (Cons g ())) 
                    (S Z) 
                    (Cons f 
                      (Cons g ()))) 
                  (Cons f 
                    (Cons g ())))))) 
          (synthesize= 
            (Cons f 
              (Cons g ())) 
            (S 
              (S Z)) 
            (filter well-typed 
              (prodWith . 
                (Cons f 
                  (Cons g ())) 
                (trace! 
                  (synthesize= 
                    (Cons f 
                      (Cons g ())) 
                    (S Z) 
                    (Cons f 
                      (Cons g ()))) 
                  (Cons f 
                    (Cons g ()))))))) 
        (filter well-typed 
          (prodWith . 
            (Cons f 
              (Cons g ())) 
            (trace! 
              (synthesize= 
                (Cons f 
                  (Cons g ())) 
                (S Z) 
                (Cons f 
                  (Cons g ()))) 
              (Cons f 
                (Cons g ())))))) 
      (trace! 
        (info 
          (variables 
            (prgs 
              (trace! 
                (synthesize= 
                  (Cons f 
                    (Cons g ())) 
                  (S Z) 
                  (Cons f 
                    (Cons g ()))) 
                (Cons f 
                  (Cons g ())))) 
            (cmbs 
              (prodWith . 
                (Cons f 
                  (Cons g ())) 
                (trace! 
                  (synthesize= 
                    (Cons f 
                      (Cons g ())) 
                    (S Z) 
                    (Cons f 
                      (Cons g ()))) 
                  (Cons f 
                    (Cons g ())))))) 
          (synthesize= 
            (Cons f 
              (Cons g ())) 
            (S 
              (S Z)) 
            (filter well-typed 
              (prodWith . 
                (Cons f 
                  (Cons g ())) 
                (trace! 
                  (synthesize= 
                    (Cons f 
                      (Cons g ())) 
                    (S Z) 
                    (Cons f 
                      (Cons g ()))) 
                  (Cons f 
                    (Cons g ()))))))) 
        (filter well-typed 
          (prodWith . 
            (Cons f 
              (Cons g ())) 
            (trace! 
              (synthesize= 
                (Cons f 
                  (Cons g ())) 
                (S Z) 
                (Cons f 
                  (Cons g ()))) 
              (Cons f 
                (Cons g ()))))))) 
    ( (Cons 
        (. f f) 
        (Cons 
          (. f g) 
          (Cons 
            (. g f) 
            (Cons 
              (. g g) ())))))))
write_pass_fail_result("EXPERIMENTS.SYNTHESIZE-VIA-TYPE-CHECKING.114",exec,[synthesize,[functions],[fromNumber,2]],'FAIL',[['Cons',['.',f,f],['Cons',['.',f,g],['Cons',['.',g,f],['Cons',['.',g,g],[]]]]]],[['trace!',[info,[variables,[prgs,['trace!',['synthesize=',['Cons',f,['Cons',g,[]]],['S','Z'],['Cons',f,['Cons',g,[]]]],['Cons',f,['Cons',g,[]]]]],[cmbs,[prodWith,'.',['Cons',f,['Cons',g,[]]],['trace!',['synthesize=',['Cons',f,['Cons',g,[]]],['S','Z'],['Cons',f,['Cons',g,[]]]],['Cons',f,['Cons',g,[]]]]]]],['synthesize=',['Cons',f,['Cons',g,[]]],['S',['S','Z']],[filter,'well-typed',[prodWith,'.',['Cons',f,['Cons',g,[]]],['trace!',['synthesize=',['Cons',f,['Cons',g,[]]],['S','Z'],['Cons',f,['Cons',g,[]]]],['Cons',f,['Cons',g,[]]]]]]]],[filter,'well-typed',[prodWith,'.',['Cons',f,['Cons',g,[]]],['trace!',['synthesize=',['Cons',f,['Cons',g,[]]],['S','Z'],['Cons',f,['Cons',g,[]]]],['Cons',f,['Cons',g,[]]]]]]],['trace!',[info,[variables,[prgs,['trace!',['synthesize=',['Cons',f,['Cons',g,[]]],['S','Z'],['Cons',f,['Cons',g,[]]]],['Cons',f,['Cons',g,[]]]]],[cmbs,[prodWith,'.',['Cons',f,['Cons',g,[]]],['trace!',['synthesize=',['Cons',f,['Cons',g,[]]],['S','Z'],['Cons',f,['Cons',g,[]]]],['Cons',f,['Cons',g,[]]]]]]],['synthesize=',['Cons',f,['Cons',g,[]]],['S',['S','Z']],[filter,'well-typed',[prodWith,'.',['Cons',f,['Cons',g,[]]],['trace!',['synthesize=',['Cons',f,['Cons',g,[]]],['S','Z'],['Cons',f,['Cons',g,[]]]],['Cons',f,['Cons',g,[]]]]]]]],[filter,'well-typed',[prodWith,'.',['Cons',f,['Cons',g,[]]],['trace!',['synthesize=',['Cons',f,['Cons',g,[]]],['S','Z'],['Cons',f,['Cons',g,[]]]],['Cons',f,['Cons',g,[]]]]]]],['trace!',[info,[variables,[prgs,['trace!',['synthesize=',['Cons',f,['Cons',g,[]]],['S','Z'],['Cons',f,['Cons',g,[]]]],['Cons',f,['Cons',g,[]]]]],[cmbs,[prodWith,'.',['Cons',f,['Cons',g,[]]],['trace!',['synthesize=',['Cons',f,['Cons',g,[]]],['S','Z'],['Cons',f,['Cons',g,[]]]],['Cons',f,['Cons',g,[]]]]]]],['synthesize=',['Cons',f,['Cons',g,[]]],['S',['S','Z']],[filter,'well-typed',[prodWith,'.',['Cons',f,['Cons',g,[]]],['trace!',['synthesize=',['Cons',f,['Cons',g,[]]],['S','Z'],['Cons',f,['Cons',g,[]]]],['Cons',f,['Cons',g,[]]]]]]]],[filter,'well-typed',[prodWith,'.',['Cons',f,['Cons',g,[]]],['trace!',['synthesize=',['Cons',f,['Cons',g,[]]],['S','Z'],['Cons',f,['Cons',g,[]]]],['Cons',f,['Cons',g,[]]]]]]],['trace!',[info,[variables,[prgs,['trace!',['synthesize=',['Cons',f,['Cons',g,[]]],['S','Z'],['Cons',f,['Cons',g,[]]]],['Cons',f,['Cons',g,[]]]]],[cmbs,[prodWith,'.',['Cons',f,['Cons',g,[]]],['trace!',['synthesize=',['Cons',f,['Cons',g,[]]],['S','Z'],['Cons',f,['Cons',g,[]]]],['Cons',f,['Cons',g,[]]]]]]],['synthesize=',['Cons',f,['Cons',g,[]]],['S',['S','Z']],[filter,'well-typed',[prodWith,'.',['Cons',f,['Cons',g,[]]],['trace!',['synthesize=',['Cons',f,['Cons',g,[]]],['S','Z'],['Cons',f,['Cons',g,[]]]],['Cons',f,['Cons',g,[]]]]]]]],[filter,'well-typed',[prodWith,'.',['Cons',f,['Cons',g,[]]],['trace!',['synthesize=',['Cons',f,['Cons',g,[]]],['S','Z'],['Cons',f,['Cons',g,[]]]],['Cons',f,['Cons',g,[]]]]]]]])

</span>

--------------------------------------------------------------------------
<span class="ansi32">% 15,221,611 inferences, 3.815 CPU in 3.816 seconds (100% CPU, 3989919 Lips)
</span> (@ = "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/synthesis/experiments/synthesize-via-type-checking.metta" 0)
<span class="ansi1">LoonIt Report
</span>------------
<span class="ansi32">Successes: 12
</span><span class="ansi31">Failures: 1
</span>doing(ansi2html -u < "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/TEE.ansi" > "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/synthesis/experiments/synthesize-via-type-checking.html" )

</pre>
</body>

</html>
