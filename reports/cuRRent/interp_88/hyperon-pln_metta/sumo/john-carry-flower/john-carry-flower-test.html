<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>
<style type="text/css">
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content">
 (@ track_load_into_file "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/sumo/john-carry-flower/john-carry-flower-test.metta")
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/sumo/john-carry-flower/john-carry-flower-test.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/sumo/john-carry-flower/john-carry-flower-test.metta')
1=[()]
2=[()]
3=[()]
4=[()]
5=[(), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), ()]
6=[(: (ModusPonens (WitnessOf (⟹ (∧ (subclass Carrying Transfer) (instance JohnsCarry Carrying)) (instance JohnsCarry Transfer))) (BinaryConjunctionIntroduction (WitnessOf (subclass Carrying Transfer)) (WitnessOf (instance JohnsCarry Carrying)))) (instance JohnsCarry Transfer))]
7=[(let* (((: $proof1#5582 (⟹ $x#5505 (∧ (instance JohnsCarry Transfer) (objectTransferred JohnsCarry JohnsVase) (orientation JohnsFlower JohnsVase Inside)))) (synthesize (: $proof1#5582 (⟹ $x#5505 (∧ (instance JohnsCarry Transfer) (objectTransferred JohnsCarry JohnsVase) (orientation JohnsFlower JohnsVase Inside)))) kb rb (S (S Z)))) ((: $proof2#5583 $x#5505) (synthesize (: $proof2#5583 $x#5505) kb rb (S (S Z))))) (: (ModusPonens $proof1#5582 $proof2#5583) (∧ (instance JohnsCarry Transfer) (objectTransferred JohnsCarry JohnsVase) (orientation JohnsFlower JohnsVase Inside)))), (: (TrinaryConjunctionIntroduction (ModusPonens (WitnessOf (⟹ (∧ (subclass Carrying Transfer) (instance JohnsCarry Carrying)) (instance JohnsCarry Transfer))) (BinaryConjunctionIntroduction (WitnessOf (subclass Carrying Transfer)) (WitnessOf (instance JohnsCarry Carrying)))) (WitnessOf (objectTransferred JohnsCarry JohnsVase)) (WitnessOf (orientation JohnsFlower JohnsVase Inside))) (∧ (instance JohnsCarry Transfer) (objectTransferred JohnsCarry JohnsVase) (orientation JohnsFlower JohnsVase Inside)))]
8=[(: (ModusPonens (WitnessOf (⟹ (∧ (instance JohnsCarry Transfer) (objectTransferred JohnsCarry JohnsVase) (orientation JohnsFlower JohnsVase Inside)) (objectTransferred JohnsCarry JohnsFlower))) (TrinaryConjunctionIntroduction (ModusPonens (WitnessOf (⟹ (∧ (subclass Carrying Transfer) (instance JohnsCarry Carrying)) (instance JohnsCarry Transfer))) (BinaryConjunctionIntroduction (WitnessOf (subclass Carrying Transfer)) (WitnessOf (instance JohnsCarry Carrying)))) (WitnessOf (objectTransferred JohnsCarry JohnsVase)) (WitnessOf (orientation JohnsFlower JohnsVase Inside)))) (objectTransferred JohnsCarry JohnsFlower))]
9=[(let* (((: $proof1#36413 (⟹ $x#36327 (∧ (instance $C Carrying) (agent $C John) (instance $F Flower) (objectTransferred $C $F)))) (synthesize (: $proof1#36413 (⟹ $x#36327 (∧ (instance $C Carrying) (agent $C John) (instance $F Flower) (objectTransferred $C $F)))) kb rb (S (S (S (S Z)))))) ((: $proof2#36414 $x#36327) (synthesize (: $proof2#36414 $x#36327) kb rb (S (S (S (S Z))))))) (: (ModusPonens $proof1#36413 $proof2#36414) (∧ (instance $C Carrying) (agent $C John) (instance $F Flower) (objectTransferred $C $F)))), (: (QuaternaryConjunctionIntroduction (WitnessOf (instance JohnsCarry Carrying)) (WitnessOf (agent JohnsCarry John)) (WitnessOf (instance JohnsFlower Flower)) (ModusPonens (WitnessOf (⟹ (∧ (instance JohnsCarry Transfer) (objectTransferred JohnsCarry JohnsVase) (orientation JohnsFlower JohnsVase Inside)) (objectTransferred JohnsCarry JohnsFlower))) (TrinaryConjunctionIntroduction (ModusPonens (WitnessOf (⟹ (∧ (subclass Carrying Transfer) (instance JohnsCarry Carrying)) (instance JohnsCarry Transfer))) (BinaryConjunctionIntroduction (WitnessOf (subclass Carrying Transfer)) (WitnessOf (instance JohnsCarry Carrying)))) (WitnessOf (objectTransferred JohnsCarry JohnsVase)) (WitnessOf (orientation JohnsFlower JohnsVase Inside))))) (∧ (instance JohnsCarry Carrying) (agent JohnsCarry John) (instance JohnsFlower Flower) (objectTransferred JohnsCarry JohnsFlower)))]
:- dynamic file_answers/3.

file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/sumo/john-carry-flower/john-carry-flower-test.metta', 1, [[]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/sumo/john-carry-flower/john-carry-flower-test.metta', 2, [[]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/sumo/john-carry-flower/john-carry-flower-test.metta', 3, [[]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/sumo/john-carry-flower/john-carry-flower-test.metta', 4, [[]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/sumo/john-carry-flower/john-carry-flower-test.metta', 5, [[], ',', [], ',', [], ',', [], ',', [], ',', [], ',', [], ',', [], ',', [], ',', [], ',', [], ',', [], ',', [], ',', [], ',', [], ',', [], ',', [], ',', [], ',', [], ',', [], ',', [], ',', [], ',', []]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/sumo/john-carry-flower/john-carry-flower-test.metta', 6, [[:, ['ModusPonens', ['WitnessOf', [⟹, [∧, [subclass, 'Carrying', 'Transfer'], [instance, 'JohnsCarry', 'Carrying']], [instance, 'JohnsCarry', 'Transfer']]], ['BinaryConjunctionIntroduction', ['WitnessOf', [subclass, 'Carrying', 'Transfer']], ['WitnessOf', [instance, 'JohnsCarry', 'Carrying']]]], [instance, 'JohnsCarry', 'Transfer']]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/sumo/john-carry-flower/john-carry-flower-test.metta', 7, [['let*', [[[:, Proof1_C35_5582, [⟹, X_C35_5505, [∧, [instance, 'JohnsCarry', 'Transfer'], [objectTransferred, 'JohnsCarry', 'JohnsVase'], [orientation, 'JohnsFlower', 'JohnsVase', 'Inside']]]], [synthesize, [:, Proof1_C35_5582, [⟹, X_C35_5505, [∧, [instance, 'JohnsCarry', 'Transfer'], [objectTransferred, 'JohnsCarry', 'JohnsVase'], [orientation, 'JohnsFlower', 'JohnsVase', 'Inside']]]], kb, rb, ['S', ['S', 'Z']]]], [[:, Proof2_C35_5583, X_C35_5505], [synthesize, [:, Proof2_C35_5583, X_C35_5505], kb, rb, ['S', ['S', 'Z']]]]], [:, ['ModusPonens', Proof1_C35_5582, Proof2_C35_5583], [∧, [instance, 'JohnsCarry', 'Transfer'], [objectTransferred, 'JohnsCarry', 'JohnsVase'], [orientation, 'JohnsFlower', 'JohnsVase', 'Inside']]]], ',', [:, ['TrinaryConjunctionIntroduction', ['ModusPonens', ['WitnessOf', [⟹, [∧, [subclass, 'Carrying', 'Transfer'], [instance, 'JohnsCarry', 'Carrying']], [instance, 'JohnsCarry', 'Transfer']]], ['BinaryConjunctionIntroduction', ['WitnessOf', [subclass, 'Carrying', 'Transfer']], ['WitnessOf', [instance, 'JohnsCarry', 'Carrying']]]], ['WitnessOf', [objectTransferred, 'JohnsCarry', 'JohnsVase']], ['WitnessOf', [orientation, 'JohnsFlower', 'JohnsVase', 'Inside']]], [∧, [instance, 'JohnsCarry', 'Transfer'], [objectTransferred, 'JohnsCarry', 'JohnsVase'], [orientation, 'JohnsFlower', 'JohnsVase', 'Inside']]]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/sumo/john-carry-flower/john-carry-flower-test.metta', 8, [[:, ['ModusPonens', ['WitnessOf', [⟹, [∧, [instance, 'JohnsCarry', 'Transfer'], [objectTransferred, 'JohnsCarry', 'JohnsVase'], [orientation, 'JohnsFlower', 'JohnsVase', 'Inside']], [objectTransferred, 'JohnsCarry', 'JohnsFlower']]], ['TrinaryConjunctionIntroduction', ['ModusPonens', ['WitnessOf', [⟹, [∧, [subclass, 'Carrying', 'Transfer'], [instance, 'JohnsCarry', 'Carrying']], [instance, 'JohnsCarry', 'Transfer']]], ['BinaryConjunctionIntroduction', ['WitnessOf', [subclass, 'Carrying', 'Transfer']], ['WitnessOf', [instance, 'JohnsCarry', 'Carrying']]]], ['WitnessOf', [objectTransferred, 'JohnsCarry', 'JohnsVase']], ['WitnessOf', [orientation, 'JohnsFlower', 'JohnsVase', 'Inside']]]], [objectTransferred, 'JohnsCarry', 'JohnsFlower']]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/sumo/john-carry-flower/john-carry-flower-test.metta', 9, [['let*', [[[:, Proof1_C35_36413, [⟹, X_C35_36327, [∧, [instance, C, 'Carrying'], [agent, C, 'John'], [instance, False, 'Flower'], [objectTransferred, C, False]]]], [synthesize, [:, Proof1_C35_36413, [⟹, X_C35_36327, [∧, [instance, C, 'Carrying'], [agent, C, 'John'], [instance, False, 'Flower'], [objectTransferred, C, False]]]], kb, rb, ['S', ['S', ['S', ['S', 'Z']]]]]], [[:, Proof2_C35_36414, X_C35_36327], [synthesize, [:, Proof2_C35_36414, X_C35_36327], kb, rb, ['S', ['S', ['S', ['S', 'Z']]]]]]], [:, ['ModusPonens', Proof1_C35_36413, Proof2_C35_36414], [∧, [instance, C, 'Carrying'], [agent, C, 'John'], [instance, False, 'Flower'], [objectTransferred, C, False]]]], ',', [:, ['QuaternaryConjunctionIntroduction', ['WitnessOf', [instance, 'JohnsCarry', 'Carrying']], ['WitnessOf', [agent, 'JohnsCarry', 'John']], ['WitnessOf', [instance, 'JohnsFlower', 'Flower']], ['ModusPonens', ['WitnessOf', [⟹, [∧, [instance, 'JohnsCarry', 'Transfer'], [objectTransferred, 'JohnsCarry', 'JohnsVase'], [orientation, 'JohnsFlower', 'JohnsVase', 'Inside']], [objectTransferred, 'JohnsCarry', 'JohnsFlower']]], ['TrinaryConjunctionIntroduction', ['ModusPonens', ['WitnessOf', [⟹, [∧, [subclass, 'Carrying', 'Transfer'], [instance, 'JohnsCarry', 'Carrying']], [instance, 'JohnsCarry', 'Transfer']]], ['BinaryConjunctionIntroduction', ['WitnessOf', [subclass, 'Carrying', 'Transfer']], ['WitnessOf', [instance, 'JohnsCarry', 'Carrying']]]], ['WitnessOf', [objectTransferred, 'JohnsCarry', 'JohnsVase']], ['WitnessOf', [orientation, 'JohnsFlower', 'JohnsVase', 'Inside']]]]], [∧, [instance, 'JohnsCarry', 'Carrying'], [agent, 'JohnsCarry', 'John'], [instance, 'JohnsFlower', 'Flower'], [objectTransferred, 'JohnsCarry', 'JohnsFlower']]]]).

;;; Test reasoning on the content of orientation.kif.metta.  Before
;;; running that file, make sure `orientation.kif.metta` has been
;;; properly generated.  See `README.md` for more information on how to
;;; do that.
;; Import synthesizer
<span class="ansi38-000068000">!(import! &self "../../synthesis/Synthesize.metta")

</span>      -->(0,'&self',['import!','&self','../../synthesis/Synthesize.metta'],depth(1))
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/sumo/john-carry-flower/john-carry-flower-test.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/sumo/john-carry-flower/john-carry-flower-test.metta')
;; Import knowledge base
;;; Import modules
<span class="ansi38-000068000">!(import! &self "../common/Num.metta")

</span>      -->(1,'&self',['import!','&self','../common/Num.metta'],depth(1))
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/sumo/john-carry-flower/john-carry-flower-test.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/sumo/john-carry-flower/john-carry-flower-test.metta')
;; !(import! &self Unify.metta)
;; Enumerate all programs up to a given depth that are consistent with
;; the query, using the given axiom non-deterministic functions and rules.
;;
;; The arguments are:
;;
;; $query: an Atom under the form (: TERM TYPE).  The atom may contain
;;         free variables within TERM and TYPE to form various sort of
;;         queries, such as:
;;         1. Backward chaining: (: $term (Inheritance $x Mammal))
;;         2. Forward chaining: (: ($rule $premise AXIOM) $type)
;;         3. Mixed chaining: (: ($rule $premise AXIOM) (Inheritance $x Mammal))
;;         4. Type checking: (: TERM TYPE)
;;         5. Type inference: (: TERM $type)
;;
;; $kb: a nullary function to axiom, to non-deterministically pick up
;;      an axiom.  An axiom is an Atom of the form (: TERM TYPE).
;;
;; $rb: a nullary function to rule, to non-deterministically pick up a
;;      rule.  A rule is a function mapping premises to conclusion,
;;      where premises and conclusion have the form (: TERM TYPE).
;;
;; $depth: a Nat representing the maximum depth of the generated
;;         programs.
;;
;; TODO: recurse over curried rules instead of duplicating code over
;; tuples.
;;; Collection of functions operating on numbers
;; Define max
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,max,[->,A,A,A]])
</span><span class="ansi38-255165000">  (: max 
    (-> $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[max,X,Y],[if,[>,X,Y],X,Y])
</span><span class="ansi38-255165000">  (= 
    (max $X $Y) 
    (if 
      (> $X $Y) $X $Y))
</span>

;; Define min
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,min,[->,A,A,A]])
</span><span class="ansi38-255165000">  (: min 
    (-> $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[min,X,Y],[if,[<,X,Y],X,Y])
</span><span class="ansi38-255165000">  (= 
    (min $X $Y) 
    (if 
      (< $X $Y) $X $Y))
</span>

;; Clamp a number to be within a certain range
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,clamp,[->,A,A,A,A]])
</span><span class="ansi38-255165000">  (: clamp 
    (-> $A $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[clamp,X,L,U],[max,L,[min,U,X]])
</span><span class="ansi38-255165000">  (= 
    (clamp $X $L $U) 
    (max $L 
      (min $U $X)))
</span>

;; Define abs
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,abs,[->,A,A]])
</span><span class="ansi38-255165000">  (: abs 
    (-> $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[abs,X],[if,[<,X,0],[*,-1,X],X])
</span><span class="ansi38-255165000">  (= 
    (abs $X) 
    (if 
      (< $X 0) 
      (* -1 $X) $X))
</span>

;; Define <=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,<=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: <= 
    (-> $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[<=,X,Y],[or,[<,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">  (= 
    (<= $X $Y) 
    (or 
      (< $X $Y) 
      (== $X $Y)))
</span>

;; Define >=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,>=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: >= 
    (-> $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[>=,X,Y],[or,[>,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">  (= 
    (>= $X $Y) 
    (or 
      (> $X $Y) 
      (== $X $Y)))
</span>

;; Define approximately equal
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,approxEq,[->,A,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: approxEq 
    (-> $A $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[approxEq,X,Y,Epsilon],[<=,[abs,[-,X,Y]],Epsilon])
</span><span class="ansi38-255165000">  (= 
    (approxEq $X $Y $Epsilon) 
    (<= 
      (abs 
        (- $X $Y)) $Epsilon))
</span>

;; Define Nat
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Nat','Type'])
</span><span class="ansi38-255165000">  (: Nat Type)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Z','Nat'])
</span><span class="ansi38-255165000">  (: Z Nat)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'S',[->,'Nat','Nat']])
</span><span class="ansi38-255165000">  (: S 
    (-> Nat Nat))
</span>

;; Define cast functions between Nat and Number
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNumber,[->,'Number','Nat']])
</span><span class="ansi38-255165000">  (: fromNumber 
    (-> Number Nat))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNumber,N],[if,[<=,N,0],'Z',['S',[fromNumber,[-,N,1]]]])
</span><span class="ansi38-255165000">  (= 
    (fromNumber $N) 
    (if 
      (<= $N 0) Z 
      (S 
        (fromNumber 
          (- $N 1)))))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNat,[->,'Nat','Number']])
</span><span class="ansi38-255165000">  (: fromNat 
    (-> Nat Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,'Z'],0)
</span><span class="ansi38-255165000">  (= 
    (fromNat Z) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,['S',K]],[+,1,[fromNat,K]])
</span><span class="ansi38-255165000">  (= 
    (fromNat 
      (S $K)) 
    (+ 1 
      (fromNat $K)))
</span>

;; Define a generic less than operator, â©», for Nat.  < cannot be used
;; because it is a built-in, its type is hardwired and cannot be
;; overloaded.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Nat','Nat','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Nat Nat Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',_,'Z'],'False')
</span><span class="ansi38-255165000">  (= 
    (â©» $_ Z) False)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»','Z',['S',_]],'True')
</span><span class="ansi38-255165000">  (= 
    (â©» Z 
      (S $_)) True)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',['S',X],['S',Y]],['â©»',X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» 
      (S $X) 
      (S $Y)) 
    (â©» $X $Y))
</span>

;; Overload â©» for Number.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Number','Number','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Number Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',X,Y],[<,X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» $X $Y) 
    (< $X $Y))
</span>

;; Return the ceiling of a non negative number.  If the number is
;; negative it returns 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,ceil,[->,'Number','Number']])
</span><span class="ansi38-255165000">  (: ceil 
    (-> Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[ceil,N],[fromNat,[fromNumber,N]])
</span><span class="ansi38-255165000">  (= 
    (ceil $N) 
    (fromNat 
      (fromNumber $N)))
</span>

;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'number->bool',[->,'Number','Bool']])
</span><span class="ansi38-255165000">  (: number->bool 
    (-> Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['number->bool',X],[<,0,X])
</span><span class="ansi38-255165000">  (= 
    (number->bool $X) 
    (< 0 $X))
</span>

;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'bool->number',[->,'Bool','Number']])
</span><span class="ansi38-255165000">  (: bool->number 
    (-> Bool Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','False'],0)
</span><span class="ansi38-255165000">  (= 
    (bool->number False) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','True'],1)
</span><span class="ansi38-255165000">  (= 
    (bool->number True) 1)
</span>

;; Define a less than type.  Note that it is purposefully different
;; than â©» as it is a type, not an operator.  Inhabitants of (â x y)
;; are proofs that x â©» y == True.  For now â is only axiomatized for
;; Nat.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â\x8D\\x83\',[->,True,True,'Type']])
</span><span class="ansi38-255165000">  (: â 
    (-> $True $True Type))
</span>

;; Zero is always less than the successor of something
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['zero-lt-succ-axiom'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['zero-lt-succ-axiom'],[:,'ZeroLTSucc',['â\x8D\\x83\','Z',['S',K]]])
</span><span class="ansi38-255165000">  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (â Z 
        (S $K))))
</span>

;; If x â y then (S x) â (S y)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['succ-monotonicity-rule'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['succ-monotonicity-rule'],[:,'SuccMonotonicity',[->,['â\x8D\\x83\',X,Y],['â\x8D\\x83\',['S',X],['S',Y]]]])
</span><span class="ansi38-255165000">  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (â $X $Y) 
        (â 
          (S $X) 
          (S $Y)))))
</span>

      <--(1,retval('Empty'))
<span class="ansi33"> Empty

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,synthesize,[->,'Atom',[->,'Atom'],[->,'Atom'],'Nat','Atom']])
</span><span class="ansi38-255165000">  (: synthesize 
    (-> Atom 
      (-> Atom) 
      (-> Atom) Nat Atom))
</span>

;; Nullary rule (axiom)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Kb,Rb,Depth],[let,Query,[Kb],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Kb $Rb $Depth) 
    (let $Query 
      ($Kb) $Query))
</span>

;; Unary rule
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Kb,Rb,['S',K]],['let*',[[[:,Ructor,[->,Premise,Conclusion]],[Rb]],[[:,[Ructor,Proof],Conclusion],Query],[[:,Proof,Premise],[synthesize,[:,Proof,Premise],Kb,Rb,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Kb $Rb 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise $Conclusion)) 
          ($Rb)) 
        ( (: 
            ($Ructor $Proof) $Conclusion) $Query) 
        ( (: $Proof $Premise) 
          (synthesize 
            (: $Proof $Premise) $Kb $Rb $K))) $Query))
</span>

;; Binary rule
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Kb,Rb,['S',K]],['let*',[[[:,Ructor,[->,Premise1,Premise2,Conclusion]],[Rb]],[[:,[Ructor,Proof1,Proof2],Conclusion],Query],[[:,Proof1,Premise1],[synthesize,[:,Proof1,Premise1],Kb,Rb,K]],[[:,Proof2,Premise2],[synthesize,[:,Proof2,Premise2],Kb,Rb,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Kb $Rb 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise1 $Premise2 $Conclusion)) 
          ($Rb)) 
        ( (: 
            ($Ructor $Proof1 $Proof2) $Conclusion) $Query) 
        ( (: $Proof1 $Premise1) 
          (synthesize 
            (: $Proof1 $Premise1) $Kb $Rb $K)) 
        ( (: $Proof2 $Premise2) 
          (synthesize 
            (: $Proof2 $Premise2) $Kb $Rb $K))) $Query))
</span>

;; Trinary rule
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Kb,Rb,['S',K]],['let*',[[[:,Ructor,[->,Premise1,Premise2,Premise3,Conclusion]],[Rb]],[[:,[Ructor,Proof1,Proof2,Proof3],Conclusion],Query],[[:,Proof1,Premise1],[synthesize,[:,Proof1,Premise1],Kb,Rb,K]],[[:,Proof2,Premise2],[synthesize,[:,Proof2,Premise2],Kb,Rb,K]],[[:,Proof3,Premise3],[synthesize,[:,Proof3,Premise3],Kb,Rb,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Kb $Rb 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise1 $Premise2 $Premise3 $Conclusion)) 
          ($Rb)) 
        ( (: 
            ($Ructor $Proof1 $Proof2 $Proof3) $Conclusion) $Query) 
        ( (: $Proof1 $Premise1) 
          (synthesize 
            (: $Proof1 $Premise1) $Kb $Rb $K)) 
        ( (: $Proof2 $Premise2) 
          (synthesize 
            (: $Proof2 $Premise2) $Kb $Rb $K)) 
        ( (: $Proof3 $Premise3) 
          (synthesize 
            (: $Proof3 $Premise3) $Kb $Rb $K))) $Query))
</span>

;; Quaternary rule
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Kb,Rb,['S',K]],['let*',[[[:,Ructor,[->,Premise1,Premise2,Premise3,Premise4,Conclusion]],[Rb]],[[:,[Ructor,Proof1,Proof2,Proof3,Proof4],Conclusion],Query],[[:,Proof1,Premise1],[synthesize,[:,Proof1,Premise1],Kb,Rb,K]],[[:,Proof2,Premise2],[synthesize,[:,Proof2,Premise2],Kb,Rb,K]],[[:,Proof3,Premise3],[synthesize,[:,Proof3,Premise3],Kb,Rb,K]],[[:,Proof4,Premise4],[synthesize,[:,Proof4,Premise4],Kb,Rb,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Kb $Rb 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise1 $Premise2 $Premise3 $Premise4 $Conclusion)) 
          ($Rb)) 
        ( (: 
            ($Ructor $Proof1 $Proof2 $Proof3 $Proof4) $Conclusion) $Query) 
        ( (: $Proof1 $Premise1) 
          (synthesize 
            (: $Proof1 $Premise1) $Kb $Rb $K)) 
        ( (: $Proof2 $Premise2) 
          (synthesize 
            (: $Proof2 $Premise2) $Kb $Rb $K)) 
        ( (: $Proof3 $Premise3) 
          (synthesize 
            (: $Proof3 $Premise3) $Kb $Rb $K)) 
        ( (: $Proof4 $Premise4) 
          (synthesize 
            (: $Proof4 $Premise4) $Kb $Rb $K))) $Query))
</span>

;; Quintenary rule
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Kb,Rb,['S',K]],['let*',[[[:,Ructor,[->,Premise1,Premise2,Premise3,Premise4,Premise5,Conclusion]],[Rb]],[[:,[Ructor,Proof1,Proof2,Proof3,Proof4,Proof5],Conclusion],Query],[[:,Proof1,Premise1],[synthesize,[:,Proof1,Premise1],Kb,Rb,K]],[[:,Proof2,Premise2],[synthesize,[:,Proof2,Premise2],Kb,Rb,K]],[[:,Proof3,Premise3],[synthesize,[:,Proof3,Premise3],Kb,Rb,K]],[[:,Proof4,Premise4],[synthesize,[:,Proof4,Premise4],Kb,Rb,K]],[[:,Proof5,Premise5],[synthesize,[:,Proof5,Premise5],Kb,Rb,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Kb $Rb 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise1 $Premise2 $Premise3 $Premise4 $Premise5 $Conclusion)) 
          ($Rb)) 
        ( (: 
            ($Ructor $Proof1 $Proof2 $Proof3 $Proof4 $Proof5) $Conclusion) $Query) 
        ( (: $Proof1 $Premise1) 
          (synthesize 
            (: $Proof1 $Premise1) $Kb $Rb $K)) 
        ( (: $Proof2 $Premise2) 
          (synthesize 
            (: $Proof2 $Premise2) $Kb $Rb $K)) 
        ( (: $Proof3 $Premise3) 
          (synthesize 
            (: $Proof3 $Premise3) $Kb $Rb $K)) 
        ( (: $Proof4 $Premise4) 
          (synthesize 
            (: $Proof4 $Premise4) $Kb $Rb $K)) 
        ( (: $Proof5 $Premise5) 
          (synthesize 
            (: $Proof5 $Premise5) $Kb $Rb $K))) $Query))
</span>

      <--(0,retval('Empty'))
<span class="ansi33"> Empty

</span><span class="ansi38-000068000">!(import! &kb john-carry-flower.kif.metta)

</span>      -->(2,'&self',['import!','&kb','john-carry-flower.kif.metta'],depth(1))
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/sumo/john-carry-flower/john-carry-flower-test.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/sumo/john-carry-flower/john-carry-flower-test.metta')
;; Import rule base
;;; Auto-generated by suo-kif-to-metta.sh
;; Self-contained SUO-KIF file extracted from
;;
;; https://github.com/ontologyportal/sumo/blob/master/Merge.kif
;;
;; containing knowledge about `objectTransferred`.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',['â\x9F\¹',['â\x88\§',[subclass,X,Y],[instance,Z,X]],[instance,Z,Y]])
</span><span class="ansi38-255165000">  (â¹ 
    (â§ 
      (subclass $X $Y) 
      (instance $Z $X)) 
    (instance $Z $Y))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[instance,objectTransferred,'CaseRole'])
</span><span class="ansi38-255165000">  (instance objectTransferred CaseRole)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[subrelation,objectTransferred,patient])
</span><span class="ansi38-255165000">  (subrelation objectTransferred patient)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[domain,objectTransferred,1,'Transfer'])
</span><span class="ansi38-255165000">  (domain objectTransferred 1 Transfer)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[domain,objectTransferred,2,'Object'])
</span><span class="ansi38-255165000">  (domain objectTransferred 2 Object)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[format,'EnglishLanguage',objectTransferred,"the object transferred in %1 is %n %2"])
</span><span class="ansi38-255165000">  (format EnglishLanguage objectTransferred "the object transferred in %1 is %n %2")
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[documentation,objectTransferred,'EnglishLanguage',"A relation that specifies the object that\nis transferred during the process.  For example, in a &%Mailing process, the object\ntransferred is a letter or package."])
</span><span class="ansi38-255165000">  (documentation objectTransferred EnglishLanguage "A relation that specifies the object that\nis transferred during the process.  For example, in a &%Mailing process, the object\ntransferred is a letter or package.")
</span>

;; (â¹
;;   (objectTransferred $P $OBJ)
;;   (â ($O $D)
;;     (â§
;;       (origin $P $O)
;;       (destination $P $D)
;;       (holdsDuring
;;         (ImmediatePastFn $P)
;;         (located $OBJ $O))
;;       (holdsDuring
;;         (ImmediateFutureFn $P)
;;         (located $OBJ $D)))))
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',['â\x9F\¹',['â\x88\§',[instance,True,'Transfer'],[objectTransferred,True,O],[orientation,O2,O,'Inside']],[objectTransferred,True,O2]])
</span><span class="ansi38-255165000">  (â¹ 
    (â§ 
      (instance $True Transfer) 
      (objectTransferred $True $O) 
      (orientation $O2 $O Inside)) 
    (objectTransferred $True $O2))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',['â\x9F\¹',['â\x88\§',[instance,True,'Transfer'],[objectTransferred,True,O],[orientation,O2,O,'On']],[objectTransferred,True,O2]])
</span><span class="ansi38-255165000">  (â¹ 
    (â§ 
      (instance $True Transfer) 
      (objectTransferred $True $O) 
      (orientation $O2 $O On)) 
    (objectTransferred $True $O2))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[subclass,'Carrying','Transfer'])
</span><span class="ansi38-255165000">  (subclass Carrying Transfer)
</span>

;; Add instances of `objectTransferred`, extracted from
;;
;; https://github.com/ontologyportal/sumo/blob/master/tests/SP04.kif.tq
;;
;; to test it.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[subclass,'Flower','PlantAnatomicalStructure'])
</span><span class="ansi38-255165000">  (subclass Flower PlantAnatomicalStructure)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[instance,'Inside','PositionalAttribute'])
</span><span class="ansi38-255165000">  (instance Inside PositionalAttribute)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[subclass,'Container','Object'])
</span><span class="ansi38-255165000">  (subclass Container Object)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[domain,objectTransferred,1,'Transfer'])
</span><span class="ansi38-255165000">  (domain objectTransferred 1 Transfer)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[domain,objectTransferred,2,'Object'])
</span><span class="ansi38-255165000">  (domain objectTransferred 2 Object)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[instance,objectTransferred,'CaseRole'])
</span><span class="ansi38-255165000">  (instance objectTransferred CaseRole)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[subrelation,objectTransferred,patient])
</span><span class="ansi38-255165000">  (subrelation objectTransferred patient)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[instance,'JohnsCarry','Carrying'])
</span><span class="ansi38-255165000">  (instance JohnsCarry Carrying)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[objectTransferred,'JohnsCarry','JohnsVase'])
</span><span class="ansi38-255165000">  (objectTransferred JohnsCarry JohnsVase)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[agent,'JohnsCarry','John'])
</span><span class="ansi38-255165000">  (agent JohnsCarry John)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[instance,'JohnsFlower','Flower'])
</span><span class="ansi38-255165000">  (instance JohnsFlower Flower)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[instance,'JohnsVase','Container'])
</span><span class="ansi38-255165000">  (instance JohnsVase Container)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[orientation,'JohnsFlower','JohnsVase','Inside'])
</span><span class="ansi38-255165000">  (orientation JohnsFlower JohnsVase Inside)
</span>

      <--(2,retval('Empty'))
<span class="ansi33"> Empty

</span>;; An example of query would be
;;
;; (query (â§ (instance $C Carrying) (agent $C John) (instance $F Flower) (objectTransferred $C $F)))
<span class="ansi38-000068000">!(import! &rb "../rule-base.metta")

</span>      -->(3,'&self',['import!','&rb','../rule-base.metta'],depth(1))
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/sumo/john-carry-flower/john-carry-flower-test.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/sumo/john-carry-flower/john-carry-flower-test.metta')
;; Label each statement in the knowledge base as a witness of a type,
;; because that is what the synthesizer expects.  For now each witness
;; is defined by using the `WitnessOf` construct.  So for instance the
;; statement
;;
;; (instance A Object)
;;
;; has the corresponding witness
;;
;; (WitnessOf (instance A Object))
;;
;; Then add the labelled statement in the labelled-kb space.
;;; Inference rules to operate on SUMO
;; Binary Conjunction Introduction
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&rb',[:,'BinaryConjunctionIntroduction',[->,X,Y,['â\x88\§',X,Y]]])
</span><span class="ansi38-255165000">  (: BinaryConjunctionIntroduction 
    (-> $X $Y 
      (â§ $X $Y)))
</span>

;; Premises
;; Conclusion
;; Trinary Conjunction Introduction
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&rb',[:,'TrinaryConjunctionIntroduction',[->,X,Y,Z,['â\x88\§',X,Y,Z]]])
</span><span class="ansi38-255165000">  (: TrinaryConjunctionIntroduction 
    (-> $X $Y $Z 
      (â§ $X $Y $Z)))
</span>

;; Premises
;; Conclusion
;; Quaternary Conjunction Introduction
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&rb',[:,'QuaternaryConjunctionIntroduction',[->,X,Y,Z,W,['â\x88\§',X,Y,Z,W]]])
</span><span class="ansi38-255165000">  (: QuaternaryConjunctionIntroduction 
    (-> $X $Y $Z $W 
      (â§ $X $Y $Z $W)))
</span>

;; Premises
;; Conclusion
;; Modus Ponens
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&rb',[:,'ModusPonens',[->,['â\x9F\¹',X,Y],X,Y]])
</span><span class="ansi38-255165000">  (: ModusPonens 
    (-> 
      (â¹ $X $Y) $X $Y))
</span>

      <--(3,retval('Empty'))
<span class="ansi33"> Empty

</span>;; Premises
;; Conclusion
<span class="ansi38-000068000">!(bind! &labelled-kb 
  (new-space))

</span>      -->(4,'&self',['bind!','&labelled-kb',['new-space']],depth(1))
          -->(5,'&self',['new-space'],depth(3))
          <--(5,retval('Space'([])))
            -->(6,'&self','Space'([]),depth(4))
      <--(4,retval('Empty'))
<span class="ansi33"> Empty

</span><span class="ansi38-000068000">!(match &kb $X 
  (add-atom &labelled-kb 
    (: 
      (WitnessOf $X) $X)))

</span>      -->(7,'&self',[match,'&kb',_85372,['add-atom','&labelled-kb',[:,['WitnessOf',_85372],_85372]]],depth(1))
      <--(7,retval(['add-atom','&labelled-kb',[:,['WitnessOf',[]],[]]]))
        -->(8,'&self',['add-atom','&labelled-kb',[:,['WitnessOf',[]],[]]],depth(2))
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&labelled-kb',[:,['WitnessOf',[]],[]])
</span><span class="ansi38-255165000">  (: 
    (WitnessOf ()) ())
</span>

        <--(8,retval('True'))
<span class="ansi33"> True
</span><span class="ansi32">['X'=[]]
</span>

<span class="ansi31">
! (assertEqualToResult 
    (match &kb $X 
      (add-atom &labelled-kb 
        (: 
          (WitnessOf $X) $X))) 
    (()))
(@ ! 
  (assertEqual 
    (True) 
    (())))
write_pass_fail_result("JOHN-CARRY-FLOWER.JOHN-CARRY-FLOWER-TEST.103",exec,[match,'&kb',X,['add-atom','&labelled-kb',[:,['WitnessOf',X],X]]],'FAIL',[[]],['True'])

</span>

--------------------------------------------------------------------------
;; Define knowledge base (called kb but different than &kb)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,kb,[->,'Atom']])
</span><span class="ansi38-255165000">  (: kb 
    (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[kb],[match,'&labelled-kb',X,X])
</span><span class="ansi38-255165000">  (= 
    (kb) 
    (match &labelled-kb $X $X))
</span>

;; Define rule base (called rb but different than &rb)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,rb,[->,'Atom']])
</span><span class="ansi38-255165000">  (: rb 
    (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[rb],[match,'&rb',X,X])
</span><span class="ansi38-255165000">  (= 
    (rb) 
    (match &rb $X $X))
</span>

;; ;; Call synthesizer on query (â§ (instance $C Carrying) (agent $C John))
;; !(synthesize (: $proof (â§ (instance $C Carrying) (agent $C John)))
;;              kb rb (fromNumber 1))
;; ;; Call synthesizer on query (â§ (instance $C Carrying) (agent $C John) (instance $F Flower))
;; !(synthesize (: $proof (â§ (instance $C Carrying) (agent $C John) (instance $F Flower)))
;;              kb rb (fromNumber 2))
;; Call synthesizer on query (instance JohnsCarry Transfer)
;;
;; Should synthesize the following proof tree
;;                                                              ----------------------------     ------------------------------
;;                                                              (subclass Carrying Transfer)     (instance JohnsCarry Carrying)
;;                                                              ---------------------------------------------------------------(BinaryConjunctionIntroduction)
;; (â¹ (â§ (subclass $X $Y) (instance $Z $X)) (instance $Z $Y))  (â§ (subclass Carrying Transfer) (instance JohnsCarry Carrying))
;; ----------------------------------------------------------------------------------------------------------------------------(ModusPonens)
;;                                             (instance JohnsCarry Transfer)
<span class="ansi38-000068000">!(synthesize 
  (: $Proof 
    (instance JohnsCarry Transfer)) kb rb 
  (fromNumber 2))

</span>      -->(9,'&self',[synthesize,[:,_94354,[instance,'JohnsCarry','Transfer']],kb,rb,[fromNumber,2]],depth(1))
          -->(10,'&self',[instance,'JohnsCarry','Transfer'],depth(3))
        -->(11,'&self',[let,[:,_94354,[instance,'JohnsCarry','Transfer']],[kb],[:,_94354,[instance,'JohnsCarry','Transfer']]],depth(2))
            -->(12,'&self',[kb],depth(4))
              -->(13,'&self',[match,'&labelled-kb',_102086,_102086],depth(5))
              <--(13,retval([]))
            <--(12,retval([match,'&labelled-kb',_102176,_102176]))
        <--(11,retval(fail))
      <--(9,retval([let,[:,_101326,[instance,'JohnsCarry','Transfer']],[kb],[:,_101326,[instance,'JohnsCarry','Transfer']]]))
<span class="ansi31">
! (assertEqualToResult 
    (synthesize 
      (: $Proof 
        (instance JohnsCarry Transfer)) kb rb 
      (fromNumber 2)) 
    (()))
(@ ! 
  (assertEqual () 
    (())))
write_pass_fail_result("JOHN-CARRY-FLOWER.JOHN-CARRY-FLOWER-TEST.104",exec,[synthesize,[:,Proof,[instance,'JohnsCarry','Transfer']],kb,rb,[fromNumber,2]],'FAIL',[[]],[])

</span>

--------------------------------------------------------------------------
;; Call synthesizer on query (â§ (instance JohnsCarry Transfer) (objectTransferred JohnsCarry JohnsVase) (orientation JohnsFlower JohnsVase Inside))
;;
;; Should synthesize the following proof tree
;;
;;
;;                                                              ----------------------------     ------------------------------
;;                                                              (subclass Carrying Transfer)     (instance JohnsCarry Carrying)
;;                                                              ---------------------------------------------------------------(BinaryConjunctionIntroduction)
;; (â¹ (â§ (subclass $X $Y) (instance $Z $X)) (instance $Z $Y))  (â§ (subclass Carrying Transfer) (instance JohnsCarry Carrying))
;; ----------------------------------------------------------------------------------------------------------------------------(ModusPonens)   ----------------------------------------  ------------------------------------------
;;                                             (instance JohnsCarry Transfer)                                                                  (objectTransferred JohnsCarry JohnsVase)  (orientation JohnsFlower JohnsVase Inside)
;;                                             ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------(TrinaryConjunctionIntroduction)
;;                                                                       (â§ (instance JohnsCarry Transfer) (objectTransferred JohnsCarry JohnsVase) (orientation JohnsFlower JohnsVase Inside))
<span class="ansi38-000068000">!(synthesize 
  (: $Proof 
    (â§ 
      (instance JohnsCarry Transfer) 
      (objectTransferred JohnsCarry JohnsVase) 
      (orientation JohnsFlower JohnsVase Inside))) kb rb 
  (fromNumber 3))

</span>      -->(14,'&self',[synthesize,[:,_259898,['â\x88\§',[instance,'JohnsCarry','Transfer'],[objectTransferred,'JohnsCarry','JohnsVase'],[orientation,'JohnsFlower','JohnsVase','Inside']]],kb,rb,[fromNumber,3]],depth(1))
          -->(15,'&self',[instance,'JohnsCarry','Transfer'],depth(3))
        -->(16,'&self',[let,[:,_259898,['â\x88\§',[instance,'JohnsCarry','Transfer'],[objectTransferred,'JohnsCarry','JohnsVase'],[orientation,'JohnsFlower','JohnsVase','Inside']]],[kb],[:,_259898,['â\x88\§',[instance,'JohnsCarry','Transfer'],[objectTransferred,'JohnsCarry','JohnsVase'],[orientation,'JohnsFlower','JohnsVase','Inside']]]],depth(2))
            -->(17,'&self',[kb],depth(4))
              -->(18,'&self',[match,'&labelled-kb',_264486,_264486],depth(5))
              <--(18,retval([]))
            <--(17,retval([match,'&labelled-kb',_264576,_264576]))
        <--(16,retval(fail))
      <--(14,retval([let,[:,_263660,['â\x88\§',[instance,'JohnsCarry','Transfer'],[objectTransferred,'JohnsCarry','JohnsVase'],[orientation,'JohnsFlower','JohnsVase','Inside']]],[kb],[:,_263660,['â\x88\§',[instance,'JohnsCarry','Transfer'],[objectTransferred,'JohnsCarry','JohnsVase'],[orientation,'JohnsFlower','JohnsVase','Inside']]]]))
<span class="ansi31">
! (assertEqualToResult 
    (synthesize 
      (: $Proof 
        (â§ 
          (instance JohnsCarry Transfer) 
          (objectTransferred JohnsCarry JohnsVase) 
          (orientation JohnsFlower JohnsVase Inside))) kb rb 
      (fromNumber 3)) 
    (() () () () () () () () () () () () () () () () () () () () () () ()))
(@ ! 
  (assertEqual () 
    (() () () () () () () () () () () () () () () () () () () () () () ())))
write_pass_fail_result("JOHN-CARRY-FLOWER.JOHN-CARRY-FLOWER-TEST.105",exec,[synthesize,[:,Proof,['â\x88\§',[instance,'JohnsCarry','Transfer'],[objectTransferred,'JohnsCarry','JohnsVase'],[orientation,'JohnsFlower','JohnsVase','Inside']]],kb,rb,[fromNumber,3]],'FAIL',[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],[])

</span>

--------------------------------------------------------------------------
;; Call synthesizer on query (objectTransferred JohnsCarry JohnsFlower)
;;
;; Should synthesize the following proof tree
;;                                                                                                                                       ----------------------------     ------------------------------
;;                                                                                                                                       (subclass Carrying Transfer)     (instance JohnsCarry Carrying)
;;                                                                                                                                       ---------------------------------------------------------------(BinaryConjunctionIntroduction)
;;                                                                          (â¹ (â§ (subclass $X $Y) (instance $Z $X)) (instance $Z $Y))  (â§ (subclass Carrying Transfer) (instance JohnsCarry Carrying))
;;                                                                          ----------------------------------------------------------------------------------------------------------------------------(ModusPonens)   ----------------------------------------  ------------------------------------------
;;                                                                                                                      (instance JohnsCarry Transfer)                                                                  (objectTransferred JohnsCarry JohnsVase)  (orientation JohnsFlower JohnsVase Inside)
;; -----------------------------------------------------------------------------------------------------------------    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------(TrinaryConjunctionIntroduction)
;; (â¹ (â§ (instance $T Transfer) (objectTransferred $T $O) (orientation $O2 $O Inside)) (objectTransferred $T $O2))    (â§ (instance JohnsCarry Transfer) (objectTransferred JohnsCarry JohnsVase) (orientation JohnsFlower JohnsVase Inside))
;; ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------(ModusPonens)
;;                                                                                              (objectTransferred JohnsCarry JohnsFlower)
<span class="ansi38-000068000">!(synthesize 
  (: $Proof 
    (objectTransferred JohnsCarry JohnsFlower)) kb rb 
  (fromNumber 4))

</span>      -->(19,'&self',[synthesize,[:,_419690,[objectTransferred,'JohnsCarry','JohnsFlower']],kb,rb,[fromNumber,4]],depth(1))
          -->(20,'&self',[objectTransferred,'JohnsCarry','JohnsFlower'],depth(3))
        -->(21,'&self',[let,[:,_419690,[objectTransferred,'JohnsCarry','JohnsFlower']],[kb],[:,_419690,[objectTransferred,'JohnsCarry','JohnsFlower']]],depth(2))
            -->(22,'&self',[kb],depth(4))
              -->(23,'&self',[match,'&labelled-kb',_423714,_423714],depth(5))
              <--(23,retval([]))
            <--(22,retval([match,'&labelled-kb',_423804,_423804]))
        <--(21,retval(fail))
      <--(19,retval([let,[:,_422954,[objectTransferred,'JohnsCarry','JohnsFlower']],[kb],[:,_422954,[objectTransferred,'JohnsCarry','JohnsFlower']]]))
<span class="ansi31">
! (assertEqualToResult 
    (synthesize 
      (: $Proof 
        (objectTransferred JohnsCarry JohnsFlower)) kb rb 
      (fromNumber 4)) 
    ( (: 
        (ModusPonens 
          (WitnessOf 
            (⟹ 
              (∧ 
                (subclass Carrying Transfer) 
                (instance JohnsCarry Carrying)) 
              (instance JohnsCarry Transfer))) 
          (BinaryConjunctionIntroduction 
            (WitnessOf 
              (subclass Carrying Transfer)) 
            (WitnessOf 
              (instance JohnsCarry Carrying)))) 
        (instance JohnsCarry Transfer))))
(@ ! 
  (assertEqual () 
    ( (: 
        (ModusPonens 
          (WitnessOf 
            (⟹ 
              (∧ 
                (subclass Carrying Transfer) 
                (instance JohnsCarry Carrying)) 
              (instance JohnsCarry Transfer))) 
          (BinaryConjunctionIntroduction 
            (WitnessOf 
              (subclass Carrying Transfer)) 
            (WitnessOf 
              (instance JohnsCarry Carrying)))) 
        (instance JohnsCarry Transfer)))))
write_pass_fail_result("JOHN-CARRY-FLOWER.JOHN-CARRY-FLOWER-TEST.106",exec,[synthesize,[:,Proof,[objectTransferred,'JohnsCarry','JohnsFlower']],kb,rb,[fromNumber,4]],'FAIL',[[:,['ModusPonens',['WitnessOf',[⟹,[∧,[subclass,'Carrying','Transfer'],[instance,'JohnsCarry','Carrying']],[instance,'JohnsCarry','Transfer']]],['BinaryConjunctionIntroduction',['WitnessOf',[subclass,'Carrying','Transfer']],['WitnessOf',[instance,'JohnsCarry','Carrying']]]],[instance,'JohnsCarry','Transfer']]],[])

</span>

--------------------------------------------------------------------------
;; Call synthesizer on query (â§ (instance $C Carrying)
;;                              (agent $C John)
;;                              (instance $F Flower)
;;                              (objectTransferred $C $F))
;;
;; Should synthesize the following proof tree
;;                                                                                                                                                                                                                                                                              ----------------------------     ------------------------------
;;                                                                                                                                                                                                                                                                              (subclass Carrying Transfer)     (instance JohnsCarry Carrying)
;;                                                                                                                                                                                                                                                                              ---------------------------------------------------------------(BinaryConjunctionIntroduction)
;;                                                                                                                                                                                                                 (â¹ (â§ (subclass $X $Y) (instance $Z $X)) (instance $Z $Y))  (â§ (subclass Carrying Transfer) (instance JohnsCarry Carrying))
;;                                                                                                                                                                                                                 ----------------------------------------------------------------------------------------------------------------------------(ModusPonens)   ----------------------------------------  ------------------------------------------
;;                                                                                                                                                                                                                 (instance JohnsCarry Transfer)                                                                                                              (objectTransferred JohnsCarry JohnsVase)  (orientation JohnsFlower JohnsVase Inside)
;;                                                                                            -----------------------------------------------------------------------------------------------------------------    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------(TrinaryConjunctionIntroduction)
;;                                                                                            (â¹ (â§ (instance $T Transfer) (objectTransferred $T $O) (orientation $O2 $O Inside)) (objectTransferred $T $O2))    (â§ (instance JohnsCarry Transfer) (objectTransferred JohnsCarry JohnsVase) (orientation JohnsFlower JohnsVase Inside))
;; ------------------------------   -----------------------   -----------------------------   ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------(ModusPonens)
;; (instance JohnsCarry Carrying)   (agent JohnsCarry John)   (instance JohnsFlower Flower)   (objectTransferred JohnsCarry JohnsFlower)
;; --------------------------------------------------------------------------------------------------------------------------------------(QuaternaryConjuctionIntroduction)
;;  (â§ (instance JohnsCarry Carrying) (agent JohnsCarry John) (instance JohnsFlower Flower) (objectTransferred JohnsCarry JohnsFlower))
;;
;; Corresponding to the MeTTa expression:
;;
;; (: (QuaternaryConjunctionIntroduction (WitnessOf (instance JohnsCarry Carrying))
;;                                       (WitnessOf (agent JohnsCarry John))
;;                                       (WitnessOf (instance JohnsFlower Flower))
;;                                       (ModusPonens (WitnessOf (â¹ (â§ (instance JohnsCarry Transfer) (objectTransferred JohnsCarry JohnsVase) (orientation JohnsFlower JohnsVase Inside)) (objectTransferred JohnsCarry JohnsFlower)))
;;                                                    (TrinaryConjunctionIntroduction (ModusPonens (WitnessOf (â¹ (â§ (subclass Carrying Transfer) (instance JohnsCarry Carrying)) (instance JohnsCarry Transfer)))
;;                                                                                                 (BinaryConjunctionIntroduction (WitnessOf (subclass Carrying Transfer)) (WitnessOf (instance JohnsCarry Carrying))))
;;                                                                                    (WitnessOf (objectTransferred JohnsCarry JohnsVase))
;;                                                                                    (WitnessOf (orientation JohnsFlower JohnsVase Inside)))))
;;    (â§ (instance JohnsCarry Carrying) (agent JohnsCarry John) (instance JohnsFlower Flower) (objectTransferred JohnsCarry JohnsFlower)))
<span class="ansi38-000068000">!(synthesize 
  (: $Proof 
    (â§ 
      (instance $C Carrying) 
      (agent $C John) 
      (instance $False Flower) 
      (objectTransferred $C $False))) kb rb 
  (fromNumber 5))

</span>      -->(24,'&self',[synthesize,[:,_466766,['â\x88\§',[instance,_467106,'Carrying'],[agent,_467106,'John'],[instance,_467718,'Flower'],[objectTransferred,_467106,_467718]]],kb,rb,[fromNumber,5]],depth(1))
          -->(25,'&self',[fromNumber,5],depth(3))
            -->(26,'&self',[if,[<=,5,0],'Z',['S',[fromNumber,[-,5,1]]]],depth(4))
                -->(27,'&self',[<=,5,0],depth(6))
                  -->(28,'&self',[or,[<,5,0],[==,5,0]],depth(7))
                      -->(29,'&self',[<,5,0],depth(9))
                      <--(29,retval('False'))
                      -->(30,'&self',[==,5,0],depth(9))
                      <--(30,retval('False'))
                  <--(28,retval('False'))
                -->(31,'&self',['S',[fromNumber,[-,5,1]]],depth(6))
                    -->(32,'&self',[fromNumber,[-,5,1]],depth(8))
                        -->(33,'&self',[-,5,1],depth(10))
                        <--(33,retval(4))
                        -->(34,'&self',[fromNumber,4],depth(10))
                          -->(35,'&self',[if,[<=,4,0],'Z',['S',[fromNumber,[-,4,1]]]],depth(11))
                              -->(36,'&self',[<=,4,0],depth(13))
                                -->(37,'&self',[or,[<,4,0],[==,4,0]],depth(14))
                                    -->(38,'&self',[<,4,0],depth(16))
                                    <--(38,retval('False'))
                                    -->(39,'&self',[==,4,0],depth(16))
                                    <--(39,retval('False'))
                                <--(37,retval('False'))
                              -->(40,'&self',['S',[fromNumber,[-,4,1]]],depth(13))
                                  -->(41,'&self',[fromNumber,[-,4,1]],depth(15))
                                      -->(42,'&self',[-,4,1],depth(17))
                                      <--(42,retval(3))
                                      -->(43,'&self',[fromNumber,3],depth(17))
                                        -->(44,'&self',[if,[<=,3,0],'Z',['S',[fromNumber,[-,3,1]]]],depth(18))
                                            -->(45,'&self',[<=,3,0],depth(20))
                                              -->(46,'&self',[or,[<,3,0],[==,3,0]],depth(21))
                                                  -->(47,'&self',[<,3,0],depth(23))
                                                  <--(47,retval('False'))
                                                  -->(48,'&self',[==,3,0],depth(23))
                                                  <--(48,retval('False'))
                                              <--(46,retval('False'))
                                            -->(49,'&self',['S',[fromNumber,[-,3,1]]],depth(20))
                                                -->(50,'&self',[fromNumber,[-,3,1]],depth(22))
                                                    -->(51,'&self',[-,3,1],depth(24))
                                                    <--(51,retval(2))
                                                    -->(52,'&self',[fromNumber,2],depth(24))
                                                      -->(53,'&self',[if,[<=,2,0],'Z',['S',[fromNumber,[-,2,1]]]],depth(25))
                                                          -->(54,'&self',[<=,2,0],depth(27))
                                                            -->(55,'&self',[or,[<,2,0],[==,2,0]],depth(28))
                                                                -->(56,'&self',[<,2,0],depth(30))
                                                                <--(56,retval('False'))
                                                                -->(57,'&self',[==,2,0],depth(30))
                                                                <--(57,retval('False'))
                                                            <--(55,retval('False'))
                                                          -->(58,'&self',['S',[fromNumber,[-,2,1]]],depth(27))
                                                              -->(59,'&self',[fromNumber,[-,2,1]],depth(29))
                                                                  -->(60,'&self',[-,2,1],depth(31))
                                                                  <--(60,retval(1))
                                                                  -->(61,'&self',[fromNumber,1],depth(31))
                                                                    -->(62,'&self',[if,[<=,1,0],'Z',['S',[fromNumber,[-,1,1]]]],depth(32))
                                                                        -->(63,'&self',[<=,1,0],depth(34))
                                                                          -->(64,'&self',[or,[<,1,0],[==,1,0]],depth(35))
                                                                              -->(65,'&self',[<,1,0],depth(37))
                                                                              <--(65,retval('False'))
                                                                              -->(66,'&self',[==,1,0],depth(37))
                                                                              <--(66,retval('False'))
                                                                          <--(64,retval('False'))
                                                                        -->(67,'&self',['S',[fromNumber,[-,1,1]]],depth(34))
                                                                            -->(68,'&self',[fromNumber,[-,1,1]],depth(36))
                                                                                -->(69,'&self',[-,1,1],depth(38))
                                                                                <--(69,retval(0))
                                                                                -->(70,'&self',[fromNumber,0],depth(38))
                                                                                  -->(71,'&self',[if,[<=,0,0],'Z',['S',[fromNumber,[-,0,1]]]],depth(39))
                                                                                      -->(72,'&self',[<=,0,0],depth(41))
                                                                                        -->(73,'&self',[or,[<,0,0],[==,0,0]],depth(42))
                                                                                            -->(74,'&self',[<,0,0],depth(44))
                                                                                            <--(74,retval('False'))
                                                                                            -->(75,'&self',[==,0,0],depth(44))
                                                                                            <--(75,retval('True'))
                                                                                        <--(73,retval('True'))
                                                                          -->(76,'&self',['S','Z'],depth(35))
                                                                      -->(77,'&self',['S','Z'],depth(33))
                                                                -->(78,'&self',['S','Z'],depth(30))
                                                            -->(79,'&self',['S',['S','Z']],depth(28))
                                                                -->(80,'&self',['S','Z'],depth(30))
                                                        -->(81,'&self',['S',['S','Z']],depth(26))
                                                            -->(82,'&self',['S','Z'],depth(28))
                                                  -->(83,'&self',['S',['S','Z']],depth(23))
                                                      -->(84,'&self',['S','Z'],depth(25))
                                              -->(85,'&self',['S',['S',['S','Z']]],depth(21))
                                                  -->(86,'&self',['S',['S','Z']],depth(23))
                                                      -->(87,'&self',['S','Z'],depth(25))
                                          -->(88,'&self',['S',['S',['S','Z']]],depth(19))
                                              -->(89,'&self',['S',['S','Z']],depth(21))
                                                  -->(90,'&self',['S','Z'],depth(23))
                                    -->(91,'&self',['S',['S',['S','Z']]],depth(16))
                                        -->(92,'&self',['S',['S','Z']],depth(18))
                                            -->(93,'&self',['S','Z'],depth(20))
                                -->(94,'&self',['S',['S',['S',['S','Z']]]],depth(14))
                                    -->(95,'&self',['S',['S',['S','Z']]],depth(16))
                                        -->(96,'&self',['S',['S','Z']],depth(18))
                                            -->(97,'&self',['S','Z'],depth(20))
                            -->(98,'&self',['S',['S',['S',['S','Z']]]],depth(12))
                                -->(99,'&self',['S',['S',['S','Z']]],depth(14))
                                    -->(100,'&self',['S',['S','Z']],depth(16))
Switched off tracing. For a longer trace !(pragma! tracelen 101))<span class="ansi31">

! (assertEqualToResult 
    (synthesize 
      (: $Proof 
        (â§ 
          (instance $C Carrying) 
          (agent $C John) 
          (instance $False Flower) 
          (objectTransferred $C $False))) kb rb 
      (fromNumber 5)) 
    ( (let* 
        ( ( (: $Proof1_C35_5582 
              (⟹ $X_C35_5505 
                (∧ 
                  (instance JohnsCarry Transfer) 
                  (objectTransferred JohnsCarry JohnsVase) 
                  (orientation JohnsFlower JohnsVase Inside)))) 
            (synthesize 
              (: $Proof1_C35_5582 
                (⟹ $X_C35_5505 
                  (∧ 
                    (instance JohnsCarry Transfer) 
                    (objectTransferred JohnsCarry JohnsVase) 
                    (orientation JohnsFlower JohnsVase Inside)))) kb rb 
              (S 
                (S Z)))) 
          ( (: $Proof2_C35_5583 $X_C35_5505) 
            (synthesize 
              (: $Proof2_C35_5583 $X_C35_5505) kb rb 
              (S 
                (S Z))))) 
        (: 
          (ModusPonens $Proof1_C35_5582 $Proof2_C35_5583) 
          (∧ 
            (instance JohnsCarry Transfer) 
            (objectTransferred JohnsCarry JohnsVase) 
            (orientation JohnsFlower JohnsVase Inside)))) 
      (: 
        (TrinaryConjunctionIntroduction 
          (ModusPonens 
            (WitnessOf 
              (⟹ 
                (∧ 
                  (subclass Carrying Transfer) 
                  (instance JohnsCarry Carrying)) 
                (instance JohnsCarry Transfer))) 
            (BinaryConjunctionIntroduction 
              (WitnessOf 
                (subclass Carrying Transfer)) 
              (WitnessOf 
                (instance JohnsCarry Carrying)))) 
          (WitnessOf 
            (objectTransferred JohnsCarry JohnsVase)) 
          (WitnessOf 
            (orientation JohnsFlower JohnsVase Inside))) 
        (∧ 
          (instance JohnsCarry Transfer) 
          (objectTransferred JohnsCarry JohnsVase) 
          (orientation JohnsFlower JohnsVase Inside)))))
(@ ! 
  (assertEqual () 
    ( (let* 
        ( ( (: $Proof1_C35_5582 
              (⟹ $X_C35_5505 
                (∧ 
                  (instance JohnsCarry Transfer) 
                  (objectTransferred JohnsCarry JohnsVase) 
                  (orientation JohnsFlower JohnsVase Inside)))) 
            (synthesize 
              (: $Proof1_C35_5582 
                (⟹ $X_C35_5505 
                  (∧ 
                    (instance JohnsCarry Transfer) 
                    (objectTransferred JohnsCarry JohnsVase) 
                    (orientation JohnsFlower JohnsVase Inside)))) kb rb 
              (S 
                (S Z)))) 
          ( (: $Proof2_C35_5583 $X_C35_5505) 
            (synthesize 
              (: $Proof2_C35_5583 $X_C35_5505) kb rb 
              (S 
                (S Z))))) 
        (: 
          (ModusPonens $Proof1_C35_5582 $Proof2_C35_5583) 
          (∧ 
            (instance JohnsCarry Transfer) 
            (objectTransferred JohnsCarry JohnsVase) 
            (orientation JohnsFlower JohnsVase Inside)))) 
      (: 
        (TrinaryConjunctionIntroduction 
          (ModusPonens 
            (WitnessOf 
              (⟹ 
                (∧ 
                  (subclass Carrying Transfer) 
                  (instance JohnsCarry Carrying)) 
                (instance JohnsCarry Transfer))) 
            (BinaryConjunctionIntroduction 
              (WitnessOf 
                (subclass Carrying Transfer)) 
              (WitnessOf 
                (instance JohnsCarry Carrying)))) 
          (WitnessOf 
            (objectTransferred JohnsCarry JohnsVase)) 
          (WitnessOf 
            (orientation JohnsFlower JohnsVase Inside))) 
        (∧ 
          (instance JohnsCarry Transfer) 
          (objectTransferred JohnsCarry JohnsVase) 
          (orientation JohnsFlower JohnsVase Inside))))))
write_pass_fail_result("JOHN-CARRY-FLOWER.JOHN-CARRY-FLOWER-TEST.107",exec,[synthesize,[:,Proof,['â\x88\§',[instance,C,'Carrying'],[agent,C,'John'],[instance,False,'Flower'],[objectTransferred,C,False]]],kb,rb,[fromNumber,5]],'FAIL',[['let*',[[[:,Proof1_C35_5582,[⟹,X_C35_5505,[∧,[instance,'JohnsCarry','Transfer'],[objectTransferred,'JohnsCarry','JohnsVase'],[orientation,'JohnsFlower','JohnsVase','Inside']]]],[synthesize,[:,Proof1_C35_5582,[⟹,X_C35_5505,[∧,[instance,'JohnsCarry','Transfer'],[objectTransferred,'JohnsCarry','JohnsVase'],[orientation,'JohnsFlower','JohnsVase','Inside']]]],kb,rb,['S',['S','Z']]]],[[:,Proof2_C35_5583,X_C35_5505],[synthesize,[:,Proof2_C35_5583,X_C35_5505],kb,rb,['S',['S','Z']]]]],[:,['ModusPonens',Proof1_C35_5582,Proof2_C35_5583],[∧,[instance,'JohnsCarry','Transfer'],[objectTransferred,'JohnsCarry','JohnsVase'],[orientation,'JohnsFlower','JohnsVase','Inside']]]],[:,['TrinaryConjunctionIntroduction',['ModusPonens',['WitnessOf',[⟹,[∧,[subclass,'Carrying','Transfer'],[instance,'JohnsCarry','Carrying']],[instance,'JohnsCarry','Transfer']]],['BinaryConjunctionIntroduction',['WitnessOf',[subclass,'Carrying','Transfer']],['WitnessOf',[instance,'JohnsCarry','Carrying']]]],['WitnessOf',[objectTransferred,'JohnsCarry','JohnsVase']],['WitnessOf',[orientation,'JohnsFlower','JohnsVase','Inside']]],[∧,[instance,'JohnsCarry','Transfer'],[objectTransferred,'JohnsCarry','JohnsVase'],[orientation,'JohnsFlower','JohnsVase','Inside']]]],[])

</span>

--------------------------------------------------------------------------
<span class="ansi32">% 85,711,195 inferences, 18.067 CPU in 18.069 seconds (100% CPU, 4744111 Lips)
</span> (@ = "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/sumo/john-carry-flower/john-carry-flower-test.metta" 0)
<span class="ansi1">LoonIt Report
</span>------------
<span class="ansi32">Successes: 0
</span><span class="ansi31">Failures: 5
</span>doing(ansi2html -u < "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/TEE.ansi" > "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_88/hyperon-pln_metta/sumo/john-carry-flower/john-carry-flower-test.html" )

</pre>
</body>

</html>
