<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>
<style type="text/css">
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi36 { color: #00aaaa; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-218112214 { color: #DA70D6; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-218112214 { color: #DA70D6; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-250144246 { color: #FA90F6; }
.ansi38-218112214 { color: #DA70D6; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-250144246 { color: #FA90F6; }
.ansi38-218112214 { color: #DA70D6; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-250144246 { color: #FA90F6; }
.ansi38-218112214 { color: #DA70D6; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-250144246 { color: #FA90F6; }
.ansi38-218112214 { color: #DA70D6; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-250144246 { color: #FA90F6; }
.ansi38-218112214 { color: #DA70D6; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-250144246 { color: #FA90F6; }
.ansi38-218112214 { color: #DA70D6; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content">
 (track_load_into_file "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/extended_compat/metta-examples/recursion-schemes/src/examples/expression.metta")
%~ /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/extended_compat/metta-examples/recursion-schemes/src/examples/expression.metta:1 
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/extended_compat/metta-examples/recursion-schemes/src/examples/expression.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/extended_compat/metta-examples/recursion-schemes/src/examples/expression.metta')
1=[()]
2=[(evalExpr (mapExpr (cata mapExpr evalExpr) (unFix (Fix (Plus (Fix (Plus (Fix (Var X)) (Fix (Const 2)))) (Fix (Const 40)))))))]
3=[(Fix (Plus (Fix (Const 2)) (Fix (Const 2))))]
4=[9]
5=[(diff (mapExpr (para_pair mapExpr diff) (unFix (Fix (Plus (Fix (Var X)) (Fix (Const 1)))))))]
6=[(Fix $Y), (2t $x#534), (1p $x#535)]
7=[(Fix (Plus (Fix (Plus (Fix (Const 1)) (Fix (Var X)))) (Fix (Plus (Fix (Const 1)) (Fix (Var X))))))]
8=1.20user 0.00system 0:01.21elapsed 100%CPU (0avgtext+0avgdata 34056maxresident)k
8=0inputs+0outputs (0major+3707minor)pagefaults 0swaps
:- dynamic file_answers/3.

file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/extended_compat/metta-examples/recursion-schemes/src/examples/expression.metta', 1, [[]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/extended_compat/metta-examples/recursion-schemes/src/examples/expression.metta', 2, [[evalExpr, [mapExpr, [cata, mapExpr, evalExpr], [unFix, ['Fix', ['Plus', ['Fix', ['Plus', ['Fix', ['Var', 'X']], ['Fix', ['Const', 2]]]], ['Fix', ['Const', 40]]]]]]]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/extended_compat/metta-examples/recursion-schemes/src/examples/expression.metta', 3, [['Fix', ['Plus', ['Fix', ['Const', 2]], ['Fix', ['Const', 2]]]]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/extended_compat/metta-examples/recursion-schemes/src/examples/expression.metta', 4, [9]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/extended_compat/metta-examples/recursion-schemes/src/examples/expression.metta', 5, [[diff, [mapExpr, [para_pair, mapExpr, diff], [unFix, ['Fix', ['Plus', ['Fix', ['Var', 'X']], ['Fix', ['Const', 1]]]]]]]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/extended_compat/metta-examples/recursion-schemes/src/examples/expression.metta', 6, [['Fix', Y], [2, t, X_C35_534], [1, p, X_C35_535]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/extended_compat/metta-examples/recursion-schemes/src/examples/expression.metta', 7, [['Fix', ['Plus', ['Fix', ['Plus', ['Fix', ['Const', 1]], ['Fix', ['Var', 'X']]]], ['Fix', ['Plus', ['Fix', ['Const', 1]], ['Fix', ['Var', 'X']]]]]]]).

;; !(import! &self "../schemes.metta")
<span class="ansi38-013099040">!(import! &self "../schemes.metta")

</span><span class="ansi38-218112214">% DEBUG:   eval('&self',['import!','&self','../schemes.metta'],OUT).

</span>    -->(0,eval('&self',['import!','&self','../schemes.metta'],RET),depth(0))
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/extended_compat/metta-examples/recursion-schemes/src/schemes.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/extended_compat/metta-examples/recursion-schemes/src/schemes.metta')
;; How to apply a function to the slots, a Functor's map
;; For references see https://github.com/passy/awesome-recursion-schemes
;; For my typed Scala implementation see https://github.com/Adam-Vandervorst/RecursionSchemes
<span class="ansi38-013099040">!(transfer! base.metta)

</span><span class="ansi38-218112214">% DEBUG:   eval('&self',['transfer!','base.metta'],OUT).

</span>    -->(1,eval('&self',['transfer!','base.metta'],RET),depth(0))
%~ /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/extended_compat/metta-examples/recursion-schemes/src/examples/expression.metta:47 
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/extended_compat/metta-examples/recursion-schemes/src/base.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/extended_compat/metta-examples/recursion-schemes/src/base.metta')
;; folds
;; Wrapping and unwrapping for the recursion
;; Fix F = F (Fix F)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[unFix,['Fix',X]],X])
</span><span class="ansi38-255165000">(= 
  (unFix 
    (Fix $X)) $X)
</span>

;; identity function, useful in the combinators due to lack of
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[identity,X],X])
</span><span class="ansi38-255165000">(= 
  (identity $X) $X)
</span>

    <--(1,retval('Empty'))
Deterministic: <span class="ansi33">Empty

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[[cata,F,Alg],A],[Alg,[F,[cata,F,Alg],[unFix,A]]]])
</span><span class="ansi38-255165000">(= 
  ( (cata $F $Alg) $A) 
  ($Alg 
    ($F 
      (cata $F $Alg) 
      (unFix $A))))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[[para_pair,F,Alg],A],[',',[[para,F,Alg],A],A]])
</span><span class="ansi38-255165000">(= 
  ( (para_pair $F $Alg) $A) 
  (, 
    ( (para $F $Alg) $A) $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[[para,F,Alg],A],[Alg,[F,[para_pair,F,Alg],[unFix,A]]]])
</span><span class="ansi38-255165000">(= 
  ( (para $F $Alg) $A) 
  ($Alg 
    ($F 
      (para_pair $F $Alg) 
      (unFix $A))))
</span>

;; unfolds
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[[ana,F,Coalg],S],['Fix',[F,[ana,F,Coalg],[Coalg,S]]]])
</span><span class="ansi38-255165000">(= 
  ( (ana $F $Coalg) $S) 
  (Fix 
    ($F 
      (ana $F $Coalg) 
      ($Coalg $S))))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[[futu_picking,F,Coalg],['Pure',A]],[[futu,F,Coalg],A]])
</span><span class="ansi38-255165000">(= 
  ( (futu_picking $F $Coalg) 
    (Pure $A)) 
  ( (futu $F $Coalg) $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[[futu_picking,F,Coalg],['Bind',F]],['Fix',[F,[futu_picking,F,Coalg],F]]])
</span><span class="ansi38-255165000">(= 
  ( (futu_picking $F $Coalg) 
    (Bind $F)) 
  (Fix 
    ($F 
      (futu_picking $F $Coalg) $F)))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[[futu,F,Coalg],S],['Fix',[F,[futu_picking,F,Coalg],[Coalg,S]]]])
</span><span class="ansi38-255165000">(= 
  ( (futu $F $Coalg) $S) 
  (Fix 
    ($F 
      (futu_picking $F $Coalg) 
      ($Coalg $S))))
</span>

;; combinations
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[[hylo,F,Alg,Coalg],S],[Alg,[F,[hylo,F,Alg,Coalg],[Coalg,S]]]])
</span><span class="ansi38-255165000">(= 
  ( (hylo $F $Alg $Coalg) $S) 
  ($Alg 
    ($F 
      (hylo $F $Alg $Coalg) 
      ($Coalg $S))))
</span>

    <--(0,retval('Empty'))
Last Result(2): <span class="ansi33">Empty

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mapExpr,F,['Plus',X,Y]],['Plus',[F,X],[F,Y]]])
</span><span class="ansi38-255165000">(= 
  (mapExpr $F 
    (Plus $X $Y)) 
  (Plus 
    ($F $X) 
    ($F $Y)))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mapExpr,F,['Const',X]],['Const',X]])
</span><span class="ansi38-255165000">(= 
  (mapExpr $F 
    (Const $X)) 
  (Const $X))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[mapExpr,F,['Var',X]],['Var',X]])
</span><span class="ansi38-255165000">(= 
  (mapExpr $F 
    (Var $X)) 
  (Var $X))
</span>

;; How to evaluate the structure to some value, a single step, an algebra
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[evalExpr,['Plus',X,Y]],[+,X,Y]])
</span><span class="ansi38-255165000">(= 
  (evalExpr 
    (Plus $X $Y)) 
  (+ $X $Y))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[evalExpr,['Const',X]],X])
</span><span class="ansi38-255165000">(= 
  (evalExpr 
    (Const $X)) $X)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[evalExpr,['Var',X]],[valueOf,X]])
</span><span class="ansi38-255165000">(= 
  (evalExpr 
    (Var $X)) 
  (valueOf $X))
</span>

;; Dictionary we can use during evaluation
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[valueOf,'X'],0])
</span><span class="ansi38-255165000">(= 
  (valueOf X) 0)
</span>

;; A fold, with the Functor and algebra, applied to the Fix tree
<span class="ansi38-255165000">;; In file as:  
</span><span class="ansi1 ansi38-255238088">!((cata mapExpr evalExpr) 
  (Fix 
    (Plus 
      (Fix 
        (Plus 
          (Fix 
            (Var X)) 
          (Fix 
            (Const 2)))) 
      (Fix 
        (Const 40)))))
</span>;; To unit test case:
<span class="ansi38-013099040">!(assertEqualToResult 
  ( (cata mapExpr evalExpr) 
    (Fix 
      (Plus 
        (Fix 
          (Plus 
            (Fix 
              (Var X)) 
            (Fix 
              (Const 2)))) 
        (Fix 
          (Const 40))))) 
  ( (evalExpr 
      (mapExpr 
        (cata mapExpr evalExpr) 
        (unFix 
          (Fix 
            (Plus 
              (Fix 
                (Plus 
                  (Fix 
                    (Var X)) 
                  (Fix 
                    (Const 2)))) 
              (Fix 
                (Const 40)))))))))

</span><span class="ansi38-250144246">; !((cata mapExpr evalExpr) (Fix (Plus (Fix (Plus (Fix (Var X)) (Fix (Const 2)))) (Fix (Const 40)))))
</span><span class="ansi38-218112214">% DEBUG:   eval('&self',[[cata,mapExpr,evalExpr],['Fix',['Plus',['Fix',['Plus',['Fix',['Var','X']],['Fix',['Const',2]]]],['Fix',['Const',40]]]]],OUT).

</span>    -->(0,eval('&self',[assertEqualToResult,[[cata,mapExpr,evalExpr],['Fix',['Plus',['Fix',['Plus',['Fix',['Var','X']],['Fix',['Const',2]]]],['Fix',['Const',40]]]]],[[evalExpr,[mapExpr,[cata,mapExpr,evalExpr],[unFix,['Fix',['Plus',['Fix',['Plus',['Fix',['Var','X']],['Fix',['Const',2]]]],['Fix',['Const',40]]]]]]]]],RET),depth(0))
<h3 id="EXAMPLES.EXPRESSION.01">;; EXAMPLES.EXPRESSION.01</h3>
      -->(1,eval('&self',[[cata,mapExpr,evalExpr],['Fix',['Plus',['Fix',['Plus',['Fix',['Var','X']],['Fix',['Const',2]]]],['Fix',['Const',40]]]]],RET),depth(1))
          -->(2,eval('&self',[mapExpr,[cata,mapExpr,evalExpr],[unFix,['Fix',['Plus',['Fix',['Plus',['Fix',['Var','X']],['Fix',['Const',2]]]],['Fix',['Const',40]]]]]],RET),depth(3))
            -->(3,eval('&self',[cata,mapExpr,evalExpr],RET),depth(4))
                  -->(4,subst_args('&self',[cata,mapExpr,evalExpr],RET),depth(7))
            <--(3,retval([cata,mapExpr,evalExpr]))
            -->(5,eval('&self',[unFix,['Fix',['Plus',['Fix',['Plus',['Fix',['Var','X']],['Fix',['Const',2]]]],['Fix',['Const',40]]]]],RET),depth(4))
                -->(6,eval('&self',['Fix',['Plus',['Fix',['Var','X']],['Fix',['Const',2]]]],RET),depth(6))
                  -->(7,eval('&self',['Plus',['Fix',['Var','X']],['Fix',['Const',2]]],RET),depth(7))
                    -->(8,eval('&self',['Fix',['Var','X']],RET),depth(8))
                      -->(9,eval('&self',['Var','X'],RET),depth(9))
                      <--(9,retval(['Var','X']))
                      -->(11,eval('&self',['Var','X'],RET),depth(9))
                      <--(11,retval(['Var','X']))
                    <--(8,retval(['Fix',['Var','X']]))
                    -->(16,eval('&self',['Fix',['Const',2]],RET),depth(8))
                      -->(17,eval('&self',['Const',2],RET),depth(9))
                      <--(17,retval(['Const',2]))
                      -->(19,eval('&self',['Const',2],RET),depth(9))
                      <--(19,retval(['Const',2]))
                    <--(16,retval(['Fix',['Const',2]]))
                    -->(24,eval('&self',['Fix',['Var','X']],RET),depth(8))
                      -->(25,eval('&self',['Var','X'],RET),depth(9))
                      <--(25,retval(['Var','X']))
                      -->(27,eval('&self',['Var','X'],RET),depth(9))
                      <--(27,retval(['Var','X']))
                    <--(24,retval(['Fix',['Var','X']]))
                    -->(32,eval('&self',['Fix',['Const',2]],RET),depth(8))
                      -->(33,eval('&self',['Const',2],RET),depth(9))
                      <--(33,retval(['Const',2]))
                      -->(35,eval('&self',['Const',2],RET),depth(9))
                      <--(35,retval(['Const',2]))
                    <--(32,retval(['Fix',['Const',2]]))
                  <--(7,retval(['Plus',['Fix',['Var','X']],['Fix',['Const',2]]]))
                  -->(53,eval('&self',['Plus',['Fix',['Var','X']],['Fix',['Const',2]]],RET),depth(7))
                    -->(54,eval('&self',['Fix',['Var','X']],RET),depth(8))
                      -->(55,eval('&self',['Var','X'],RET),depth(9))
                      <--(55,retval(['Var','X']))
                      -->(57,eval('&self',['Var','X'],RET),depth(9))
                      <--(57,retval(['Var','X']))
                    <--(54,retval(['Fix',['Var','X']]))
                    -->(62,eval('&self',['Fix',['Const',2]],RET),depth(8))
                      -->(63,eval('&self',['Const',2],RET),depth(9))
                      <--(63,retval(['Const',2]))
                      -->(65,eval('&self',['Const',2],RET),depth(9))
                      <--(65,retval(['Const',2]))
                    <--(62,retval(['Fix',['Const',2]]))
                    -->(70,eval('&self',['Fix',['Var','X']],RET),depth(8))
                      -->(71,eval('&self',['Var','X'],RET),depth(9))
                      <--(71,retval(['Var','X']))
                      -->(73,eval('&self',['Var','X'],RET),depth(9))
                      <--(73,retval(['Var','X']))
                    <--(70,retval(['Fix',['Var','X']]))
                    -->(78,eval('&self',['Fix',['Const',2]],RET),depth(8))
                      -->(79,eval('&self',['Const',2],RET),depth(9))
                      <--(79,retval(['Const',2]))
                      -->(81,eval('&self',['Const',2],RET),depth(9))
                      <--(81,retval(['Const',2]))
                    <--(78,retval(['Fix',['Const',2]]))
                  <--(53,retval(['Plus',['Fix',['Var','X']],['Fix',['Const',2]]]))
                      -->(99,subst_args('&self',['Fix',['Plus',['Fix',['Var','X']],['Fix',['Const',2]]]],RET),depth(9))
; Switched off tracing. For a longer trace: !(pragma! trace-length 101)
                <--(6,retval(['Fix',['Plus',['Fix',['Var','X']],['Fix',['Const',2]]]]))
            <--(5,retval(['Plus',['Fix',['Plus',['Fix',['Var','X']],['Fix',['Const',2]]]],['Fix',['Const',40]]]))
          <--(2,retval(['Plus',2,40]))
      <--(1,retval(42))
; 
; EVAL TEST
; took 0.034 secs. (34.25 milliseconds) 
<span class="ansi31">(loonit_failureR 
  (equal_enough_for_test  
    (42) 
    ( (evalExpr 
        (mapExpr 
          (cata mapExpr evalExpr) 
          (unFix 
            (Fix 
              (Plus 
                (Fix 
                  (Plus 
                    (Fix 
                      (Var X)) 
                    (Fix 
                      (Const 2)))) 
                (Fix 
                  (Const 40))))))))))
</span>NDet Result(1): <span class="ansi33">
(got 
  (42) expected 
  (42))

</span>    <--(0,retval([got,[42],expected,[42]]))
;; How to generate the structure based on some value, a single step, a co-algebra
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[nTimes,[',',X,['S',['S',N]]]],['Plus',[',',X,['S','Z']],[',',X,['S',N]]]])
</span><span class="ansi38-255165000">(= 
  (nTimes 
    (, $X 
      (S 
        (S $N)))) 
  (Plus 
    (, $X 
      (S Z)) 
    (, $X 
      (S $N))))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[nTimes,[',',X,['S','Z']]],['Const',X]])
</span><span class="ansi38-255165000">(= 
  (nTimes 
    (, $X 
      (S Z))) 
  (Const $X))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[nTimes,[',',_,'Z']],['Const',0]])
</span><span class="ansi38-255165000">(= 
  (nTimes 
    (, $_ Z)) 
  (Const 0))
</span>

;; An unfold, with the Functor and co-algebra, applied to some seed value
<span class="ansi38-255165000">;; In file as:  
</span><span class="ansi1 ansi38-255238088">!((ana mapExpr nTimes) 
  (, 2 
    (S 
      (S Z))))
</span>;; To unit test case:
<span class="ansi38-013099040">!(assertEqualToResult 
  ( (ana mapExpr nTimes) 
    (, 2 
      (S 
        (S Z)))) 
  ( (Fix 
      (Plus 
        (Fix 
          (Const 2)) 
        (Fix 
          (Const 2))))))

</span><span class="ansi38-250144246">; !((ana mapExpr nTimes) (, 2 (S (S Z))))
</span><span class="ansi38-218112214">% DEBUG:   eval('&self',[[ana,mapExpr,nTimes],[',',2,['S',['S','Z']]]],OUT).

</span>    -->(0,eval('&self',[assertEqualToResult,[[ana,mapExpr,nTimes],[',',2,['S',['S','Z']]]],[['Fix',['Plus',['Fix',['Const',2]],['Fix',['Const',2]]]]]],RET),depth(0))
<h3 id="EXAMPLES.EXPRESSION.02">;; EXAMPLES.EXPRESSION.02</h3>
      -->(1,eval('&self',[[ana,mapExpr,nTimes],[',',2,['S',['S','Z']]]],RET),depth(1))
          -->(2,eval('&self',[mapExpr,[ana,mapExpr,nTimes],[nTimes,[',',2,['S',['S','Z']]]]],RET),depth(3))
            -->(3,eval('&self',[ana,mapExpr,nTimes],RET),depth(4))
                  -->(4,subst_args('&self',[ana,mapExpr,nTimes],RET),depth(7))
            <--(3,retval([ana,mapExpr,nTimes]))
            -->(5,eval('&self',[nTimes,[',',2,['S',['S','Z']]]],RET),depth(4))
                -->(6,eval('&self',[',',2,['S','Z']],RET),depth(6))
                  -->(7,eval('&self',['S','Z'],RET),depth(7))
                  <--(7,retval(['S','Z']))
                <--(6,retval('True'))
                -->(9,eval('&self',[',',2,['S','Z']],RET),depth(6))
                  -->(10,eval('&self',['S','Z'],RET),depth(7))
                  <--(10,retval(['S','Z']))
                <--(9,retval('True'))
                -->(12,eval('&self',[',',2,['S','Z']],RET),depth(6))
                  -->(13,eval('&self',['S','Z'],RET),depth(7))
                  <--(13,retval(['S','Z']))
                <--(12,retval('True'))
                -->(15,eval('&self',[',',2,['S','Z']],RET),depth(6))
                  -->(16,eval('&self',['S','Z'],RET),depth(7))
                  <--(16,retval(['S','Z']))
                <--(15,retval('True'))
                      -->(18,subst_args('&self',['Plus','True','True'],RET),depth(9))
                    -->(19,subst_args('&self',['Plus','True','True'],RET),depth(8))
                  -->(20,subst_args('&self',['Plus','True','True'],RET),depth(7))
                -->(21,eval('&self',[[ana,mapExpr,nTimes],'True'],RET),depth(6))
                    -->(22,eval('&self',[mapExpr,[ana,mapExpr,nTimes],[nTimes,'True']],RET),depth(8))
                      -->(23,eval('&self',[ana,mapExpr,nTimes],RET),depth(9))
                      <--(23,retval([ana,mapExpr,nTimes]))
                      -->(25,eval('&self',[nTimes,'True'],RET),depth(9))
                      <--(25,retval([nTimes,'True']))
                    <--(22,retval([mapExpr,[ana,mapExpr,nTimes],[nTimes,'True']]))
                    -->(30,eval('&self',[mapExpr,[ana,mapExpr,nTimes],[nTimes,'True']],RET),depth(8))
                      -->(31,eval('&self',[ana,mapExpr,nTimes],RET),depth(9))
                      <--(31,retval([ana,mapExpr,nTimes]))
                      -->(33,eval('&self',[nTimes,'True'],RET),depth(9))
                      <--(33,retval([nTimes,'True']))
                    <--(30,retval([mapExpr,[ana,mapExpr,nTimes],[nTimes,'True']]))
                      -->(45,subst_args('&self',['Fix',[mapExpr,[ana,mapExpr,nTimes],[nTimes,'True']]],RET),depth(9))
                -->(52,eval('&self',[[ana,mapExpr,nTimes],'True'],RET),depth(6))
                    -->(53,eval('&self',[mapExpr,[ana,mapExpr,nTimes],[nTimes,'True']],RET),depth(8))
                      -->(54,eval('&self',[ana,mapExpr,nTimes],RET),depth(9))
                      <--(54,retval([ana,mapExpr,nTimes]))
                      -->(56,eval('&self',[nTimes,'True'],RET),depth(9))
                      <--(56,retval([nTimes,'True']))
                    <--(53,retval([mapExpr,[ana,mapExpr,nTimes],[nTimes,'True']]))
                    -->(61,eval('&self',[mapExpr,[ana,mapExpr,nTimes],[nTimes,'True']],RET),depth(8))
                      -->(62,eval('&self',[ana,mapExpr,nTimes],RET),depth(9))
                      <--(62,retval([ana,mapExpr,nTimes]))
                      -->(64,eval('&self',[nTimes,'True'],RET),depth(9))
                      <--(64,retval([nTimes,'True']))
                    <--(61,retval([mapExpr,[ana,mapExpr,nTimes],[nTimes,'True']]))
                      -->(76,subst_args('&self',['Fix',[mapExpr,[ana,mapExpr,nTimes],[nTimes,'True']]],RET),depth(9))
                <--(52,retval(['Fix',[mapExpr,[ana,mapExpr,nTimes],[nTimes,'True']]]))
                <--(21,retval(['Fix',[mapExpr,[ana,mapExpr,nTimes],[nTimes,'True']]]))
                -->(83,eval('&self',[[ana,mapExpr,nTimes],'True'],RET),depth(6))
                    -->(84,eval('&self',[mapExpr,[ana,mapExpr,nTimes],[nTimes,'True']],RET),depth(8))
                      -->(85,eval('&self',[ana,mapExpr,nTimes],RET),depth(9))
                      <--(85,retval([ana,mapExpr,nTimes]))
                      -->(87,eval('&self',[nTimes,'True'],RET),depth(9))
                      <--(87,retval([nTimes,'True']))
                    <--(84,retval([mapExpr,[ana,mapExpr,nTimes],[nTimes,'True']]))
                    -->(92,eval('&self',[mapExpr,[ana,mapExpr,nTimes],[nTimes,'True']],RET),depth(8))
                      -->(93,eval('&self',[ana,mapExpr,nTimes],RET),depth(9))
                      <--(93,retval([ana,mapExpr,nTimes]))
                      -->(95,eval('&self',[nTimes,'True'],RET),depth(9))
                      <--(95,retval([nTimes,'True']))
                    <--(92,retval([mapExpr,[ana,mapExpr,nTimes],[nTimes,'True']]))
; Switched off tracing. For a longer trace: !(pragma! trace-length 101)
                <--(83,retval(['Fix',[mapExpr,[ana,mapExpr,nTimes],[nTimes,'True']]]))
            <--(5,retval(['Plus','True','True']))
          <--(2,retval(['Plus',['Fix',[mapExpr,[ana,mapExpr,nTimes],[nTimes,'True']]],['Fix',[mapExpr,[ana,mapExpr,nTimes],[nTimes,'True']]]]))
      <--(1,retval(['Fix',['Plus',['Fix',[mapExpr,[ana,mapExpr,nTimes],[nTimes,'True']]],['Fix',[mapExpr,[ana,mapExpr,nTimes],[nTimes,'True']]]]]))
; 
; EVAL TEST
; took 0.058 secs. (58.06 milliseconds) 
<span class="ansi31">(loonit_failureR 
  (equal_enough_for_test  
    ( (Fix 
        (Plus 
          (Fix 
            (mapExpr 
              (ana mapExpr nTimes) 
              (nTimes True))) 
          (Fix 
            (mapExpr 
              (ana mapExpr nTimes) 
              (nTimes True)))))) 
    ( (Fix 
        (Plus 
          (Fix 
            (Const 2)) 
          (Fix 
            (Const 2)))))))
</span>    <--(0,retval([got,[['Fix',['Plus',['Fix',[mapExpr,[ana,mapExpr,nTimes],[nTimes,'True']]],['Fix',[mapExpr,[ana,mapExpr,nTimes],[nTimes,'True']]]]]],expected,[['Fix',['Plus',['Fix',['Const',2]],['Fix',['Const',2]]]]]]))
Deterministic: <span class="ansi33">
(got 
  ( (Fix 
      (Plus 
        (Fix 
          (mapExpr 
            (ana mapExpr nTimes) 
            (nTimes True))) 
        (Fix 
          (mapExpr 
            (ana mapExpr nTimes) 
            (nTimes True)))))) expected 
  ( (Fix 
      (Plus 
        (Fix 
          (Const 2)) 
        (Fix 
          (Const 2))))))

</span>;; Combining both into a "re-fold", starting with a (co-algebra) seed value, ending with a (algebra) result value
<span class="ansi38-255165000">;; In file as:  
</span><span class="ansi1 ansi38-255238088">!((hylo mapExpr evalExpr nTimes) 
  (, 3 
    (S 
      (S 
        (S Z)))))
</span>;; To unit test case:
<span class="ansi38-013099040">!(assertEqualToResult 
  ( (hylo mapExpr evalExpr nTimes) 
    (, 3 
      (S 
        (S 
          (S Z))))) 
  (9))

</span><span class="ansi38-250144246">; !((hylo mapExpr evalExpr nTimes) (, 3 (S (S (S Z)))))
</span><span class="ansi38-218112214">% DEBUG:   eval('&self',[[hylo,mapExpr,evalExpr,nTimes],[',',3,['S',['S',['S','Z']]]]],OUT).

</span>    -->(0,eval('&self',[assertEqualToResult,[[hylo,mapExpr,evalExpr,nTimes],[',',3,['S',['S',['S','Z']]]]],[9]],RET),depth(0))
<h3 id="EXAMPLES.EXPRESSION.03">;; EXAMPLES.EXPRESSION.03</h3>
      -->(1,eval('&self',[[hylo,mapExpr,evalExpr,nTimes],[',',3,['S',['S',['S','Z']]]]],RET),depth(1))
          -->(2,eval('&self',[mapExpr,[hylo,mapExpr,evalExpr,nTimes],[nTimes,[',',3,['S',['S',['S','Z']]]]]],RET),depth(3))
            -->(3,eval('&self',[hylo,mapExpr,evalExpr,nTimes],RET),depth(4))
                  -->(4,subst_args('&self',[hylo,mapExpr,evalExpr,nTimes],RET),depth(7))
            <--(3,retval([hylo,mapExpr,evalExpr,nTimes]))
            -->(5,eval('&self',[nTimes,[',',3,['S',['S',['S','Z']]]]],RET),depth(4))
                -->(6,eval('&self',[',',3,['S','Z']],RET),depth(6))
                  -->(7,eval('&self',['S','Z'],RET),depth(7))
                  <--(7,retval(['S','Z']))
                <--(6,retval('True'))
                -->(9,eval('&self',[',',3,['S',['S','Z']]],RET),depth(6))
                  -->(10,eval('&self',['S',['S','Z']],RET),depth(7))
                    -->(11,eval('&self',['S','Z'],RET),depth(8))
                    <--(11,retval(['S','Z']))
                    -->(13,eval('&self',['S','Z'],RET),depth(8))
                    <--(13,retval(['S','Z']))
                    -->(15,eval('&self',['S','Z'],RET),depth(8))
                    <--(15,retval(['S','Z']))
                  <--(10,retval(['S',['S','Z']]))
                <--(9,retval('True'))
                -->(20,eval('&self',[',',3,['S','Z']],RET),depth(6))
                  -->(21,eval('&self',['S','Z'],RET),depth(7))
                  <--(21,retval(['S','Z']))
                <--(20,retval('True'))
                -->(23,eval('&self',[',',3,['S',['S','Z']]],RET),depth(6))
                  -->(24,eval('&self',['S',['S','Z']],RET),depth(7))
                    -->(25,eval('&self',['S','Z'],RET),depth(8))
                    <--(25,retval(['S','Z']))
                    -->(27,eval('&self',['S','Z'],RET),depth(8))
                    <--(27,retval(['S','Z']))
                    -->(29,eval('&self',['S','Z'],RET),depth(8))
                    <--(29,retval(['S','Z']))
                  <--(24,retval(['S',['S','Z']]))
                <--(23,retval('True'))
                      -->(34,subst_args('&self',['Plus','True','True'],RET),depth(9))
                    -->(35,subst_args('&self',['Plus','True','True'],RET),depth(8))
                  -->(36,subst_args('&self',['Plus','True','True'],RET),depth(7))
                -->(37,eval('&self',[[hylo,mapExpr,evalExpr,nTimes],'True'],RET),depth(6))
                    -->(38,eval('&self',[mapExpr,[hylo,mapExpr,evalExpr,nTimes],[nTimes,'True']],RET),depth(8))
                      -->(39,eval('&self',[hylo,mapExpr,evalExpr,nTimes],RET),depth(9))
                      <--(39,retval([hylo,mapExpr,evalExpr,nTimes]))
                      -->(41,eval('&self',[nTimes,'True'],RET),depth(9))
                      <--(41,retval([nTimes,'True']))
                    <--(38,retval([mapExpr,[hylo,mapExpr,evalExpr,nTimes],[nTimes,'True']]))
                      -->(50,subst_args('&self',[evalExpr,[mapExpr,[hylo,mapExpr,evalExpr,nTimes],[nTimes,'True']]],RET),depth(9))
                -->(54,eval('&self',[[hylo,mapExpr,evalExpr,nTimes],'True'],RET),depth(6))
                    -->(55,eval('&self',[mapExpr,[hylo,mapExpr,evalExpr,nTimes],[nTimes,'True']],RET),depth(8))
                      -->(56,eval('&self',[hylo,mapExpr,evalExpr,nTimes],RET),depth(9))
                      <--(56,retval([hylo,mapExpr,evalExpr,nTimes]))
                      -->(58,eval('&self',[nTimes,'True'],RET),depth(9))
                      <--(58,retval([nTimes,'True']))
                    <--(55,retval([mapExpr,[hylo,mapExpr,evalExpr,nTimes],[nTimes,'True']]))
                      -->(67,subst_args('&self',[evalExpr,[mapExpr,[hylo,mapExpr,evalExpr,nTimes],[nTimes,'True']]],RET),depth(9))
                <--(54,retval([evalExpr,[mapExpr,[hylo,mapExpr,evalExpr,nTimes],[nTimes,'True']]]))
                <--(37,retval([evalExpr,[mapExpr,[hylo,mapExpr,evalExpr,nTimes],[nTimes,'True']]]))
                -->(71,eval('&self',[[hylo,mapExpr,evalExpr,nTimes],'True'],RET),depth(6))
                    -->(72,eval('&self',[mapExpr,[hylo,mapExpr,evalExpr,nTimes],[nTimes,'True']],RET),depth(8))
                      -->(73,eval('&self',[hylo,mapExpr,evalExpr,nTimes],RET),depth(9))
                      <--(73,retval([hylo,mapExpr,evalExpr,nTimes]))
                      -->(75,eval('&self',[nTimes,'True'],RET),depth(9))
                      <--(75,retval([nTimes,'True']))
                    <--(72,retval([mapExpr,[hylo,mapExpr,evalExpr,nTimes],[nTimes,'True']]))
                      -->(84,subst_args('&self',[evalExpr,[mapExpr,[hylo,mapExpr,evalExpr,nTimes],[nTimes,'True']]],RET),depth(9))
                -->(88,eval('&self',[[hylo,mapExpr,evalExpr,nTimes],'True'],RET),depth(6))
                    -->(89,eval('&self',[mapExpr,[hylo,mapExpr,evalExpr,nTimes],[nTimes,'True']],RET),depth(8))
                      -->(90,eval('&self',[hylo,mapExpr,evalExpr,nTimes],RET),depth(9))
                      <--(90,retval([hylo,mapExpr,evalExpr,nTimes]))
                      -->(92,eval('&self',[nTimes,'True'],RET),depth(9))
                      <--(92,retval([nTimes,'True']))
                    <--(89,retval([mapExpr,[hylo,mapExpr,evalExpr,nTimes],[nTimes,'True']]))
; Switched off tracing. For a longer trace: !(pragma! trace-length 101)
                <--(88,retval([evalExpr,[mapExpr,[hylo,mapExpr,evalExpr,nTimes],[nTimes,'True']]]))
                <--(71,retval([evalExpr,[mapExpr,[hylo,mapExpr,evalExpr,nTimes],[nTimes,'True']]]))
            <--(5,retval(['Plus','True','True']))
          <--(2,retval(['Plus',[evalExpr,[mapExpr,[hylo,mapExpr,evalExpr,nTimes],[nTimes,'True']]],[evalExpr,[mapExpr,[hylo,mapExpr,evalExpr,nTimes],[nTimes,'True']]]]))
      <--(1,retval([+,[evalExpr,[mapExpr,[hylo,mapExpr,evalExpr,nTimes],[nTimes,'True']]],[evalExpr,[mapExpr,[hylo,mapExpr,evalExpr,nTimes],[nTimes,'True']]]]))
; 
; EVAL TEST
; took 0.037 secs. (37.04 milliseconds) 
<span class="ansi31">(loonit_failureR 
  (equal_enough_for_test  
    ( (+ 
        (evalExpr 
          (mapExpr 
            (hylo mapExpr evalExpr nTimes) 
            (nTimes True))) 
        (evalExpr 
          (mapExpr 
            (hylo mapExpr evalExpr nTimes) 
            (nTimes True))))) 
    (9)))
</span>    <--(0,retval([got,[[+,[evalExpr,[mapExpr,[hylo,mapExpr,evalExpr,nTimes],[nTimes,'True']]],[evalExpr,[mapExpr,[hylo,mapExpr,evalExpr,nTimes],[nTimes,'True']]]]],expected,[9]]))
Deterministic: <span class="ansi33">
(got 
  ( (+ 
      (evalExpr 
        (mapExpr 
          (hylo mapExpr evalExpr nTimes) 
          (nTimes True))) 
      (evalExpr 
        (mapExpr 
          (hylo mapExpr evalExpr nTimes) 
          (nTimes True))))) expected 
  (9))

</span>;; How to evaluate the structure, with access to the original expression (on top of the processed value)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[diff,['Const',_]],['Fix',['Const',0]]])
</span><span class="ansi38-255165000">(= 
  (diff 
    (Const $_)) 
  (Fix 
    (Const 0)))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[diff,['Var',_]],['Fix',['Const',1]]])
</span><span class="ansi38-255165000">(= 
  (diff 
    (Var $_)) 
  (Fix 
    (Const 1)))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[diff,['Plus',[',',Dx,X],[',',Dy,Y]]],['Fix',['Plus',Dx,Dy]]])
</span><span class="ansi38-255165000">(= 
  (diff 
    (Plus 
      (, $Dx $X) 
      (, $Dy $Y))) 
  (Fix 
    (Plus $Dx $Dy)))
</span>

;; (= (diff (Times (, $dx $x) (, $dy $y))) (Fix (Plus (Fix (Times $dx $y)) (Fix (Times $dy $x)))))
<span class="ansi38-255165000">;; In file as:  
</span><span class="ansi1 ansi38-255238088">!((para mapExpr diff) 
  (Fix 
    (Plus 
      (Fix 
        (Var X)) 
      (Fix 
        (Const 1)))))
</span>;; To unit test case:
<span class="ansi38-013099040">!(assertEqualToResult 
  ( (para mapExpr diff) 
    (Fix 
      (Plus 
        (Fix 
          (Var X)) 
        (Fix 
          (Const 1))))) 
  ( (diff 
      (mapExpr 
        (para_pair mapExpr diff) 
        (unFix 
          (Fix 
            (Plus 
              (Fix 
                (Var X)) 
              (Fix 
                (Const 1)))))))))

</span><span class="ansi38-250144246">; !((para mapExpr diff) (Fix (Plus (Fix (Var X)) (Fix (Const 1)))))
</span><span class="ansi38-218112214">% DEBUG:   eval('&self',[[para,mapExpr,diff],['Fix',['Plus',['Fix',['Var','X']],['Fix',['Const',1]]]]],OUT).

</span>    -->(0,eval('&self',[assertEqualToResult,[[para,mapExpr,diff],['Fix',['Plus',['Fix',['Var','X']],['Fix',['Const',1]]]]],[[diff,[mapExpr,[para_pair,mapExpr,diff],[unFix,['Fix',['Plus',['Fix',['Var','X']],['Fix',['Const',1]]]]]]]]],RET),depth(0))
<h3 id="EXAMPLES.EXPRESSION.04">;; EXAMPLES.EXPRESSION.04</h3>
      -->(1,eval('&self',[[para,mapExpr,diff],['Fix',['Plus',['Fix',['Var','X']],['Fix',['Const',1]]]]],RET),depth(1))
          -->(2,eval('&self',[mapExpr,[para_pair,mapExpr,diff],[unFix,['Fix',['Plus',['Fix',['Var','X']],['Fix',['Const',1]]]]]],RET),depth(3))
            -->(3,eval('&self',[para_pair,mapExpr,diff],RET),depth(4))
                  -->(4,subst_args('&self',[para_pair,mapExpr,diff],RET),depth(7))
            <--(3,retval([para_pair,mapExpr,diff]))
            -->(5,eval('&self',[unFix,['Fix',['Plus',['Fix',['Var','X']],['Fix',['Const',1]]]]],RET),depth(4))
                -->(6,eval('&self',['Fix',['Var','X']],RET),depth(6))
                  -->(7,eval('&self',['Var','X'],RET),depth(7))
                  <--(7,retval(['Var','X']))
                  -->(9,eval('&self',['Var','X'],RET),depth(7))
                  <--(9,retval(['Var','X']))
                      -->(11,subst_args('&self',['Fix',['Var','X']],RET),depth(9))
                <--(6,retval(['Fix',['Var','X']]))
                -->(14,eval('&self',['Fix',['Const',1]],RET),depth(6))
                  -->(15,eval('&self',['Const',1],RET),depth(7))
                  <--(15,retval(['Const',1]))
                  -->(17,eval('&self',['Const',1],RET),depth(7))
                  <--(17,retval(['Const',1]))
                      -->(19,subst_args('&self',['Fix',['Const',1]],RET),depth(9))
                <--(14,retval(['Fix',['Const',1]]))
                -->(22,eval('&self',['Fix',['Var','X']],RET),depth(6))
                  -->(23,eval('&self',['Var','X'],RET),depth(7))
                  <--(23,retval(['Var','X']))
                  -->(25,eval('&self',['Var','X'],RET),depth(7))
                  <--(25,retval(['Var','X']))
                      -->(27,subst_args('&self',['Fix',['Var','X']],RET),depth(9))
                <--(22,retval(['Fix',['Var','X']]))
                -->(30,eval('&self',['Fix',['Const',1]],RET),depth(6))
                  -->(31,eval('&self',['Const',1],RET),depth(7))
                  <--(31,retval(['Const',1]))
                  -->(33,eval('&self',['Const',1],RET),depth(7))
                  <--(33,retval(['Const',1]))
                      -->(35,subst_args('&self',['Fix',['Const',1]],RET),depth(9))
                <--(30,retval(['Fix',['Const',1]]))
                    -->(38,subst_args('&self',['Plus',['Fix',['Var','X']],['Fix',['Const',1]]],RET),depth(8))
                  -->(51,subst_args('&self',['Plus',['Fix',['Var','X']],['Fix',['Const',1]]],RET),depth(7))
                      -->(52,subst_args('&self',['Fix',['Var','X']],RET),depth(9))
                      -->(55,subst_args('&self',['Fix',['Const',1]],RET),depth(9))
                      -->(58,subst_args('&self',['Fix',['Var','X']],RET),depth(9))
                      -->(61,subst_args('&self',['Fix',['Const',1]],RET),depth(9))
                -->(64,eval('&self',[[para_pair,mapExpr,diff],['Fix',['Var','X']]],RET),depth(6))
                    -->(65,eval('&self',[[para,mapExpr,diff],['Fix',['Var','X']]],RET),depth(8))
                    -->(91,eval('&self',['Fix',['Var','X']],RET),depth(8))
                      -->(92,eval('&self',['Var','X'],RET),depth(9))
                      <--(92,retval(['Var','X']))
                      -->(94,eval('&self',['Var','X'],RET),depth(9))
                      <--(94,retval(['Var','X']))
                    <--(91,retval(['Fix',['Var','X']]))
                -->(99,eval('&self',[[para_pair,mapExpr,diff],['Fix',['Const',1]]],RET),depth(6))
                    -->(100,eval('&self',[[para,mapExpr,diff],['Fix',['Const',1]]],RET),depth(8))
; Switched off tracing. For a longer trace: !(pragma! trace-length 101)
                    <--(100,retval(['Fix',['Const',0]]))
                <--(99,retval('True'))
                    <--(65,retval(['Fix',['Const',1]]))
                <--(64,retval('True'))
            <--(5,retval(['Plus',['Fix',['Var','X']],['Fix',['Const',1]]]))
          <--(2,retval(['Plus','True','True']))
      <--(1,retval([diff,['Plus','True','True']]))
; 
; EVAL TEST
; took 0.017 secs. (16.58 milliseconds) 
<span class="ansi31">(loonit_failureR 
  (equal_enough_for_test  
    ( (diff 
        (Plus True True))) 
    ( (diff 
        (mapExpr 
          (para_pair mapExpr diff) 
          (unFix 
            (Fix 
              (Plus 
                (Fix 
                  (Var X)) 
                (Fix 
                  (Const 1))))))))))
</span>NDet Result(1): <span class="ansi33">
(got 
  ( (diff 
      (Plus True True))) expected 
  ( (diff 
      (Plus True True))))

</span>    <--(0,retval([got,[[diff,['Plus','True','True']]],expected,[[diff,['Plus','True','True']]]]))
;; Unfold shorthand definitions like "1p" for "1 + X" into a Bind-Pure tree of expressions
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[expand,[1,p,X]],['Plus',['Bind',['Const',1]],['Pure',X]]])
</span><span class="ansi38-255165000">(= 
  (expand 
    (1 p $X)) 
  (Plus 
    (Bind 
      (Const 1)) 
    (Pure $X)))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[expand,[2,t,X]],['Plus',['Pure',X],['Pure',X]]])
</span><span class="ansi38-255165000">(= 
  (expand 
    (2 t $X)) 
  (Plus 
    (Pure $X) 
    (Pure $X)))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=asserted_metta_atom('&self',[=,[expand,['Fix',X]],X])
</span><span class="ansi38-255165000">(= 
  (expand 
    (Fix $X)) $X)
</span>

;; Everything this can process
<span class="ansi38-255165000">;; In file as:  
</span><span class="ansi1 ansi38-255238088">!(match &self 
  (= 
    (expand $X) $Y) $X)
</span>;; To unit test case:
<span class="ansi38-013099040">!(assertEqualToResult 
  (match &self 
    (= 
      (expand $X) $Y) $X) 
  ( (Fix $Y) 
    (2 t $X_C35_534) 
    (1 p $X_C35_535)))

</span><span class="ansi38-250144246">; !(match &self (= (expand $X) $Y) $X)
</span><span class="ansi38-218112214">% DEBUG:   eval('&self',[match,'&self',[=,[expand,X],Y],X],OUT).

</span>    -->(0,eval('&self',[assertEqualToResult,[match,'&self',[=,[expand,_48128],_48412],_48128],[['Fix',_48412],[2,t,_49304],[1,p,_49660]]],RET),depth(0))
<h3 id="EXAMPLES.EXPRESSION.05">;; EXAMPLES.EXPRESSION.05</h3>
      -->(1,eval('&self',[match,'&self',[=,[expand,_48128],_48412],_48128],RET),depth(1))
              -->(2,subst_args('&self',[1,p,_61732],RET),depth(5))
            -->(3,subst_args('&self',[1,p,_61732],RET),depth(4))
              -->(4,subst_args('&self',[2,t,_63468],RET),depth(5))
            -->(5,subst_args('&self',[2,t,_63468],RET),depth(4))
              -->(6,subst_args('&self',['Fix',_2344],RET),depth(5))
            -->(7,subst_args('&self',['Fix',_2344],RET),depth(4))
      <--(1,retval(['Fix',_6240]))
; 
; EVAL TEST
; took 0.001 secs. (1.28 milliseconds) 
<span class="ansi36">(loonit_success 
  (equal_enough_for_test  
    ( (1 p $_2446) 
      (2 t $_2410) 
      (Fix $_2344)) 
    ( (1 p $_2446) 
      (2 t $_2410) 
      (Fix $_2344))))
</span>    <--(0,retval('Empty'))
Deterministic: <span class="ansi33">Empty

</span>;; Expand the definition
<span class="ansi38-255165000">;; In file as:  
</span><span class="ansi1 ansi38-255238088">!((futu mapExpr expand) 
  (2 t 
    (1 p 
      (Fix 
        (Var X)))))
</span>;; To unit test case:
<span class="ansi38-013099040">!(assertEqualToResult 
  ( (futu mapExpr expand) 
    (2 t 
      (1 p 
        (Fix 
          (Var X))))) 
  ( (Fix 
      (Plus 
        (Fix 
          (Plus 
            (Fix 
              (Const 1)) 
            (Fix 
              (Var X)))) 
        (Fix 
          (Plus 
            (Fix 
              (Const 1)) 
            (Fix 
              (Var X))))))))

</span><span class="ansi38-250144246">; !((futu mapExpr expand) (2 t (1 p (Fix (Var X)))))
</span><span class="ansi38-218112214">% DEBUG:   eval('&self',[[futu,mapExpr,expand],[2,t,[1,p,['Fix',['Var','X']]]]],OUT).

</span>    -->(0,eval('&self',[assertEqualToResult,[[futu,mapExpr,expand],[2,t,[1,p,['Fix',['Var','X']]]]],[['Fix',['Plus',['Fix',['Plus',['Fix',['Const',1]],['Fix',['Var','X']]]],['Fix',['Plus',['Fix',['Const',1]],['Fix',['Var','X']]]]]]]],RET),depth(0))
<h3 id="EXAMPLES.EXPRESSION.06">;; EXAMPLES.EXPRESSION.06</h3>
      -->(1,eval('&self',[[futu,mapExpr,expand],[2,t,[1,p,['Fix',['Var','X']]]]],RET),depth(1))
          -->(2,eval('&self',[mapExpr,[futu_picking,mapExpr,expand],[expand,[2,t,[1,p,['Fix',['Var','X']]]]]],RET),depth(3))
            -->(3,eval('&self',[futu_picking,mapExpr,expand],RET),depth(4))
                  -->(4,subst_args('&self',[futu_picking,mapExpr,expand],RET),depth(7))
            <--(3,retval([futu_picking,mapExpr,expand]))
            -->(5,eval('&self',[expand,[2,t,[1,p,['Fix',['Var','X']]]]],RET),depth(4))
                -->(6,eval('&self',['Pure',[1,p,['Fix',['Var','X']]]],RET),depth(6))
                  -->(7,eval('&self',[1,p,['Fix',['Var','X']]],RET),depth(7))
                    -->(8,eval('&self',['Fix',['Var','X']],RET),depth(8))
                      -->(9,eval('&self',['Var','X'],RET),depth(9))
                      <--(9,retval(['Var','X']))
                      -->(11,eval('&self',['Var','X'],RET),depth(9))
                      <--(11,retval(['Var','X']))
                    <--(8,retval(['Fix',['Var','X']]))
                    -->(16,eval('&self',['Fix',['Var','X']],RET),depth(8))
                      -->(17,eval('&self',['Var','X'],RET),depth(9))
                      <--(17,retval(['Var','X']))
                      -->(19,eval('&self',['Var','X'],RET),depth(9))
                      <--(19,retval(['Var','X']))
                    <--(16,retval(['Fix',['Var','X']]))
                  <--(7,retval([1,p,['Fix',['Var','X']]]))
                  -->(28,eval('&self',[1,p,['Fix',['Var','X']]],RET),depth(7))
                    -->(29,eval('&self',['Fix',['Var','X']],RET),depth(8))
                      -->(30,eval('&self',['Var','X'],RET),depth(9))
                      <--(30,retval(['Var','X']))
                      -->(32,eval('&self',['Var','X'],RET),depth(9))
                      <--(32,retval(['Var','X']))
                    <--(29,retval(['Fix',['Var','X']]))
                    -->(37,eval('&self',['Fix',['Var','X']],RET),depth(8))
                      -->(38,eval('&self',['Var','X'],RET),depth(9))
                      <--(38,retval(['Var','X']))
                      -->(40,eval('&self',['Var','X'],RET),depth(9))
                      <--(40,retval(['Var','X']))
                    <--(37,retval(['Fix',['Var','X']]))
                  <--(28,retval([1,p,['Fix',['Var','X']]]))
                      -->(49,subst_args('&self',['Pure',[1,p,['Fix',['Var','X']]]],RET),depth(9))
                <--(6,retval(['Pure',[1,p,['Fix',['Var','X']]]]))
                -->(58,eval('&self',['Pure',[1,p,['Fix',['Var','X']]]],RET),depth(6))
                  -->(59,eval('&self',[1,p,['Fix',['Var','X']]],RET),depth(7))
                    -->(60,eval('&self',['Fix',['Var','X']],RET),depth(8))
                      -->(61,eval('&self',['Var','X'],RET),depth(9))
                      <--(61,retval(['Var','X']))
                      -->(63,eval('&self',['Var','X'],RET),depth(9))
                      <--(63,retval(['Var','X']))
                    <--(60,retval(['Fix',['Var','X']]))
                    -->(68,eval('&self',['Fix',['Var','X']],RET),depth(8))
                      -->(69,eval('&self',['Var','X'],RET),depth(9))
                      <--(69,retval(['Var','X']))
                      -->(71,eval('&self',['Var','X'],RET),depth(9))
                      <--(71,retval(['Var','X']))
                    <--(68,retval(['Fix',['Var','X']]))
                  <--(59,retval([1,p,['Fix',['Var','X']]]))
                  -->(80,eval('&self',[1,p,['Fix',['Var','X']]],RET),depth(7))
                    -->(81,eval('&self',['Fix',['Var','X']],RET),depth(8))
                      -->(82,eval('&self',['Var','X'],RET),depth(9))
                      <--(82,retval(['Var','X']))
                      -->(84,eval('&self',['Var','X'],RET),depth(9))
                      <--(84,retval(['Var','X']))
                    <--(81,retval(['Fix',['Var','X']]))
                    -->(89,eval('&self',['Fix',['Var','X']],RET),depth(8))
                      -->(90,eval('&self',['Var','X'],RET),depth(9))
                      <--(90,retval(['Var','X']))
                      -->(92,eval('&self',['Var','X'],RET),depth(9))
                      <--(92,retval(['Var','X']))
                    <--(89,retval(['Fix',['Var','X']]))
                  <--(80,retval([1,p,['Fix',['Var','X']]]))
; Switched off tracing. For a longer trace: !(pragma! trace-length 101)
                <--(58,retval(['Pure',[1,p,['Fix',['Var','X']]]]))
            <--(5,retval(['Plus',['Pure',[1,p,['Fix',['Var','X']]]],['Pure',[1,p,['Fix',['Var','X']]]]]))
          <--(2,retval(['Plus',['Fix',['Plus',[[futu_picking,mapExpr,expand],['Bind',['Const',1]]],['Fix',['Var','X']]]],['Fix',['Plus',[[futu_picking,mapExpr,expand],['Bind',['Const',1]]],['Fix',['Var','X']]]]]))
      <--(1,retval(['Fix',['Plus',['Fix',['Plus',[[futu_picking,mapExpr,expand],['Bind',['Const',1]]],['Fix',['Var','X']]]],['Fix',['Plus',[[futu_picking,mapExpr,expand],['Bind',['Const',1]]],['Fix',['Var','X']]]]]]))
; 
; EVAL TEST
; took 0.593 secs. (592.78 milliseconds) 
<span class="ansi31">(loonit_failureR 
  (equal_enough_for_test  
    ( (Fix 
        (Plus 
          (Fix 
            (Plus 
              ( (futu_picking mapExpr expand) 
                (Bind 
                  (Const 1))) 
              (Fix 
                (Var X)))) 
          (Fix 
            (Plus 
              ( (futu_picking mapExpr expand) 
                (Bind 
                  (Const 1))) 
              (Fix 
                (Var X))))))) 
    ( (Fix 
        (Plus 
          (Fix 
            (Plus 
              (Fix 
                (Const 1)) 
              (Fix 
                (Var X)))) 
          (Fix 
            (Plus 
              (Fix 
                (Const 1)) 
              (Fix 
                (Var X)))))))))
</span>    <--(0,retval([got,[['Fix',['Plus',['Fix',['Plus',[[futu_picking,mapExpr,expand],['Bind',['Const',1]]],['Fix',['Var','X']]]],['Fix',['Plus',[[futu_picking,mapExpr,expand],['Bind',['Const',1]]],['Fix',['Var','X']]]]]]],expected,[['Fix',['Plus',['Fix',['Plus',['Fix',['Const',1]],['Fix',['Var','X']]]],['Fix',['Plus',['Fix',['Const',1]],['Fix',['Var','X']]]]]]]]))
Deterministic: <span class="ansi33">
(got 
  ( (Fix 
      (Plus 
        (Fix 
          (Plus 
            ( (futu_picking mapExpr expand) 
              (Bind 
                (Const 1))) 
            (Fix 
              (Var X)))) 
        (Fix 
          (Plus 
            ( (futu_picking mapExpr expand) 
              (Bind 
                (Const 1))) 
            (Fix 
              (Var X))))))) expected 
  ( (Fix 
      (Plus 
        (Fix 
          (Plus 
            (Fix 
              (Const 1)) 
            (Fix 
              (Var X)))) 
        (Fix 
          (Plus 
            (Fix 
              (Const 1)) 
            (Fix 
              (Var X))))))))

</span><span class="ansi32">% 6,883,442 inferences, 1.584 CPU in 1.585 seconds (100% CPU, 4344324 Lips)
</span> (= "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/extended_compat/metta-examples/recursion-schemes/src/examples/expression.metta" 0)
<span class="ansi1">LoonIt Report
</span>------------
<span class="ansi32">Successes: 1
</span><span class="ansi31">Failures: 5
</span><br/><a href="https://github.com/logicmoo/vspace-metta/blob/main/MeTTaLog.md">Return to Summaries</a><br/>
doing(ansi2html -u < "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/TEE_20231211101417_1046453_19564.ansi" > "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/extended_compat/metta-examples/recursion-schemes/src/examples/expression.metta.html" )

</pre>
</body>

</html>
