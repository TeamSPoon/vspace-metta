<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>
<style type="text/css">
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi35 { color: #E850A8; }
.ansi36 { color: #00aaaa; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content">
 (track_load_into_file "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-pln_metta/common/formula/DeductionFormulaTest.metta")
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-pln_metta/common/formula/DeductionFormulaTest.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-pln_metta/common/formula/DeductionFormulaTest.metta')
1=[()]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[max,X,Y],[if,[>,X,Y],X,Y])
</span><span class="ansi38-255165000">  (= 
    (max $X $Y) 
    (if 
      (> $X $Y) $X $Y))
</span>

2=[()]
3=[()]
;; Define min
4=[()]
5=[()]
6=[()]
7=[1]
8=[0.5555555555555556]
9=[False]
10=[0]
11=[True]
12=[True]
13=[(STV 0.9 0.1)]
14=4.21user 0.00system 0:04.22elapsed 100%CPU (0avgtext+0avgdata 36880maxresident)k
14=0inputs+0outputs (0major+4436minor)pagefaults 0swaps
:- dynamic file_answers/3.

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,min,[->,A,A,A]])
</span><span class="ansi38-255165000">  (: min 
    (-> $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[min,X,Y],[if,[<,X,Y],X,Y])
</span><span class="ansi38-255165000">  (= 
    (min $X $Y) 
    (if 
      (< $X $Y) $X $Y))
</span>

;; Clamp a number to be within a certain range
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,clamp,[->,A,A,A,A]])
</span><span class="ansi38-255165000">  (: clamp 
    (-> $A $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[clamp,X,L,U],[max,L,[min,U,X]])
</span><span class="ansi38-255165000">  (= 
    (clamp $X $L $U) 
    (max $L 
      (min $U $X)))
</span>

;; Define abs
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,abs,[->,A,A]])
</span><span class="ansi38-255165000">  (: abs 
    (-> $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[abs,X],[if,[<,X,0],[*,-1,X],X])
</span><span class="ansi38-255165000">  (= 
    (abs $X) 
    (if 
      (< $X 0) 
      (* -1 $X) $X))
</span>

;; Define <=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,<=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: <= 
    (-> $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[<=,X,Y],[or,[<,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">  (= 
    (<= $X $Y) 
    (or 
      (< $X $Y) 
      (== $X $Y)))
</span>

;; Define >=
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-pln_metta/common/formula/DeductionFormulaTest.metta', 1, [[]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-pln_metta/common/formula/DeductionFormulaTest.metta', 2, [[]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-pln_metta/common/formula/DeductionFormulaTest.metta', 3, [[]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-pln_metta/common/formula/DeductionFormulaTest.metta', 4, [[]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-pln_metta/common/formula/DeductionFormulaTest.metta', 5, [[]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-pln_metta/common/formula/DeductionFormulaTest.metta', 6, [[]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-pln_metta/common/formula/DeductionFormulaTest.metta', 7, [1]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-pln_metta/common/formula/DeductionFormulaTest.metta', 8, [0.5555555555555556]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-pln_metta/common/formula/DeductionFormulaTest.metta', 9, ['False']).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-pln_metta/common/formula/DeductionFormulaTest.metta', 10, [0]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-pln_metta/common/formula/DeductionFormulaTest.metta', 11, ['True']).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-pln_metta/common/formula/DeductionFormulaTest.metta', 12, ['True']).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-pln_metta/common/formula/DeductionFormulaTest.metta', 13, [['STV', 0.9, 0.1]]).

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,>=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: >= 
    (-> $A $A Bool))
</span>

<span class="ansi38-000068000">!(import! &self DeductionFormula.metta)

</span>    -->(0,'&self',['import!','&self','DeductionFormula.metta'],depth(0))
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-pln_metta/common/formula/DeductionFormula.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-pln_metta/common/formula/DeductionFormula.metta')
;;; Test
;;; Formula and other functions used for the deduction rule
;;; Import modules
<span class="ansi38-000068000">!(import! &self "../truthvalue/TruthValue.metta")

</span>    -->(1,'&self',['import!','&self','../truthvalue/TruthValue.metta'],depth(0))
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[>=,X,Y],[or,[>,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">  (= 
    (>= $X $Y) 
    (or 
      (> $X $Y) 
      (== $X $Y)))
</span>

;; Define approximately equal
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-pln_metta/common/truthvalue/TruthValue.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-pln_metta/common/truthvalue/TruthValue.metta')
;;; Truth value type definition
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,approxEq,[->,A,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: approxEq 
    (-> $A $A $A Bool))
</span>

;;; Import modules
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[approxEq,X,Y,Epsilon],[<=,[abs,[-,X,Y]],Epsilon])
</span><span class="ansi38-255165000">  (= 
    (approxEq $X $Y $Epsilon) 
    (<= 
      (abs 
        (- $X $Y)) $Epsilon))
</span>

;; Define Nat
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Nat','Type'])
</span><span class="ansi38-255165000">  (: Nat Type)
</span>

<span class="ansi38-000068000">!(import! &self "../Num.metta")

</span>    -->(2,'&self',['import!','&self','../Num.metta'],depth(0))
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Z','Nat'])
</span><span class="ansi38-255165000">  (: Z Nat)
</span>

%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-pln_metta/common/Num.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-pln_metta/common/Num.metta')
;;;;;;;;;;;
;;; Type ;;
;;;;;;;;;;;
;;; Collection of functions operating on numbers
;;; Define max
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'S',[->,'Nat','Nat']])
</span><span class="ansi38-255165000">  (: S 
    (-> Nat Nat))
</span>

;; Define cast functions between Nat and Number
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNumber,[->,'Number','Nat']])
</span><span class="ansi38-255165000">  (: fromNumber 
    (-> Number Nat))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,max,[[->,A,A,A]])
</span><span class="ansi38-255165000">(: max 
  (-> $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNumber,N],[if,[<=,N,0],'Z',['S',[fromNumber,[-,N,1]]]])
</span><span class="ansi38-255165000">  (= 
    (fromNumber $N) 
    (if 
      (<= $N 0) Z 
      (S 
        (fromNumber 
          (- $N 1)))))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[max,X,Y],[if,[>,X,Y],X,Y])
</span><span class="ansi38-255165000">(= 
  (max $X $Y) 
  (if 
    (> $X $Y) $X $Y))
</span>

;;; Define min
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNat,[->,'Nat','Number']])
</span><span class="ansi38-255165000">  (: fromNat 
    (-> Nat Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,min,[[->,A,A,A]])
</span><span class="ansi38-255165000">(: min 
  (-> $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,'Z'],0)
</span><span class="ansi38-255165000">  (= 
    (fromNat Z) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[min,X,Y],[if,[<,X,Y],X,Y])
</span><span class="ansi38-255165000">(= 
  (min $X $Y) 
  (if 
    (< $X $Y) $X $Y))
</span>

;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,['S',K]],[+,1,[fromNat,K]])
</span><span class="ansi38-255165000">  (= 
    (fromNat 
      (S $K)) 
    (+ 1 
      (fromNat $K)))
</span>

;; Define a generic less than operator, â©», for Nat.  < cannot be used
;; because it is a built-in, its type is hardwired and cannot be
;; overloaded.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Nat','Nat','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Nat Nat Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,clamp,[[->,A,A,A,A]])
</span><span class="ansi38-255165000">(: clamp 
  (-> $A $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',_,'Z'],'False')
</span><span class="ansi38-255165000">  (= 
    (â©» $_ Z) False)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»','Z',['S',_]],'True')
</span><span class="ansi38-255165000">  (= 
    (â©» Z 
      (S $_)) True)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[clamp,X,L,U],[max,L,[min,U,X]])
</span><span class="ansi38-255165000">(= 
  (clamp $X $L $U) 
  (max $L 
    (min $U $X)))
</span>

;;; Define abs
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',['S',X],['S',Y]],['â©»',X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» 
      (S $X) 
      (S $Y)) 
    (â©» $X $Y))
</span>

;; Overload â©» for Number.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,abs,[[->,A,A]])
</span><span class="ansi38-255165000">(: abs 
  (-> $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Number','Number','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Number Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',X,Y],[<,X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» $X $Y) 
    (< $X $Y))
</span>

;; Return the ceiling of a non negative number.  If the number is
;; negative it returns 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,ceil,[->,'Number','Number']])
</span><span class="ansi38-255165000">  (: ceil 
    (-> Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[abs,X],[if,[<,X,0],[*,-1,X],X])
</span><span class="ansi38-255165000">(= 
  (abs $X) 
  (if 
    (< $X 0) 
    (* -1 $X) $X))
</span>

;;; Define <=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,<=,[[->,A,A,'Bool']])
</span><span class="ansi38-255165000">(: <= 
  (-> $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[ceil,N],[fromNat,[fromNumber,N]])
</span><span class="ansi38-255165000">  (= 
    (ceil $N) 
    (fromNat 
      (fromNumber $N)))
</span>

;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'number->bool',[->,'Number','Bool']])
</span><span class="ansi38-255165000">  (: number->bool 
    (-> Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['number->bool',X],[<,0,X])
</span><span class="ansi38-255165000">  (= 
    (number->bool $X) 
    (< 0 $X))
</span>

;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[<=,X,Y],[or,[<,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">(= 
  (<= $X $Y) 
  (or 
    (< $X $Y) 
    (== $X $Y)))
</span>

;;; Define >=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'bool->number',[->,'Bool','Number']])
</span><span class="ansi38-255165000">  (: bool->number 
    (-> Bool Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','False'],0)
</span><span class="ansi38-255165000">  (= 
    (bool->number False) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,>=,[[->,A,A,'Bool']])
</span><span class="ansi38-255165000">(: >= 
  (-> $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','True'],1)
</span><span class="ansi38-255165000">  (= 
    (bool->number True) 1)
</span>

;; Define a less than type.  Note that it is purposefully different
;; than â©» as it is a type, not an operator.  Inhabitants of (â x y)
;; are proofs that x â©» y == True.  For now â is only axiomatized for
;; Nat.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â\x8D\\x83\',[->,True,True,'Type']])
</span><span class="ansi38-255165000">  (: â 
    (-> $True $True Type))
</span>

;; Zero is always less than the successor of something
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['zero-lt-succ-axiom'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[>=,X,Y],[or,[>,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">(= 
  (>= $X $Y) 
  (or 
    (> $X $Y) 
    (== $X $Y)))
</span>

;;; Define approximately equal
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['zero-lt-succ-axiom'],[:,'ZeroLTSucc',['â\x8D\\x83\','Z',['S',K]]])
</span><span class="ansi38-255165000">  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (â Z 
        (S $K))))
</span>

;; If x â y then (S x) â (S y)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['succ-monotonicity-rule'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['succ-monotonicity-rule'],[:,'SuccMonotonicity',[->,['â\x8D\\x83\',X,Y],['â\x8D\\x83\',['S',X],['S',Y]]]])
</span><span class="ansi38-255165000">  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (â $X $Y) 
        (â 
          (S $X) 
          (S $Y)))))
</span>

      <--(1,retval('Empty'))
<span class="ansi33"> Empty

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,approxEq,[[->,A,A,A,'Bool']])
</span><span class="ansi38-255165000">(: approxEq 
  (-> $A $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[approxEq,X,Y,Epsilon],[<=,[abs,[-,X,Y]],Epsilon])
</span><span class="ansi38-255165000">(= 
  (approxEq $X $Y $Epsilon) 
  (<= 
    (abs 
      (- $X $Y)) $Epsilon))
</span>

;;; Define Nat
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'Nat',['Type'])
</span><span class="ansi38-255165000">(: Nat Type)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'Z',['Nat'])
</span><span class="ansi38-255165000">(: Z Nat)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,synthesize,[->,'Atom',[->,'Atom'],[->,'Atom'],'Nat','Atom']])
</span><span class="ansi38-255165000">  (: synthesize 
    (-> Atom 
      (-> Atom) 
      (-> Atom) Nat Atom))
</span>

;; Nullary rule (axiom)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'S',[[->,'Nat','Nat']])
</span><span class="ansi38-255165000">(: S 
  (-> Nat Nat))
</span>

;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,fromNumber,[[->,'Number','Nat']])
</span><span class="ansi38-255165000">(: fromNumber 
  (-> Number Nat))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Kb,Rb,Depth],[let,Query,[Kb],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Kb $Rb $Depth) 
    (let $Query 
      ($Kb) $Query))
</span>

;; Unary rule
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[fromNumber,N],[if,[<=,N,0],'Z',['S',[fromNumber,[-,N,1]]]])
</span><span class="ansi38-255165000">(= 
  (fromNumber $N) 
  (if 
    (<= $N 0) Z 
    (S 
      (fromNumber 
        (- $N 1)))))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,fromNat,[[->,'Nat','Number']])
</span><span class="ansi38-255165000">(: fromNat 
  (-> Nat Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[fromNat,'Z'],0)
</span><span class="ansi38-255165000">(= 
  (fromNat Z) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[fromNat,['S',K]],[+,1,[fromNat,K]])
</span><span class="ansi38-255165000">(= 
  (fromNat 
    (S $K)) 
  (+ 1 
    (fromNat $K)))
</span>

;;; Define a generic less than operator, â©», for Nat.  < cannot be used
;;; because it is a built-in, its type is hardwired and cannot be
;;; overloaded.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'â©»',[[->,'Nat','Nat','Bool']])
</span><span class="ansi38-255165000">(: â©» 
  (-> Nat Nat Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Kb,Rb,['S',K]],['let*',[[[:,Ructor,[->,Premise,Conclusion]],[Rb]],[[:,[Ructor,Proof],Conclusion],Query],[[:,Proof,Premise],[synthesize,[:,Proof,Premise],Kb,Rb,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Kb $Rb 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise $Conclusion)) 
          ($Rb)) 
        ( (: 
            ($Ructor $Proof) $Conclusion) $Query) 
        ( (: $Proof $Premise) 
          (synthesize 
            (: $Proof $Premise) $Kb $Rb $K))) $Query))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['â©»',_,'Z'],'False')
</span><span class="ansi38-255165000">(= 
  (â©» $_ Z) False)
</span>

;; Binary rule
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['â©»','Z',['S',_]],'True')
</span><span class="ansi38-255165000">(= 
  (â©» Z 
    (S $_)) True)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['â©»',['S',X],['S',Y]],['â©»',X,Y])
</span><span class="ansi38-255165000">(= 
  (â©» 
    (S $X) 
    (S $Y)) 
  (â©» $X $Y))
</span>

;;; Overload â©» for Number.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'â©»',[[->,'Number','Number','Bool']])
</span><span class="ansi38-255165000">(: â©» 
  (-> Number Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['â©»',X,Y],[<,X,Y])
</span><span class="ansi38-255165000">(= 
  (â©» $X $Y) 
  (< $X $Y))
</span>

;;; Return the ceiling of a non negative number.  If the number is
;;; negative it returns 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,ceil,[[->,'Number','Number']])
</span><span class="ansi38-255165000">(: ceil 
  (-> Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[ceil,N],[fromNat,[fromNumber,N]])
</span><span class="ansi38-255165000">(= 
  (ceil $N) 
  (fromNat 
    (fromNumber $N)))
</span>

;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'number->bool',[[->,'Number','Bool']])
</span><span class="ansi38-255165000">(: number->bool 
  (-> Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['number->bool',X],[<,0,X])
</span><span class="ansi38-255165000">(= 
  (number->bool $X) 
  (< 0 $X))
</span>

;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Kb,Rb,['S',K]],['let*',[[[:,Ructor,[->,Premise1,Premise2,Conclusion]],[Rb]],[[:,[Ructor,Proof1,Proof2],Conclusion],Query],[[:,Proof1,Premise1],[synthesize,[:,Proof1,Premise1],Kb,Rb,K]],[[:,Proof2,Premise2],[synthesize,[:,Proof2,Premise2],Kb,Rb,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Kb $Rb 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise1 $Premise2 $Conclusion)) 
          ($Rb)) 
        ( (: 
            ($Ructor $Proof1 $Proof2) $Conclusion) $Query) 
        ( (: $Proof1 $Premise1) 
          (synthesize 
            (: $Proof1 $Premise1) $Kb $Rb $K)) 
        ( (: $Proof2 $Premise2) 
          (synthesize 
            (: $Proof2 $Premise2) $Kb $Rb $K))) $Query))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'bool->number',[[->,'Bool','Number']])
</span><span class="ansi38-255165000">(: bool->number 
  (-> Bool Number))
</span>

;; Trinary rule
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['bool->number','False'],0)
</span><span class="ansi38-255165000">(= 
  (bool->number False) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['bool->number','True'],1)
</span><span class="ansi38-255165000">(= 
  (bool->number True) 1)
</span>

;;; Define a less than type.  Note that it is purposefully different
;;; than â©» as it is a type, not an operator.  Inhabitants of (â x y)
;;; are proofs that x â©» y == True.  For now â is only axiomatized for
;;; Nat.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'â\x8D\\x83\',[[->,T,T,'Type']])
</span><span class="ansi38-255165000">(: â 
  (-> $T $T Type))
</span>

;;; Zero is always less than the successor of something
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,['zero-lt-succ-axiom'],[[->,'Atom']])
</span><span class="ansi38-255165000">(: 
  (zero-lt-succ-axiom) 
  (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['zero-lt-succ-axiom'],[:,'ZeroLTSucc',['â\x8D\\x83\','Z',['S',K]]])
</span><span class="ansi38-255165000">(= 
  (zero-lt-succ-axiom) 
  (: ZeroLTSucc 
    (â Z 
      (S $K))))
</span>

;;; If x â y then (S x) â (S y)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,['succ-monotonicity-rule'],[[->,'Atom']])
</span><span class="ansi38-255165000">(: 
  (succ-monotonicity-rule) 
  (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['succ-monotonicity-rule'],[:,'SuccMonotonicity',[->,['â\x8D\\x83\',X,Y],['â\x8D\\x83\',['S',X],['S',Y]]]])
</span><span class="ansi38-255165000">(= 
  (succ-monotonicity-rule) 
  (: SuccMonotonicity 
    (-> 
      (â $X $Y) 
      (â 
        (S $X) 
        (S $Y)))))
</span>

    <--(2,retval('Empty'))
      -->(2,'&self','Empty',depth(1))
; Evaluation took 266.68 milliseconds.
<span class="ansi33">Deterministic: Empty

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'TruthValue',['Type'])
</span><span class="ansi38-255165000">(: TruthValue Type)
</span>

;;;;;;;;;;;;;;;;;;;
;;; Constructors ;;
;;;;;;;;;;;;;;;;;;;
;;; Boolean TV constructor
;;; TODO: alternatively we could have (: â¤ TruthValue) and (: â¥ TruthValue)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Kb,Rb,['S',K]],['let*',[[[:,Ructor,[->,Premise1,Premise2,Premise3,Conclusion]],[Rb]],[[:,[Ructor,Proof1,Proof2,Proof3],Conclusion],Query],[[:,Proof1,Premise1],[synthesize,[:,Proof1,Premise1],Kb,Rb,K]],[[:,Proof2,Premise2],[synthesize,[:,Proof2,Premise2],Kb,Rb,K]],[[:,Proof3,Premise3],[synthesize,[:,Proof3,Premise3],Kb,Rb,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Kb $Rb 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise1 $Premise2 $Premise3 $Conclusion)) 
          ($Rb)) 
        ( (: 
            ($Ructor $Proof1 $Proof2 $Proof3) $Conclusion) $Query) 
        ( (: $Proof1 $Premise1) 
          (synthesize 
            (: $Proof1 $Premise1) $Kb $Rb $K)) 
        ( (: $Proof2 $Premise2) 
          (synthesize 
            (: $Proof2 $Premise2) $Kb $Rb $K)) 
        ( (: $Proof3 $Premise3) 
          (synthesize 
            (: $Proof3 $Premise3) $Kb $Rb $K))) $Query))
</span>

;; Quaternary rule
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'Bl',[[->,'Bool','TruthValue']])
</span><span class="ansi38-255165000">(: Bl 
  (-> Bool TruthValue))
</span>

;;; First order probability TV constructor, i.e. mere probability.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Kb,Rb,['S',K]],['let*',[[[:,Ructor,[->,Premise1,Premise2,Premise3,Premise4,Conclusion]],[Rb]],[[:,[Ructor,Proof1,Proof2,Proof3,Proof4],Conclusion],Query],[[:,Proof1,Premise1],[synthesize,[:,Proof1,Premise1],Kb,Rb,K]],[[:,Proof2,Premise2],[synthesize,[:,Proof2,Premise2],Kb,Rb,K]],[[:,Proof3,Premise3],[synthesize,[:,Proof3,Premise3],Kb,Rb,K]],[[:,Proof4,Premise4],[synthesize,[:,Proof4,Premise4],Kb,Rb,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Kb $Rb 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise1 $Premise2 $Premise3 $Premise4 $Conclusion)) 
          ($Rb)) 
        ( (: 
            ($Ructor $Proof1 $Proof2 $Proof3 $Proof4) $Conclusion) $Query) 
        ( (: $Proof1 $Premise1) 
          (synthesize 
            (: $Proof1 $Premise1) $Kb $Rb $K)) 
        ( (: $Proof2 $Premise2) 
          (synthesize 
            (: $Proof2 $Premise2) $Kb $Rb $K)) 
        ( (: $Proof3 $Premise3) 
          (synthesize 
            (: $Proof3 $Premise3) $Kb $Rb $K)) 
        ( (: $Proof4 $Premise4) 
          (synthesize 
            (: $Proof4 $Premise4) $Kb $Rb $K))) $Query))
</span>

;; Quintenary rule
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'Pr',[[->,'Number','TruthValue']])
</span><span class="ansi38-255165000">(: Pr 
  (-> Number TruthValue))
</span>

;;; Simple Truth Value.  A Second order probability TV constructor,
;;; i.e. probability and confidence.  The probability is in fact the
;;; mode of the corresponding beta distribution.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Kb,Rb,['S',K]],['let*',[[[:,Ructor,[->,Premise1,Premise2,Premise3,Premise4,Premise5,Conclusion]],[Rb]],[[:,[Ructor,Proof1,Proof2,Proof3,Proof4,Proof5],Conclusion],Query],[[:,Proof1,Premise1],[synthesize,[:,Proof1,Premise1],Kb,Rb,K]],[[:,Proof2,Premise2],[synthesize,[:,Proof2,Premise2],Kb,Rb,K]],[[:,Proof3,Premise3],[synthesize,[:,Proof3,Premise3],Kb,Rb,K]],[[:,Proof4,Premise4],[synthesize,[:,Proof4,Premise4],Kb,Rb,K]],[[:,Proof5,Premise5],[synthesize,[:,Proof5,Premise5],Kb,Rb,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Kb $Rb 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise1 $Premise2 $Premise3 $Premise4 $Premise5 $Conclusion)) 
          ($Rb)) 
        ( (: 
            ($Ructor $Proof1 $Proof2 $Proof3 $Proof4 $Proof5) $Conclusion) $Query) 
        ( (: $Proof1 $Premise1) 
          (synthesize 
            (: $Proof1 $Premise1) $Kb $Rb $K)) 
        ( (: $Proof2 $Premise2) 
          (synthesize 
            (: $Proof2 $Premise2) $Kb $Rb $K)) 
        ( (: $Proof3 $Premise3) 
          (synthesize 
            (: $Proof3 $Premise3) $Kb $Rb $K)) 
        ( (: $Proof4 $Premise4) 
          (synthesize 
            (: $Proof4 $Premise4) $Kb $Rb $K)) 
        ( (: $Proof5 $Premise5) 
          (synthesize 
            (: $Proof5 $Premise5) $Kb $Rb $K))) $Query))
</span>

      <--(0,retval('Empty'))
<span class="ansi33"> Empty

</span><span class="ansi38-000068000">!(import! &kb john-carry-flower.kif.metta)

</span>      -->(2,'&self',['import!','&kb','john-carry-flower.kif.metta'],depth(1))
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_1/hyperon-pln_metta/sumo/john-carry-flower/john-carry-flower-test.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_1/hyperon-pln_metta/sumo/john-carry-flower/john-carry-flower-test.metta')
;; Import rule base
;;; Auto-generated by suo-kif-to-metta.sh
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'STV',[[->,'Number','Number','TruthValue']])
</span><span class="ansi38-255165000">(: STV 
  (-> Number Number TruthValue))
</span>

;;;;;;;;;;;;;;;;
;;; Constants ;;
;;;;;;;;;;;;;;;;
;;; For now the underlying beta distributions have a Jeffreys prior,
;;; i.e. the prior alpha and beta are 0.5.
;; Self-contained SUO-KIF file extracted from
;;
;; https://github.com/ontologyportal/sumo/blob/master/Merge.kif
;;
;; containing knowledge about `objectTransferred`.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'prior-alpha',[[->,'Number']])
</span><span class="ansi38-255165000">(: prior-alpha 
  (-> Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',['â\x9F\¹',['â\x88\§',[subclass,X,Y],[instance,Z,X]],[instance,Z,Y]])
</span><span class="ansi38-255165000">  (â¹ 
    (â§ 
      (subclass $X $Y) 
      (instance $Z $X)) 
    (instance $Z $Y))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[instance,objectTransferred,'CaseRole'])
</span><span class="ansi38-255165000">  (instance objectTransferred CaseRole)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[subrelation,objectTransferred,patient])
</span><span class="ansi38-255165000">  (subrelation objectTransferred patient)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['prior-alpha'],0.5)
</span><span class="ansi38-255165000">(= 
  (prior-alpha) 0.5)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[domain,objectTransferred,1,'Transfer'])
</span><span class="ansi38-255165000">  (domain objectTransferred 1 Transfer)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[domain,objectTransferred,2,'Object'])
</span><span class="ansi38-255165000">  (domain objectTransferred 2 Object)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'prior-beta',[[->,'Number']])
</span><span class="ansi38-255165000">(: prior-beta 
  (-> Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[format,'EnglishLanguage',objectTransferred,"the object transferred in %1 is %n %2"])
</span><span class="ansi38-255165000">  (format EnglishLanguage objectTransferred "the object transferred in %1 is %n %2")
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['prior-beta'],0.5)
</span><span class="ansi38-255165000">(= 
  (prior-beta) 0.5)
</span>

;;; Lookahead
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,lookahead,[[->,'Number']])
</span><span class="ansi38-255165000">(: lookahead 
  (-> Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[documentation,objectTransferred,'EnglishLanguage',"A relation that specifies the object that\nis transferred during the process.  For example, in a &%Mailing process, the object\ntransferred is a letter or package."])
</span><span class="ansi38-255165000">  (documentation objectTransferred EnglishLanguage "A relation that specifies the object that\nis transferred during the process.  For example, in a &%Mailing process, the object\ntransferred is a letter or package.")
</span>

;; (â¹
;;   (objectTransferred $P $OBJ)
;;   (â ($O $D)
;;     (â§
;;       (origin $P $O)
;;       (destination $P $D)
;;       (holdsDuring
;;         (ImmediatePastFn $P)
;;         (located $OBJ $O))
;;       (holdsDuring
;;         (ImmediateFutureFn $P)
;;         (located $OBJ $D)))))
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[lookahead],1.0)
</span><span class="ansi38-255165000">(= 
  (lookahead) 1.0)
</span>

;;; Maximum supported count (till +inf is supported, possibly).
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',['â\x9F\¹',['â\x88\§',[instance,True,'Transfer'],[objectTransferred,True,O],[orientation,O2,O,'Inside']],[objectTransferred,True,O2]])
</span><span class="ansi38-255165000">  (â¹ 
    (â§ 
      (instance $True Transfer) 
      (objectTransferred $True $O) 
      (orientation $O2 $O Inside)) 
    (objectTransferred $True $O2))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'max-count',[[->,'Number']])
</span><span class="ansi38-255165000">(: max-count 
  (-> Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',['â\x9F\¹',['â\x88\§',[instance,True,'Transfer'],[objectTransferred,True,O],[orientation,O2,O,'On']],[objectTransferred,True,O2]])
</span><span class="ansi38-255165000">  (â¹ 
    (â§ 
      (instance $True Transfer) 
      (objectTransferred $True $O) 
      (orientation $O2 $O On)) 
    (objectTransferred $True $O2))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[subclass,'Carrying','Transfer'])
</span><span class="ansi38-255165000">  (subclass Carrying Transfer)
</span>

;; Add instances of `objectTransferred`, extracted from
;;
;; https://github.com/ontologyportal/sumo/blob/master/tests/SP04.kif.tq
;;
;; to test it.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[subclass,'Flower','PlantAnatomicalStructure'])
</span><span class="ansi38-255165000">  (subclass Flower PlantAnatomicalStructure)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[instance,'Inside','PositionalAttribute'])
</span><span class="ansi38-255165000">  (instance Inside PositionalAttribute)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[subclass,'Container','Object'])
</span><span class="ansi38-255165000">  (subclass Container Object)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[domain,objectTransferred,1,'Transfer'])
</span><span class="ansi38-255165000">  (domain objectTransferred 1 Transfer)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[domain,objectTransferred,2,'Object'])
</span><span class="ansi38-255165000">  (domain objectTransferred 2 Object)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[instance,objectTransferred,'CaseRole'])
</span><span class="ansi38-255165000">  (instance objectTransferred CaseRole)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[subrelation,objectTransferred,patient])
</span><span class="ansi38-255165000">  (subrelation objectTransferred patient)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[instance,'JohnsCarry','Carrying'])
</span><span class="ansi38-255165000">  (instance JohnsCarry Carrying)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[objectTransferred,'JohnsCarry','JohnsVase'])
</span><span class="ansi38-255165000">  (objectTransferred JohnsCarry JohnsVase)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[agent,'JohnsCarry','John'])
</span><span class="ansi38-255165000">  (agent JohnsCarry John)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[instance,'JohnsFlower','Flower'])
</span><span class="ansi38-255165000">  (instance JohnsFlower Flower)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[instance,'JohnsVase','Container'])
</span><span class="ansi38-255165000">  (instance JohnsVase Container)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[orientation,'JohnsFlower','JohnsVase','Inside'])
</span><span class="ansi38-255165000">  (orientation JohnsFlower JohnsVase Inside)
</span>

      <--(2,retval('Empty'))
<span class="ansi33"> Empty

</span>;; An example of query would be
;;
;; (query (â§ (instance $C Carrying) (agent $C John) (instance $F Flower) (objectTransferred $C $F)))
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['max-count'],1000000000.0)
</span><span class="ansi38-255165000">(= 
  (max-count) 1000000000.0)
</span>

;;;;;;;;;;;;;;
;;; Methods ;;
;;;;;;;;;;;;;;
;;; Convert count to confidence using the formula
;;;
;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'count->confidence',[[->,'Number','Number']])
</span><span class="ansi38-255165000">(: count->confidence 
  (-> Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['count->confidence',Cnt],[/,Cnt,[+,Cnt,[lookahead]]])
</span><span class="ansi38-255165000">(= 
  (count->confidence $Cnt) 
  ("/" $Cnt 
    (+ $Cnt 
      (lookahead))))
</span>

;;; Convert confidence to count using the formula
;;;
;;; count = (confidence * lookahead) / (1 - confidence)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'confidence->count',[[->,'Number','Number']])
</span><span class="ansi38-255165000">(: confidence->count 
  (-> Number Number))
</span>

<span class="ansi38-000068000">!(import! &rb "../rule-base.metta")

</span>      -->(3,'&self',['import!','&rb','../rule-base.metta'],depth(1))
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_1/hyperon-pln_metta/sumo/john-carry-flower/john-carry-flower-test.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_1/hyperon-pln_metta/sumo/john-carry-flower/john-carry-flower-test.metta')
;; Label each statement in the knowledge base as a witness of a type,
;; because that is what the synthesizer expects.  For now each witness
;; is defined by using the `WitnessOf` construct.  So for instance the
;; statement
;;
;; (instance A Object)
;;
;; has the corresponding witness
;;
;; (WitnessOf (instance A Object))
;;
;; Then add the labelled statement in the labelled-kb space.
;;; Inference rules to operate on SUMO
;; Binary Conjunction Introduction
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&rb',[:,'BinaryConjunctionIntroduction',[->,X,Y,['â\x88\§',X,Y]]])
</span><span class="ansi38-255165000">  (: BinaryConjunctionIntroduction 
    (-> $X $Y 
      (â§ $X $Y)))
</span>

;; Premises
;; Conclusion
;; Trinary Conjunction Introduction
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&rb',[:,'TrinaryConjunctionIntroduction',[->,X,Y,Z,['â\x88\§',X,Y,Z]]])
</span><span class="ansi38-255165000">  (: TrinaryConjunctionIntroduction 
    (-> $X $Y $Z 
      (â§ $X $Y $Z)))
</span>

;; Premises
;; Conclusion
;; Quaternary Conjunction Introduction
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&rb',[:,'QuaternaryConjunctionIntroduction',[->,X,Y,Z,W,['â\x88\§',X,Y,Z,W]]])
</span><span class="ansi38-255165000">  (: QuaternaryConjunctionIntroduction 
    (-> $X $Y $Z $W 
      (â§ $X $Y $Z $W)))
</span>

;; Premises
;; Conclusion
;; Modus Ponens
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&rb',[:,'ModusPonens',[->,['â\x9F\¹',X,Y],X,Y]])
</span><span class="ansi38-255165000">  (: ModusPonens 
    (-> 
      (â¹ $X $Y) $X $Y))
</span>

      <--(3,retval('Empty'))
<span class="ansi33"> Empty

</span>;; Premises
;; Conclusion
<span class="ansi38-000068000">!(bind! &labelled-kb 
  (new-space))

</span>      -->(4,'&self',['bind!','&labelled-kb',['new-space']],depth(1))
          -->(5,'&self',['new-space'],depth(3))
          <--(5,retval('Space'([])))
            -->(6,'&self','Space'([]),depth(4))
      <--(4,retval('Empty'))
<span class="ansi33"> Empty

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['confidence->count',Conf],[if,[approxEq,1.0,Conf,1.0e-9],['max-count'],[/,[*,Conf,[lookahead]],[-,1.0,Conf]]])
</span><span class="ansi38-255165000">(= 
  (confidence->count $Conf) 
  (if 
    (approxEq 1.0 $Conf 1.0e-9) 
    (max-count) 
    ("/" 
      (* $Conf 
        (lookahead)) 
      (- 1.0 $Conf))))
</span>

;;; Increment the negative count of a given truth value, by
;;; incrementing its total count without incrementing the positive
;;; count.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'inc-neg-count',[[->,'TruthValue','TruthValue']])
</span><span class="ansi38-255165000">(: inc-neg-count 
  (-> TruthValue TruthValue))
</span>

<span class="ansi38-000068000">!(match &kb $X 
  (add-atom &labelled-kb 
    (: 
      (WitnessOf $X) $X)))

</span>      -->(7,'&self',[match,'&kb',_82254,['add-atom','&labelled-kb',[:,['WitnessOf',_82254],_82254]]],depth(1))
      <--(7,retval(['add-atom','&labelled-kb',[:,['WitnessOf',[]],[]]]))
        -->(8,'&self',['add-atom','&labelled-kb',[:,['WitnessOf',[]],[]]],depth(2))
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&labelled-kb',[:,['WitnessOf',[]],[]])
</span><span class="ansi38-255165000">  (: 
    (WitnessOf ()) ())
</span>

        <--(8,retval('True'))
<span class="ansi33"> True
</span><span class="ansi32">['X'=[]]
</span>

<span class="ansi31">
! (assertEqualToResult 
    (match &kb $X 
      (add-atom &labelled-kb 
        (: 
          (WitnessOf $X) $X))) 
    (()))
(@ ! 
  (assertEqual 
    (True) 
    (())))
write_pass_fail_result("JOHN-CARRY-FLOWER.JOHN-CARRY-FLOWER-TEST.103",exec,[match,'&kb',X,['add-atom','&labelled-kb',[:,['WitnessOf',X],X]]],'FAIL',[[]],['True'])

</span>

--------------------------------------------------------------------------
;; Define knowledge base (called kb but different than &kb)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,kb,[->,'Atom']])
</span><span class="ansi38-255165000">  (: kb 
    (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[kb],[match,'&labelled-kb',X,X])
</span><span class="ansi38-255165000">  (= 
    (kb) 
    (match &labelled-kb $X $X))
</span>

;; Define rule base (called rb but different than &rb)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,rb,[->,'Atom']])
</span><span class="ansi38-255165000">  (: rb 
    (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['inc-neg-count',['STV',S,C]],['let*',[[Tot_cnt,['confidence->count',C]],[Pos_cnt,[*,S,Tot_cnt]],[New_tot_cnt,[+,Tot_cnt,1]]],['STV',[/,Pos_cnt,New_tot_cnt],['count->confidence',New_tot_cnt]]])
</span><span class="ansi38-255165000">(= 
  (inc-neg-count 
    (STV $S $C)) 
  (let* 
    ( ($Tot_cnt 
        (confidence->count $C)) 
      ($Pos_cnt 
        (* $S $Tot_cnt)) 
      ($New_tot_cnt 
        (+ $Tot_cnt 1))) 
    (STV 
      ("/" $Pos_cnt $New_tot_cnt) 
      (count->confidence $New_tot_cnt))))
</span>

;;; Increment the positive count of a given truth value, by
;;; incrementing its total count and its positive count.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'inc-pos-count',[[->,'TruthValue','TruthValue']])
</span><span class="ansi38-255165000">(: inc-pos-count 
  (-> TruthValue TruthValue))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['inc-pos-count',['STV',S,C]],['let*',[[Tot_cnt,['confidence->count',C]],[Pos_cnt,[*,S,Tot_cnt]],[New_pos_cnt,[+,Pos_cnt,1]],[New_tot_cnt,[+,Tot_cnt,1]]],['STV',[/,New_pos_cnt,New_tot_cnt],['count->confidence',New_tot_cnt]]])
</span><span class="ansi38-255165000">(= 
  (inc-pos-count 
    (STV $S $C)) 
  (let* 
    ( ($Tot_cnt 
        (confidence->count $C)) 
      ($Pos_cnt 
        (* $S $Tot_cnt)) 
      ($New_pos_cnt 
        (+ $Pos_cnt 1)) 
      ($New_tot_cnt 
        (+ $Tot_cnt 1))) 
    (STV 
      ("/" $New_pos_cnt $New_tot_cnt) 
      (count->confidence $New_tot_cnt))))
</span>

;;; Return the first order probability mode of the second order
;;; distribution associated to a truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,mode,[[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: mode 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[mode,['Bl','True']],1.0)
</span><span class="ansi38-255165000">(= 
  (mode 
    (Bl True)) 1.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[mode,['Bl','False']],0.0)
</span><span class="ansi38-255165000">(= 
  (mode 
    (Bl False)) 0.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[mode,['Pr',Pr]],Pr)
</span><span class="ansi38-255165000">(= 
  (mode 
    (Pr $Pr)) $Pr)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[mode,['STV',Pr,_]],Pr)
</span><span class="ansi38-255165000">(= 
  (mode 
    (STV $Pr $_)) $Pr)
</span>

;;; Return the total count of a truth value.  For truth values not
;;; capturing a notion of confidence, such as Bl or Pr then the count
;;; is assumed to be a very large number (cause +inf does not seem to
;;; be supported at the moment).
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,count,[[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: count 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[count,['Bl',_]],['max-count'])
</span><span class="ansi38-255165000">(= 
  (count 
    (Bl $_)) 
  (max-count))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[count,['Pr',_]],['max-count'])
</span><span class="ansi38-255165000">(= 
  (count 
    (Pr $_)) 
  (max-count))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[rb],[match,'&rb',X,X])
</span><span class="ansi38-255165000">  (= 
    (rb) 
    (match &rb $X $X))
</span>

;; ;; Call synthesizer on query (â§ (instance $C Carrying) (agent $C John))
;; !(synthesize (: $proof (â§ (instance $C Carrying) (agent $C John)))
;;              kb rb (fromNumber 1))
;; ;; Call synthesizer on query (â§ (instance $C Carrying) (agent $C John) (instance $F Flower))
;; !(synthesize (: $proof (â§ (instance $C Carrying) (agent $C John) (instance $F Flower)))
;;              kb rb (fromNumber 2))
;; Call synthesizer on query (instance JohnsCarry Transfer)
;;
;; Should synthesize the following proof tree
;;                                                              ----------------------------     ------------------------------
;;                                                              (subclass Carrying Transfer)     (instance JohnsCarry Carrying)
;;                                                              ---------------------------------------------------------------(BinaryConjunctionIntroduction)
;; (â¹ (â§ (subclass $X $Y) (instance $Z $X)) (instance $Z $Y))  (â§ (subclass Carrying Transfer) (instance JohnsCarry Carrying))
;; ----------------------------------------------------------------------------------------------------------------------------(ModusPonens)
;;                                             (instance JohnsCarry Transfer)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[count,['STV',_,Conf]],['confidence->count',Conf])
</span><span class="ansi38-255165000">(= 
  (count 
    (STV $_ $Conf)) 
  (confidence->count $Conf))
</span>

;;; Return the confidence of a truth value.  For truth values not
;;; capturing a notion of confidence, such as Bl or Pr then the
;;; confidence is assumed to be 1.0.  For truth values capturing a
;;; notion of confidence, such as STV, the formula to convert a count
;;; into confidence is as follows
;;;
;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,confidence,[[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: confidence 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[confidence,['Bl',_]],1.0)
</span><span class="ansi38-255165000">(= 
  (confidence 
    (Bl $_)) 1.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[confidence,['Pr',_]],1.0)
</span><span class="ansi38-255165000">(= 
  (confidence 
    (Pr $_)) 1.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[confidence,['STV',_,Conf]],Conf)
</span><span class="ansi38-255165000">(= 
  (confidence 
    (STV $_ $Conf)) $Conf)
</span>

;;; Return the positive count of a truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'pos-count',[[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: pos-count 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['pos-count',Tv],[*,[mode,Tv],[count,Tv]])
</span><span class="ansi38-255165000">(= 
  (pos-count $Tv) 
  (* 
    (mode $Tv) 
    (count $Tv)))
</span>

;;; Return the negative count of a truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'neg-count',[[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: neg-count 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['neg-count',Tv],[*,[-,1,[mode,Tv]],[count,Tv]])
</span><span class="ansi38-255165000">(= 
  (neg-count $Tv) 
  (* 
    (- 1 
      (mode $Tv)) 
    (count $Tv)))
</span>

;;; Return the posterior alpha of a truth value
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'post-alpha',[[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: post-alpha 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['post-alpha',Tv],[+,['prior-alpha'],['pos-count',Tv]])
</span><span class="ansi38-255165000">(= 
  (post-alpha $Tv) 
  (+ 
    (prior-alpha) 
    (pos-count $Tv)))
</span>

;;; Return the posterior beta of a truth value
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'post-beta',[[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: post-beta 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['post-beta',Tv],[+,['prior-beta'],['neg-count',Tv]])
</span><span class="ansi38-255165000">(= 
  (post-beta $Tv) 
  (+ 
    (prior-beta) 
    (neg-count $Tv)))
</span>

;;; Return the first order probability mean of the second order
;;; distribution associated to a truth value.  For truth values not
;;; capturing a notion of confidence, such as Bl or Pr then the
;;; confidence is assumed to be 1.0.  For truth values capturing a
;;; notion of confidence, such as STV, a beta distribution is assumed.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,mean,[[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">(: mean 
  (-> TruthValue Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[mean,['Bl','True']],1.0)
</span><span class="ansi38-255165000">(= 
  (mean 
    (Bl True)) 1.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[mean,['Bl','False']],0.0)
</span><span class="ansi38-255165000">(= 
  (mean 
    (Bl False)) 0.0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[mean,['Pr',Pr]],Pr)
</span><span class="ansi38-255165000">(= 
  (mean 
    (Pr $Pr)) $Pr)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[mean,['STV',Pr,Conf]],['let*',[[A,['post-alpha',['STV',Pr,Conf]]],[B,['post-beta',['STV',Pr,Conf]]]],[/,A,[+,A,B]]])
</span><span class="ansi38-255165000">(= 
  (mean 
    (STV $Pr $Conf)) 
  (let* 
    ( ($A 
        (post-alpha 
          (STV $Pr $Conf))) 
      ($B 
        (post-beta 
          (STV $Pr $Conf)))) 
    ("/" $A 
      (+ $A $B))))
</span>

    <--(1,retval('Empty'))
      -->(1,'&self','Empty',depth(1))
; Evaluation took 1004.31 milliseconds.
<span class="ansi33">Last Result(2): Empty

</span><span class="ansi38-000068000">!(import! &self "../Num.metta")

</span>    -->(0,'&self',['import!','&self','../Num.metta'],depth(0))
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-pln_metta/common/Num.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-pln_metta/common/Num.metta')
;; Consistency Conditions
;;; Collection of functions operating on numbers
;;; Define max
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,max,[[->,A,A,A]])
</span><span class="ansi38-255165000">(: max 
  (-> $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[max,X,Y],[if,[>,X,Y],X,Y])
</span><span class="ansi38-255165000">(= 
  (max $X $Y) 
  (if 
    (> $X $Y) $X $Y))
</span>

;;; Define min
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,min,[[->,A,A,A]])
</span><span class="ansi38-255165000">(: min 
  (-> $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[min,X,Y],[if,[<,X,Y],X,Y])
</span><span class="ansi38-255165000">(= 
  (min $X $Y) 
  (if 
    (< $X $Y) $X $Y))
</span>

;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,clamp,[[->,A,A,A,A]])
</span><span class="ansi38-255165000">(: clamp 
  (-> $A $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[clamp,X,L,U],[max,L,[min,U,X]])
</span><span class="ansi38-255165000">(= 
  (clamp $X $L $U) 
  (max $L 
    (min $U $X)))
</span>

;;; Define abs
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,abs,[[->,A,A]])
</span><span class="ansi38-255165000">(: abs 
  (-> $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[abs,X],[if,[<,X,0],[*,-1,X],X])
</span><span class="ansi38-255165000">(= 
  (abs $X) 
  (if 
    (< $X 0) 
    (* -1 $X) $X))
</span>

;;; Define <=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,<=,[[->,A,A,'Bool']])
</span><span class="ansi38-255165000">(: <= 
  (-> $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[<=,X,Y],[or,[<,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">(= 
  (<= $X $Y) 
  (or 
    (< $X $Y) 
    (== $X $Y)))
</span>

;;; Define >=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,>=,[[->,A,A,'Bool']])
</span><span class="ansi38-255165000">(: >= 
  (-> $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[>=,X,Y],[or,[>,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">(= 
  (>= $X $Y) 
  (or 
    (> $X $Y) 
    (== $X $Y)))
</span>

;;; Define approximately equal
<span class="ansi38-000068000">!(synthesize 
  (: $Proof 
    (instance JohnsCarry Transfer)) kb rb 
  (fromNumber 2))

</span>      -->(9,'&self',[synthesize,[:,_93674,[instance,'JohnsCarry','Transfer']],kb,rb,[fromNumber,2]],depth(1))
          -->(10,'&self',[instance,'JohnsCarry','Transfer'],depth(3))
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,approxEq,[[->,A,A,A,'Bool']])
</span><span class="ansi38-255165000">(: approxEq 
  (-> $A $A $A Bool))
</span>

        -->(11,'&self',[let,[:,_93674,[instance,'JohnsCarry','Transfer']],[kb],[:,_93674,[instance,'JohnsCarry','Transfer']]],depth(2))
            -->(12,'&self',[kb],depth(4))
              -->(13,'&self',[match,'&labelled-kb',_101406,_101406],depth(5))
              <--(13,retval([]))
            <--(12,retval([match,'&labelled-kb',_101496,_101496]))
        <--(11,retval(fail))
      <--(9,retval([let,[:,_100646,[instance,'JohnsCarry','Transfer']],[kb],[:,_100646,[instance,'JohnsCarry','Transfer']]]))
<span class="ansi31">
! (assertEqualToResult 
    (synthesize 
      (: $Proof 
        (instance JohnsCarry Transfer)) kb rb 
      (fromNumber 2)) 
    (()))
(@ ! 
  (assertEqual () 
    (())))
write_pass_fail_result("JOHN-CARRY-FLOWER.JOHN-CARRY-FLOWER-TEST.104",exec,[synthesize,[:,Proof,[instance,'JohnsCarry','Transfer']],kb,rb,[fromNumber,2]],'FAIL',[[]],[])

</span>

--------------------------------------------------------------------------
;; Call synthesizer on query (â§ (instance JohnsCarry Transfer) (objectTransferred JohnsCarry JohnsVase) (orientation JohnsFlower JohnsVase Inside))
;;
;; Should synthesize the following proof tree
;;
;;
;;                                                              ----------------------------     ------------------------------
;;                                                              (subclass Carrying Transfer)     (instance JohnsCarry Carrying)
;;                                                              ---------------------------------------------------------------(BinaryConjunctionIntroduction)
;; (â¹ (â§ (subclass $X $Y) (instance $Z $X)) (instance $Z $Y))  (â§ (subclass Carrying Transfer) (instance JohnsCarry Carrying))
;; ----------------------------------------------------------------------------------------------------------------------------(ModusPonens)   ----------------------------------------  ------------------------------------------
;;                                             (instance JohnsCarry Transfer)                                                                  (objectTransferred JohnsCarry JohnsVase)  (orientation JohnsFlower JohnsVase Inside)
;;                                             ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------(TrinaryConjunctionIntroduction)
;;                                                                       (â§ (instance JohnsCarry Transfer) (objectTransferred JohnsCarry JohnsVase) (orientation JohnsFlower JohnsVase Inside))
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[approxEq,X,Y,Epsilon],[<=,[abs,[-,X,Y]],Epsilon])
</span><span class="ansi38-255165000">(= 
  (approxEq $X $Y $Epsilon) 
  (<= 
    (abs 
      (- $X $Y)) $Epsilon))
</span>

;;; Define Nat
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'Nat',['Type'])
</span><span class="ansi38-255165000">(: Nat Type)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'Z',['Nat'])
</span><span class="ansi38-255165000">(: Z Nat)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'S',[[->,'Nat','Nat']])
</span><span class="ansi38-255165000">(: S 
  (-> Nat Nat))
</span>

;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,fromNumber,[[->,'Number','Nat']])
</span><span class="ansi38-255165000">(: fromNumber 
  (-> Number Nat))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[fromNumber,N],[if,[<=,N,0],'Z',['S',[fromNumber,[-,N,1]]]])
</span><span class="ansi38-255165000">(= 
  (fromNumber $N) 
  (if 
    (<= $N 0) Z 
    (S 
      (fromNumber 
        (- $N 1)))))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,fromNat,[[->,'Nat','Number']])
</span><span class="ansi38-255165000">(: fromNat 
  (-> Nat Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[fromNat,'Z'],0)
</span><span class="ansi38-255165000">(= 
  (fromNat Z) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[fromNat,['S',K]],[+,1,[fromNat,K]])
</span><span class="ansi38-255165000">(= 
  (fromNat 
    (S $K)) 
  (+ 1 
    (fromNat $K)))
</span>

;;; Define a generic less than operator, â©», for Nat.  < cannot be used
;;; because it is a built-in, its type is hardwired and cannot be
;;; overloaded.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'â©»',[[->,'Nat','Nat','Bool']])
</span><span class="ansi38-255165000">(: â©» 
  (-> Nat Nat Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['â©»',_,'Z'],'False')
</span><span class="ansi38-255165000">(= 
  (â©» $_ Z) False)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['â©»','Z',['S',_]],'True')
</span><span class="ansi38-255165000">(= 
  (â©» Z 
    (S $_)) True)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['â©»',['S',X],['S',Y]],['â©»',X,Y])
</span><span class="ansi38-255165000">(= 
  (â©» 
    (S $X) 
    (S $Y)) 
  (â©» $X $Y))
</span>

;;; Overload â©» for Number.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'â©»',[[->,'Number','Number','Bool']])
</span><span class="ansi38-255165000">(: â©» 
  (-> Number Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['â©»',X,Y],[<,X,Y])
</span><span class="ansi38-255165000">(= 
  (â©» $X $Y) 
  (< $X $Y))
</span>

;;; Return the ceiling of a non negative number.  If the number is
;;; negative it returns 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,ceil,[[->,'Number','Number']])
</span><span class="ansi38-255165000">(: ceil 
  (-> Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[ceil,N],[fromNat,[fromNumber,N]])
</span><span class="ansi38-255165000">(= 
  (ceil $N) 
  (fromNat 
    (fromNumber $N)))
</span>

;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'number->bool',[[->,'Number','Bool']])
</span><span class="ansi38-255165000">(: number->bool 
  (-> Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['number->bool',X],[<,0,X])
</span><span class="ansi38-255165000">(= 
  (number->bool $X) 
  (< 0 $X))
</span>

;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'bool->number',[[->,'Bool','Number']])
</span><span class="ansi38-255165000">(: bool->number 
  (-> Bool Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['bool->number','False'],0)
</span><span class="ansi38-255165000">(= 
  (bool->number False) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['bool->number','True'],1)
</span><span class="ansi38-255165000">(= 
  (bool->number True) 1)
</span>

;;; Define a less than type.  Note that it is purposefully different
;;; than â©» as it is a type, not an operator.  Inhabitants of (â x y)
;;; are proofs that x â©» y == True.  For now â is only axiomatized for
;;; Nat.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'â\x8D\\x83\',[[->,T,T,'Type']])
</span><span class="ansi38-255165000">(: â 
  (-> $T $T Type))
</span>

;;; Zero is always less than the successor of something
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,['zero-lt-succ-axiom'],[[->,'Atom']])
</span><span class="ansi38-255165000">(: 
  (zero-lt-succ-axiom) 
  (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['zero-lt-succ-axiom'],[:,'ZeroLTSucc',['â\x8D\\x83\','Z',['S',K]]])
</span><span class="ansi38-255165000">(= 
  (zero-lt-succ-axiom) 
  (: ZeroLTSucc 
    (â Z 
      (S $K))))
</span>

;;; If x â y then (S x) â (S y)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,['succ-monotonicity-rule'],[[->,'Atom']])
</span><span class="ansi38-255165000">(: 
  (succ-monotonicity-rule) 
  (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['succ-monotonicity-rule'],[:,'SuccMonotonicity',[->,['â\x8D\\x83\',X,Y],['â\x8D\\x83\',['S',X],['S',Y]]]])
</span><span class="ansi38-255165000">(= 
  (succ-monotonicity-rule) 
  (: SuccMonotonicity 
    (-> 
      (â $X $Y) 
      (â 
        (S $X) 
        (S $Y)))))
</span>

    <--(0,retval('Empty'))
      -->(0,'&self','Empty',depth(1))
<span class="ansi33">Deterministic: Empty

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'smallest-intersection-probability',[[->,'Number','Number','Number']])
</span><span class="ansi38-255165000">(: smallest-intersection-probability 
  (-> Number Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['smallest-intersection-probability',As,Bs],[clamp,[/,[-,[+,As,Bs],1],As],0,1])
</span><span class="ansi38-255165000">(= 
  (smallest-intersection-probability $As $Bs) 
  (clamp 
    ("/" 
      (- 
        (+ $As $Bs) 1) $As) 0 1))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'largest-intersection-probability',[[->,'Number','Number','Number']])
</span><span class="ansi38-255165000">(: largest-intersection-probability 
  (-> Number Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['largest-intersection-probability',As,Bs],[clamp,[/,Bs,As],0,1])
</span><span class="ansi38-255165000">(= 
  (largest-intersection-probability $As $Bs) 
  (clamp 
    ("/" $Bs $As) 0 1))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'conditional-probability-consistency',[[->,'Number','Number','Number','Bool']])
</span><span class="ansi38-255165000">(: conditional-probability-consistency 
  (-> Number Number Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['conditional-probability-consistency',As,Bs,ABs],[and,[<,0,As],[and,[<=,['smallest-intersection-probability',As,Bs],ABs],[<=,ABs,['largest-intersection-probability',As,Bs]]]])
</span><span class="ansi38-255165000">(= 
  (conditional-probability-consistency $As $Bs $ABs) 
  (and 
    (< 0 $As) 
    (and 
      (<= 
        (smallest-intersection-probability $As $Bs) $ABs) 
      (<= $ABs 
        (largest-intersection-probability $As $Bs)))))
</span>

;;; Main Formula
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'simple-deduction-strength-formula',[[->,'Number','Number','Number','Number','Number','Number']])
</span><span class="ansi38-255165000">(: simple-deduction-strength-formula 
  (-> Number Number Number Number Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['simple-deduction-strength-formula',As,Bs,Cs,ABs,BCs],[if,[and,['conditional-probability-consistency',As,Bs,ABs],['conditional-probability-consistency',Bs,Cs,BCs]],[if,[<,0.99,Bs],Cs,[+,[*,ABs,BCs],[/,[*,[-,1,ABs],[-,Cs,[*,Bs,BCs]]],[-,1,Bs]]]],0])
</span><span class="ansi38-255165000">(= 
  (simple-deduction-strength-formula $As $Bs $Cs $ABs $BCs) 
  (if 
    (and 
      (conditional-probability-consistency $As $Bs $ABs) 
      (conditional-probability-consistency $Bs $Cs $BCs)) 
    (if 
      (< 0.99 $Bs) $Cs 
      (+ 
        (* $ABs $BCs) 
        ("/" 
          (* 
            (- 1 $ABs) 
            (- $Cs 
              (* $Bs $BCs))) 
          (- 1 $Bs)))) 0))
</span>

;;; Preconditions are met
;;; sB tends to 1
;;; otherwise
;;; Preconditions are not met
;;; Alternate deduction formula hardwired for STV to make it faster.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['deduction-formula',['STV',Ps,Pc],['STV',Qs,Qc],['STV',Rs,Rc],['STV',PQs,PQc],['STV',QRs,QRc]],[if,[and,['conditional-probability-consistency',Ps,Qs,PQs],['conditional-probability-consistency',Qs,Rs,QRs]],['STV',[if,[<,0.9999,Qs],Rs,[+,[*,PQs,QRs],[/,[*,[-,1,PQs],[-,Rs,[*,Qs,QRs]]],[-,1,Qs]]]],[min,Pc,[min,Qc,[min,Rc,[min,PQc,QRc]]]]],['STV',1,0]])
</span><span class="ansi38-255165000">(= 
  (deduction-formula 
    (STV $Ps $Pc) 
    (STV $Qs $Qc) 
    (STV $Rs $Rc) 
    (STV $PQs $PQc) 
    (STV $QRs $QRc)) 
  (if 
    (and 
      (conditional-probability-consistency $Ps $Qs $PQs) 
      (conditional-probability-consistency $Qs $Rs $QRs)) 
    (STV 
      (if 
        (< 0.9999 $Qs) $Rs 
        (+ 
          (* $PQs $QRs) 
          ("/" 
            (* 
              (- 1 $PQs) 
              (- $Rs 
                (* $Qs $QRs))) 
            (- 1 $Qs)))) 
      (min $Pc 
        (min $Qc 
          (min $Rc 
            (min $PQc $QRc))))) 
    (STV 1 0)))
</span>

    <--(0,retval('Empty'))
      -->(0,'&self','Empty',depth(1))
; Evaluation took 1417.22 milliseconds.
<span class="ansi33">Last Result(2): Empty

</span>;;; Preconditions are met
;; avoid division by 0
;;; Qs tends to 1
;;; Otherwise
;;; Preconditions are not met
<span class="ansi38-000068000">!(synthesize 
  (: $Proof 
    (â§ 
      (instance JohnsCarry Transfer) 
      (objectTransferred JohnsCarry JohnsVase) 
      (orientation JohnsFlower JohnsVase Inside))) kb rb 
  (fromNumber 3))

</span>      -->(14,'&self',[synthesize,[:,_259404,['â\x88\§',[instance,'JohnsCarry','Transfer'],[objectTransferred,'JohnsCarry','JohnsVase'],[orientation,'JohnsFlower','JohnsVase','Inside']]],kb,rb,[fromNumber,3]],depth(1))
          -->(15,'&self',[instance,'JohnsCarry','Transfer'],depth(3))
<span class="ansi38-000068000">!(assertEqualToResult 
  (max 3 4) 
  (4))

</span>        -->(16,'&self',[let,[:,_259404,['â\x88\§',[instance,'JohnsCarry','Transfer'],[objectTransferred,'JohnsCarry','JohnsVase'],[orientation,'JohnsFlower','JohnsVase','Inside']]],[kb],[:,_259404,['â\x88\§',[instance,'JohnsCarry','Transfer'],[objectTransferred,'JohnsCarry','JohnsVase'],[orientation,'JohnsFlower','JohnsVase','Inside']]]],depth(2))
    -->(1,'&self',[assertEqualToResult,[max,3,4],[4]],depth(0))
            -->(17,'&self',[kb],depth(4))
<span class="ansi38-017068017">[assertEqualToResult,[max,3,4],[4]]
</span>              -->(18,'&self',[match,'&labelled-kb',_263992,_263992],depth(5))
              <--(18,retval([]))
<h3 id="FORMULA.DEDUCTIONFORMULATEST.01">;; FORMULA.DEDUCTIONFORMULATEST.01</h3>
            <--(17,retval([match,'&labelled-kb',_264082,_264082]))
        <--(16,retval(fail))
      <--(14,retval([let,[:,_263166,['â\x88\§',[instance,'JohnsCarry','Transfer'],[objectTransferred,'JohnsCarry','JohnsVase'],[orientation,'JohnsFlower','JohnsVase','Inside']]],[kb],[:,_263166,['â\x88\§',[instance,'JohnsCarry','Transfer'],[objectTransferred,'JohnsCarry','JohnsVase'],[orientation,'JohnsFlower','JohnsVase','Inside']]]]))
      -->(2,'&self',[max,3,4],depth(1))
        -->(3,'&self',[if,[>,3,4],3,4],depth(2))
          -->(4,'&self',[>,3,4],depth(3))
          <--(4,retval('False'))
        <--(3,retval(4))
          -->(3,'&self',4,depth(3))
      <--(2,retval([if,[>,3,4],3,4]))
; 
; EVAL TEST
; took 0.381 ms. (380.80 microseconds) 
<span class="ansi36">(loonit_success 
  (equal_enough_for_test  
    (4) 
    (4)))
</span>    <--(1,retval('Empty'))
      -->(1,'&self','Empty',depth(1))
<span class="ansi31">
! (assertEqualToResult 
    (synthesize 
      (: $Proof 
        (â§ 
          (instance JohnsCarry Transfer) 
          (objectTransferred JohnsCarry JohnsVase) 
          (orientation JohnsFlower JohnsVase Inside))) kb rb 
      (fromNumber 3)) 
    (() () () () () () () () () () () () () () () () () () () () () () ()))
(@ ! 
  (assertEqual () 
    (() () () () () () () () () () () () () () () () () () () () () () ())))
write_pass_fail_result("JOHN-CARRY-FLOWER.JOHN-CARRY-FLOWER-TEST.105",exec,[synthesize,[:,Proof,['â\x88\§',[instance,'JohnsCarry','Transfer'],[objectTransferred,'JohnsCarry','JohnsVase'],[orientation,'JohnsFlower','JohnsVase','Inside']]],kb,rb,[fromNumber,3]],'FAIL',[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],[])

</span><span class="ansi33">Deterministic: Empty

</span>

--------------------------------------------------------------------------
;; Call synthesizer on query (objectTransferred JohnsCarry JohnsFlower)
;;
;; Should synthesize the following proof tree
;;                                                                                                                                       ----------------------------     ------------------------------
;;                                                                                                                                       (subclass Carrying Transfer)     (instance JohnsCarry Carrying)
;;                                                                                                                                       ---------------------------------------------------------------(BinaryConjunctionIntroduction)
;;                                                                          (â¹ (â§ (subclass $X $Y) (instance $Z $X)) (instance $Z $Y))  (â§ (subclass Carrying Transfer) (instance JohnsCarry Carrying))
;;                                                                          ----------------------------------------------------------------------------------------------------------------------------(ModusPonens)   ----------------------------------------  ------------------------------------------
;;                                                                                                                      (instance JohnsCarry Transfer)                                                                  (objectTransferred JohnsCarry JohnsVase)  (orientation JohnsFlower JohnsVase Inside)
;; -----------------------------------------------------------------------------------------------------------------    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------(TrinaryConjunctionIntroduction)
;; (â¹ (â§ (instance $T Transfer) (objectTransferred $T $O) (orientation $O2 $O Inside)) (objectTransferred $T $O2))    (â§ (instance JohnsCarry Transfer) (objectTransferred JohnsCarry JohnsVase) (orientation JohnsFlower JohnsVase Inside))
;; ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------(ModusPonens)
;;                                                                                              (objectTransferred JohnsCarry JohnsFlower)
<span class="ansi38-000068000">!(assertEqualToResult 
  (min 3 4) 
  (3))

</span>    -->(2,'&self',[assertEqualToResult,[min,3,4],[3]],depth(0))
<span class="ansi38-017068017">[assertEqualToResult,[min,3,4],[3]]
</span><h3 id="FORMULA.DEDUCTIONFORMULATEST.02">;; FORMULA.DEDUCTIONFORMULATEST.02</h3>
      -->(3,'&self',[min,3,4],depth(1))
        -->(4,'&self',[if,[<,3,4],3,4],depth(2))
          -->(5,'&self',[<,3,4],depth(3))
          <--(5,retval('True'))
        <--(4,retval(3))
          -->(4,'&self',3,depth(3))
      <--(3,retval([if,[<,3,4],3,4]))
; 
; EVAL TEST
; took 0.435 ms. (435.20 microseconds) 
<span class="ansi36">(loonit_success 
  (equal_enough_for_test  
    (3) 
    (3)))
</span>    <--(2,retval('Empty'))
      -->(2,'&self','Empty',depth(1))
<span class="ansi33">Deterministic: Empty

</span><span class="ansi38-000068000">!(assertEqualToResult 
  (and True True) 
  (True))

</span>    -->(3,'&self',[assertEqualToResult,[and,'True','True'],['True']],depth(0))
<span class="ansi38-017068017">[assertEqualToResult,[and,'True','True'],['True']]
</span><h3 id="FORMULA.DEDUCTIONFORMULATEST.03">;; FORMULA.DEDUCTIONFORMULATEST.03</h3>
      -->(4,'&self',[and,'True','True'],depth(1))
      <--(4,retval('True'))
; 
; EVAL TEST
; took 0.142 ms. (141.90 microseconds) 
<span class="ansi36">(loonit_success 
  (equal_enough_for_test  
    (True) 
    (True)))
</span>    <--(3,retval('Empty'))
      -->(3,'&self','Empty',depth(1))
<span class="ansi33">Deterministic: Empty

</span><span class="ansi38-000068000">!(assertEqualToResult 
  (or True False) 
  (True))

</span>    -->(4,'&self',[assertEqualToResult,[or,'True','False'],['True']],depth(0))
<span class="ansi38-017068017">[assertEqualToResult,[or,'True','False'],['True']]
</span><h3 id="FORMULA.DEDUCTIONFORMULATEST.04">;; FORMULA.DEDUCTIONFORMULATEST.04</h3>
      -->(5,'&self',[or,'True','False'],depth(1))
      <--(5,retval('True'))
; 
; EVAL TEST
; took 0.133 ms. (132.90 microseconds) 
<span class="ansi36">(loonit_success 
  (equal_enough_for_test  
    (True) 
    (True)))
</span>    <--(4,retval('Empty'))
      -->(4,'&self','Empty',depth(1))
<span class="ansi33">Deterministic: Empty

</span><span class="ansi38-000068000">!(assertEqualToResult 
  (<= 5 4) 
  (False))

</span>    -->(5,'&self',[assertEqualToResult,[<=,5,4],['False']],depth(0))
<span class="ansi38-017068017">[assertEqualToResult,[<=,5,4],['False']]
</span><h3 id="FORMULA.DEDUCTIONFORMULATEST.05">;; FORMULA.DEDUCTIONFORMULATEST.05</h3>
      -->(6,'&self',[<=,5,4],depth(1))
      <--(6,retval('False'))
; 
; EVAL TEST
; took 0.152 ms. (152.40 microseconds) 
<span class="ansi36">(loonit_success 
  (equal_enough_for_test  
    (False) 
    (False)))
</span>    <--(5,retval('Empty'))
      -->(5,'&self','Empty',depth(1))
<span class="ansi33">Deterministic: Empty

</span><span class="ansi38-000068000">!(clamp 2 0 1)

</span>    -->(6,'&self',[clamp,2,0,1],depth(0))
      -->(7,'&self',[max,0,[min,1,2]],depth(1))
        -->(8,'&self',[if,[>,0,[min,1,2]],0,[min,1,2]],depth(2))
          -->(9,'&self',[>,0,[min,1,2]],depth(3))
          <--(9,retval(fail))
        <--(8,retval(fail))
      <--(7,retval([if,[>,0,[min,1,2]],0,[min,1,2]]))
    <--(6,retval([max,0,[min,1,2]]))
%~ error(existence_error(procedure,eval_args80/4),context(efbug/2,_412240))
no results<span class="ansi33"> $_401820

</span><span class="ansi38-000068000">!(smallest-intersection-probability 0.9 0.6)

</span>    -->(6,'&self',['smallest-intersection-probability',0.9,0.6],depth(0))
      -->(7,'&self',[clamp,[/,[-,[+,0.9,0.6],1],0.9],0,1],depth(1))
        -->(8,'&self',[max,0,[min,1,[/,[-,[+,0.9,0.6],1],0.9]]],depth(2))
          -->(9,'&self',[if,[>,0,[min,1,[/,[-,[+,0.9,0.6],1],0.9]]],0,[min,1,[/,[-,[+,0.9,0.6],1],0.9]]],depth(3))
            -->(10,'&self',[>,0,[min,1,[/,[-,[+,0.9,0.6],1],0.9]]],depth(4))
            <--(10,retval(fail))
          <--(9,retval(fail))
        <--(8,retval([if,[>,0,[min,1,[/,[-,[+,0.9,0.6],1],0.9]]],0,[min,1,[/,[-,[+,0.9,0.6],1],0.9]]]))
      <--(7,retval([max,0,[min,1,[/,[-,[+,0.9,0.6],1],0.9]]]))
    <--(6,retval([clamp,[/,[-,[+,0.9,0.6],1],0.9],0,1]))
%~ error(existence_error(procedure,eval_args80/4),context(efbug/2,_433348))
no results<span class="ansi33"> $_425202

</span><span class="ansi38-000068000">!(conditional-probability-consistency 0.9 0.6 0.5)

</span>    -->(6,'&self',['conditional-probability-consistency',0.9,0.6,0.5],depth(0))
      -->(7,'&self',[and,[<,0,0.9],[and,[<=,['smallest-intersection-probability',0.9,0.6],0.5],[<=,0.5,['largest-intersection-probability',0.9,0.6]]]],depth(1))
        -->(8,'&self',[<,0,0.9],depth(2))
        <--(8,retval('True'))
        -->(8,'&self',[and,[<=,['smallest-intersection-probability',0.9,0.6],0.5],[<=,0.5,['largest-intersection-probability',0.9,0.6]]],depth(2))
          -->(9,'&self',[<=,['smallest-intersection-probability',0.9,0.6],0.5],depth(3))
            -->(10,'&self',[or,[<,['smallest-intersection-probability',0.9,0.6],0.5],[==,['smallest-intersection-probability',0.9,0.6],0.5]],depth(4))
              -->(11,'&self',[<,['smallest-intersection-probability',0.9,0.6],0.5],depth(5))
              <--(11,retval(fail))
            <--(10,retval(fail))
          <--(9,retval([or,[<,['smallest-intersection-probability',0.9,0.6],0.5],[==,['smallest-intersection-probability',0.9,0.6],0.5]]))
        <--(8,retval('False'))
      <--(7,retval('False'))
<span class="ansi33">NDet Result(1): False

</span>More Solutions? <span class="ansi35"> l

</span>    <--(6,retval([and,[<,0,0.9],[and,[<=,['smallest-intersection-probability',0.9,0.6],0.5],[<=,0.5,['largest-intersection-probability',0.9,0.6]]]]))
<span class="ansi33"> $_446368

</span><span class="ansi38-000068000">!(simple-deduction-strength-formula 0.9 0.6 0.5 0.3 0.4)

</span>    -->(6,'&self',['simple-deduction-strength-formula',0.9,0.6,0.5,0.3,0.4],depth(0))
      -->(7,'&self',[if,[and,['conditional-probability-consistency',0.9,0.6,0.3],['conditional-probability-consistency',0.6,0.5,0.4]],[if,[<,0.99,0.6],0.5,[+,[*,0.3,0.4],[/,[*,[-,1,0.3],[-,0.5,[*,0.6,0.4]]],[-,1,0.6]]]],0],depth(1))
        -->(8,'&self',[and,['conditional-probability-consistency',0.9,0.6,0.3],['conditional-probability-consistency',0.6,0.5,0.4]],depth(2))
          -->(9,'&self',['conditional-probability-consistency',0.9,0.6,0.3],depth(3))
            -->(10,'&self',[and,[<,0,0.9],[and,[<=,['smallest-intersection-probability',0.9,0.6],0.3],[<=,0.3,['largest-intersection-probability',0.9,0.6]]]],depth(4))
              -->(11,'&self',[<,0,0.9],depth(5))
              <--(11,retval('True'))
              -->(11,'&self',[and,[<=,['smallest-intersection-probability',0.9,0.6],0.3],[<=,0.3,['largest-intersection-probability',0.9,0.6]]],depth(5))
                -->(12,'&self',[<=,['smallest-intersection-probability',0.9,0.6],0.3],depth(6))
                  -->(13,'&self',[or,[<,['smallest-intersection-probability',0.9,0.6],0.3],[==,['smallest-intersection-probability',0.9,0.6],0.3]],depth(7))
                    -->(14,'&self',[<,['smallest-intersection-probability',0.9,0.6],0.3],depth(8))
                    <--(14,retval(fail))
                  <--(13,retval(fail))
                <--(12,retval([or,[<,['smallest-intersection-probability',0.9,0.6],0.3],[==,['smallest-intersection-probability',0.9,0.6],0.3]]))
              <--(11,retval('False'))
            <--(10,retval('False'))
          <--(9,retval([and,[<,0,0.9],[and,[<=,['smallest-intersection-probability',0.9,0.6],0.3],[<=,0.3,['largest-intersection-probability',0.9,0.6]]]]))
        <--(8,retval('False'))
      <--(7,retval(0))
        -->(7,'&self',0,depth(2))
<span class="ansi33">NDet Result(1): 0

</span>More Solutions? <span class="ansi35"> l

</span>    <--(6,retval([if,[and,['conditional-probability-consistency',0.9,0.6,0.3],['conditional-probability-consistency',0.6,0.5,0.4]],[if,[<,0.99,0.6],0.5,[+,[*,0.3,0.4],[/,[*,[-,1,0.3],[-,0.5,[*,0.6,0.4]]],[-,1,0.6]]]],0]))
<span class="ansi33"> $_463796

</span><span class="ansi38-000068000">!(conditional-probability-consistency 0.2 0.3 1)

</span>    -->(6,'&self',['conditional-probability-consistency',0.2,0.3,1],depth(0))
      -->(7,'&self',[and,[<,0,0.2],[and,[<=,['smallest-intersection-probability',0.2,0.3],1],[<=,1,['largest-intersection-probability',0.2,0.3]]]],depth(1))
        -->(8,'&self',[<,0,0.2],depth(2))
        <--(8,retval('True'))
        -->(8,'&self',[and,[<=,['smallest-intersection-probability',0.2,0.3],1],[<=,1,['largest-intersection-probability',0.2,0.3]]],depth(2))
          -->(9,'&self',[<=,['smallest-intersection-probability',0.2,0.3],1],depth(3))
            -->(10,'&self',[or,[<,['smallest-intersection-probability',0.2,0.3],1],[==,['smallest-intersection-probability',0.2,0.3],1]],depth(4))
              -->(11,'&self',[<,['smallest-intersection-probability',0.2,0.3],1],depth(5))
              <--(11,retval(fail))
            <--(10,retval(fail))
          <--(9,retval([or,[<,['smallest-intersection-probability',0.2,0.3],1],[==,['smallest-intersection-probability',0.2,0.3],1]]))
        <--(8,retval('False'))
      <--(7,retval('False'))
<span class="ansi33">NDet Result(1): False

</span>More Solutions? <span class="ansi35"> l

</span>    <--(6,retval([and,[<,0,0.2],[and,[<=,['smallest-intersection-probability',0.2,0.3],1],[<=,1,['largest-intersection-probability',0.2,0.3]]]]))
<span class="ansi33"> $_483584

</span><span class="ansi38-000068000">!(conditional-probability-consistency 0.3 0.4 0.9)

</span>    -->(6,'&self',['conditional-probability-consistency',0.3,0.4,0.9],depth(0))
      -->(7,'&self',[and,[<,0,0.3],[and,[<=,['smallest-intersection-probability',0.3,0.4],0.9],[<=,0.9,['largest-intersection-probability',0.3,0.4]]]],depth(1))
        -->(8,'&self',[<,0,0.3],depth(2))
        <--(8,retval('True'))
        -->(8,'&self',[and,[<=,['smallest-intersection-probability',0.3,0.4],0.9],[<=,0.9,['largest-intersection-probability',0.3,0.4]]],depth(2))
          -->(9,'&self',[<=,['smallest-intersection-probability',0.3,0.4],0.9],depth(3))
            -->(10,'&self',[or,[<,['smallest-intersection-probability',0.3,0.4],0.9],[==,['smallest-intersection-probability',0.3,0.4],0.9]],depth(4))
              -->(11,'&self',[<,['smallest-intersection-probability',0.3,0.4],0.9],depth(5))
              <--(11,retval(fail))
            <--(10,retval(fail))
          <--(9,retval([or,[<,['smallest-intersection-probability',0.3,0.4],0.9],[==,['smallest-intersection-probability',0.3,0.4],0.9]]))
        <--(8,retval('False'))
      <--(7,retval('False'))
<span class="ansi33">NDet Result(1): False

</span>More Solutions? <span class="ansi35"> l

</span>    <--(6,retval([and,[<,0,0.3],[and,[<=,['smallest-intersection-probability',0.3,0.4],0.9],[<=,0.9,['largest-intersection-probability',0.3,0.4]]]]))
<span class="ansi33"> $_499780

</span><span class="ansi38-000068000">!(deduction-formula 
  (STV 0.2 0.3) 
  (STV 0.3 0.2) 
  (STV 0.4 0.1) 
  (STV 1 0.5) 
  (STV 0.9 0.7))

</span>    -->(6,'&self',['deduction-formula',['STV',0.2,0.3],['STV',0.3,0.2],['STV',0.4,0.1],['STV',1,0.5],['STV',0.9,0.7]],depth(0))
      -->(7,'&self',[if,[and,['conditional-probability-consistency',0.2,0.3,1],['conditional-probability-consistency',0.3,0.4,0.9]],['STV',[if,[<,0.9999,0.3],0.4,[+,[*,1,0.9],[/,[*,[-,1,1],[-,0.4,[*,0.3,0.9]]],[-,1,0.3]]]],[min,0.3,[min,0.2,[min,0.1,[min,0.5,0.7]]]]],['STV',1,0]],depth(1))
        -->(8,'&self',[and,['conditional-probability-consistency',0.2,0.3,1],['conditional-probability-consistency',0.3,0.4,0.9]],depth(2))
          -->(9,'&self',['conditional-probability-consistency',0.2,0.3,1],depth(3))
            -->(10,'&self',[and,[<,0,0.2],[and,[<=,['smallest-intersection-probability',0.2,0.3],1],[<=,1,['largest-intersection-probability',0.2,0.3]]]],depth(4))
              -->(11,'&self',[<,0,0.2],depth(5))
              <--(11,retval('True'))
              -->(11,'&self',[and,[<=,['smallest-intersection-probability',0.2,0.3],1],[<=,1,['largest-intersection-probability',0.2,0.3]]],depth(5))
                -->(12,'&self',[<=,['smallest-intersection-probability',0.2,0.3],1],depth(6))
                  -->(13,'&self',[or,[<,['smallest-intersection-probability',0.2,0.3],1],[==,['smallest-intersection-probability',0.2,0.3],1]],depth(7))
                    -->(14,'&self',[<,['smallest-intersection-probability',0.2,0.3],1],depth(8))
                    <--(14,retval(fail))
                  <--(13,retval(fail))
                <--(12,retval([or,[<,['smallest-intersection-probability',0.2,0.3],1],[==,['smallest-intersection-probability',0.2,0.3],1]]))
              <--(11,retval('False'))
            <--(10,retval('False'))
          <--(9,retval([and,[<,0,0.2],[and,[<=,['smallest-intersection-probability',0.2,0.3],1],[<=,1,['largest-intersection-probability',0.2,0.3]]]]))
        <--(8,retval('False'))
        -->(8,'&self',['STV',1,0],depth(2))
      <--(7,retval(['STV',1,0]))
        -->(7,'&self',['STV',1,0],depth(2))
<span class="ansi33">NDet Result(1): (STV 1 0)

</span>More Solutions? <span class="ansi35"> l

</span>    <--(6,retval([if,[and,['conditional-probability-consistency',0.2,0.3,1],['conditional-probability-consistency',0.3,0.4,0.9]],['STV',[if,[<,0.9999,0.3],0.4,[+,[*,1,0.9],[/,[*,[-,1,1],[-,0.4,[*,0.3,0.9]]],[-,1,0.3]]]],[min,0.3,[min,0.2,[min,0.1,[min,0.5,0.7]]]]],['STV',1,0]]))
<span class="ansi33"> $_1802

</span><span class="ansi32">% 1,327,556 inferences, 1.559 CPU in 1.559 seconds (100% CPU, 851503 Lips)
</span> (= "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-pln_metta/common/formula/DeductionFormulaTest.metta" 0)
<span class="ansi1">LoonIt Report
</span>------------
<span class="ansi32">Successes: 5
</span><span class="ansi32">Failures: 0
</span><br/><a href="https://github.com/logicmoo/vspace-metta/blob/main/MeTTaLog.md">Return to Summaries</a><br/>
doing(ansi2html -u < "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/TEE.ansi" > "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-pln_metta/common/formula/DeductionFormulaTest.html" )

</pre>
</body>

</html>
