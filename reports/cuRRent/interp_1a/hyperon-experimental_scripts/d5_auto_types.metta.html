<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>
<style type="text/css">
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi38-000068000 { color: #004400; }
.ansi38-216191216 { color: #D8BFD8; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-216191216 { color: #D8BFD8; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content">
 (@ track_load_into_file "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_00/hyperon-experimental_scripts/b1_equal_chain.metta")
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_00/hyperon-experimental_scripts/b1_equal_chain.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_00/hyperon-experimental_scripts/b1_equal_chain.metta')
1=[()]
2=[()]
3=[()]
4=[()]
5=[()]
6=[()]
7=0.12user 0.01system 0:00.14elapsed 100%CPU (0avgtext+0avgdata 33152maxresident)k
7=0inputs+0outputs (0major+3475minor)pagefaults 0swaps
<span class="ansi38-000068000">!(assertEqualToResult 
  (collapse 
    (+ 5 "S")) 
  ( ( (Error "S" BadType))))

</span>      -->(73,'&self',[assertEqualToResult,[collapse,[+,5,"S"]],[[['Error',"S",'BadType']]]],depth(1))
<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.D5-AUTO-TYPES.05">;; HYPERON-EXPERIMENTAL-SCRIPTS.D5-AUTO-TYPES.05</h3>
          -->(74,'&self',[collapse,[+,5,"S"]],depth(3))
              -->(75,'&self',[+,5,"S"],depth(5))
              <--(75,retval(88))
          <--(74,retval([88]))
            -->(76,'&self',[88],depth(4))
; 
; EVAL TEST
; took 0.000553 secs. (553.20 microseconds) 

!check_type (not considering this a failure)
<span class="ansi38-216191216">(@ loonit_failureR 
  (equal_enough_for_test  
    ( (88)) 
    ( ( (Error "S" BadType)))))
</span>      <--(73,retval([got,[[88]],expected,[[['Error',"S",'BadType']]]]))
        -->(77,'&self',[got,[[88]],expected,[[['Error',"S",'BadType']]]],depth(2))
            -->(78,'&self',[[88]],depth(4))
            -->(79,'&self',[[['Error',"S",'BadType']]],depth(4))
                -->(80,'&self',[['Error',"S",'BadType']],depth(6))
                    -->(81,'&self',['Error',"S",'BadType'],depth(8))
            -->(82,'&self',[[88]],depth(4))
            -->(83,'&self',[[['Error',"S",'BadType']]],depth(4))
                -->(84,'&self',[['Error',"S",'BadType']],depth(6))
                    -->(85,'&self',['Error',"S",'BadType'],depth(8))
<span class="ansi33">  (got 
    ( (88)) expected 
    ( ( (Error "S" BadType))))

</span>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; `match` does not perform type checking on its pattern,
; so it accepts a badly typed expression, which is expected.
; It can be useful to deal with "wrong" MeTTa programs on
; a meta-level in MeTTa itself, so this behavior of `match`
; allows us to write code that analyzes badly typed expressions
; within MeTTa (e.g. for self-reflective genetic programming).
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
:- dynamic file_answers/3.

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[match,'&self',[==,'SocratesIsHuman','SamIsMortal'],'Really?'])
</span><span class="ansi38-255165000">  (match &self 
    (== SocratesIsHuman SamIsMortal) Really?)
</span>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; internal call doesn't pass type check even if wrapped
; by a function with type parameter:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; let binds without type checking, but errors when used
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[let,X,[+,5,"S"],X])
</span><span class="ansi38-255165000">  (let $X 
    (+ 5 "S") $X)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,f,[->,True,'Number']])
</span><span class="ansi38-255165000">  (: f 
    (-> $True Number))
</span>

<span class="ansi38-000068000">!(assertEqualToResult 
  (f 
    (+ 5 "S")) 
  ( (Error "S" BadType)))

</span>      -->(86,'&self',[assertEqualToResult,[f,[+,5,"S"]],[['Error',"S",'BadType']]],depth(1))
<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.D5-AUTO-TYPES.06">;; HYPERON-EXPERIMENTAL-SCRIPTS.D5-AUTO-TYPES.06</h3>
          -->(87,'&self',[f,[+,5,"S"]],depth(3))
              -->(88,'&self',[+,5,"S"],depth(5))
              <--(88,retval(88))
          <--(87,retval([f,88]))
            -->(89,'&self',[f,88],depth(4))
; 
; EVAL TEST
; took 0.000670 secs. (669.70 microseconds) 

!check_type (not considering this a failure)
<span class="ansi38-216191216">(@ loonit_failureR 
  (equal_enough_for_test  
    ( (f 88)) 
    ( (Error "S" BadType))))
</span>      <--(86,retval([got,[[f,88]],expected,[['Error',"S",'BadType']]]))
        -->(90,'&self',[got,[[f,88]],expected,[['Error',"S",'BadType']]],depth(2))
            -->(91,'&self',[f,88],depth(4))
            -->(92,'&self',[[f,88]],depth(4))
                -->(93,'&self',[f,88],depth(6))
            -->(94,'&self',[['Error',"S",'BadType']],depth(4))
                -->(95,'&self',['Error',"S",'BadType'],depth(6))
            -->(96,'&self',[[f,88]],depth(4))
                -->(97,'&self',[f,88],depth(6))
            -->(98,'&self',[['Error',"S",'BadType']],depth(4))
                -->(99,'&self',['Error',"S",'BadType'],depth(6))
<span class="ansi33">  (got 
    ( (f 88)) expected 
    ( (Error "S" BadType)))

</span><span class="ansi32">% 417,735 inferences, 0.321 CPU in 0.321 seconds (100% CPU, 1302838 Lips)
</span> (@ = "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_1a/hyperon-experimental_scripts/d5_auto_types.metta" 0)
doing(ansi2html -u < "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/TEE.ansi" > "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_1a/hyperon-experimental_scripts/d5_auto_types.metta.html" )
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_00/hyperon-experimental_scripts/b1_equal_chain.metta', 1, [[]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_00/hyperon-experimental_scripts/b1_equal_chain.metta', 2, [[]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_00/hyperon-experimental_scripts/b1_equal_chain.metta', 3, [[]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_00/hyperon-experimental_scripts/b1_equal_chain.metta', 4, [[]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_00/hyperon-experimental_scripts/b1_equal_chain.metta', 5, [[]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_00/hyperon-experimental_scripts/b1_equal_chain.metta', 6, [[]]).

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; The equality sign is specially treated by the interpreter.
;; The evaluation of any (expr) in MeTTa is done via
;; constructing the following equality query:
;; (match &self (= (expr) $r) $r)
;; The result $r is recursively evaluated in the same way,
;; until the match is empty (when the equality match is
;; empty, the expression is evaluated to itself).
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[=,['I',X],X])
</span><span class="ansi38-255165000">  (= 
    (I $X) $X)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[=,[['K',X],Y],X])
</span><span class="ansi38-255165000">  (= 
    ( (K $X) $Y) $X)
</span>

;; Note that `(K $x)` is allowed here
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[=,['K',X,Y],X])
</span><span class="ansi38-255165000">  (= 
    (K $X $Y) $X)
</span>


</pre>
</body>

</html>
