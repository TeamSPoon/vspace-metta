<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>
<style type="text/css">
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi36 { color: #00aaaa; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content">
 (track_load_into_file "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-experimental_scripts/b2_backchain.metta")
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Z','Nat'])
</span><span class="ansi38-255165000">  (: Z Nat)
</span>

%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-experimental_scripts/b2_backchain.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-experimental_scripts/b2_backchain.metta')
1=[()]
2=[()]
3=[()]
4=[()]
5=[()]
6=0.14user 0.02system 0:00.17elapsed 99%CPU (0avgtext+0avgdata 33428maxresident)k
6=0inputs+0outputs (0major+3532minor)pagefaults 0swaps
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'S',[->,'Nat','Nat']])
</span><span class="ansi38-255165000">  (: S 
    (-> Nat Nat))
</span>

;; Define cast functions between Nat and Number
:- dynamic file_answers/3.

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNumber,[->,'Number','Nat']])
</span><span class="ansi38-255165000">  (: fromNumber 
    (-> Number Nat))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNumber,N],[if,[<=,N,0],'Z',['S',[fromNumber,[-,N,1]]]])
</span><span class="ansi38-255165000">  (= 
    (fromNumber $N) 
    (if 
      (<= $N 0) Z 
      (S 
        (fromNumber 
          (- $N 1)))))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNat,[->,'Nat','Number']])
</span><span class="ansi38-255165000">  (: fromNat 
    (-> Nat Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,'Z'],0)
</span><span class="ansi38-255165000">  (= 
    (fromNat Z) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,['S',K]],[+,1,[fromNat,K]])
</span><span class="ansi38-255165000">  (= 
    (fromNat 
      (S $K)) 
    (+ 1 
      (fromNat $K)))
</span>

;; Define a generic less than operator, â©», for Nat.  < cannot be used
;; because it is a built-in, its type is hardwired and cannot be
;; overloaded.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Nat','Nat','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Nat Nat Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',_,'Z'],'False')
</span><span class="ansi38-255165000">  (= 
    (â©» $_ Z) False)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»','Z',['S',_]],'True')
</span><span class="ansi38-255165000">  (= 
    (â©» Z 
      (S $_)) True)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',['S',X],['S',Y]],['â©»',X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» 
      (S $X) 
      (S $Y)) 
    (â©» $X $Y))
</span>

;; Overload â©» for Number.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Number','Number','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Number Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',X,Y],[<,X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» $X $Y) 
    (< $X $Y))
</span>

;; Return the ceiling of a non negative number.  If the number is
;; negative it returns 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,ceil,[->,'Number','Number']])
</span><span class="ansi38-255165000">  (: ceil 
    (-> Number Number))
</span>

file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-experimental_scripts/b2_backchain.metta', 1, [[]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-experimental_scripts/b2_backchain.metta', 2, [[]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-experimental_scripts/b2_backchain.metta', 3, [[]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-experimental_scripts/b2_backchain.metta', 4, [[]]).
file_answers('/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-experimental_scripts/b2_backchain.metta', 5, [[]]).

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; `match` can be used inside equalities, which is typically
;; used for querying and reasoning over declarative knowledge
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Fact
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[ceil,N],[fromNat,[fromNumber,N]])
</span><span class="ansi38-255165000">  (= 
    (ceil $N) 
    (fromNat 
      (fromNumber $N)))
</span>

;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self','Frog','Sam',[])
</span><span class="ansi38-255165000">(Frog Sam)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'number->bool',[->,'Number','Bool']])
</span><span class="ansi38-255165000">  (: number->bool 
    (-> Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['number->bool',X],[<,0,X])
</span><span class="ansi38-255165000">  (= 
    (number->bool $X) 
    (< 0 $X))
</span>

;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'bool->number',[->,'Bool','Number']])
</span><span class="ansi38-255165000">  (: bool->number 
    (-> Bool Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','False'],0)
</span><span class="ansi38-255165000">  (= 
    (bool->number False) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[frog,X],[match,'&self',['Frog',X],'T'])
</span><span class="ansi38-255165000">(= 
  (frog $X) 
  (match &self 
    (Frog $X) T))
</span>

;; `(Frog Sam)` is not reduced; it is just a declaration
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','True'],1)
</span><span class="ansi38-255165000">  (= 
    (bool->number True) 1)
</span>

;; Define a less than type.  Note that it is purposefully different
;; than â©» as it is a type, not an operator.  Inhabitants of (â x y)
;; are proofs that x â©» y == True.  For now â is only axiomatized for
;; Nat.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â\x8D\\x83\',[->,True,True,'Type']])
</span><span class="ansi38-255165000">  (: â 
    (-> $True $True Type))
</span>

;; Zero is always less than the successor of something
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['zero-lt-succ-axiom'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['zero-lt-succ-axiom'],[:,'ZeroLTSucc',['â\x8D\\x83\','Z',['S',K]]])
</span><span class="ansi38-255165000">  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (â Z 
        (S $K))))
</span>

;; If x â y then (S x) â (S y)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['succ-monotonicity-rule'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span>

<span class="ansi38-000068000">!(assertEqualToResult 
  (Frog Sam) 
  ( (Frog Sam)))

</span>    -->(0,'&self',[assertEqualToResult,['Frog','Sam'],[['Frog','Sam']]],depth(0))
<span class="ansi38-017068017">[assertEqualToResult,['Frog','Sam'],[['Frog','Sam']]]
</span><h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.B2-BACKCHAIN.01">;; HYPERON-EXPERIMENTAL-SCRIPTS.B2-BACKCHAIN.01</h3>
      -->(1,'&self',['Frog','Sam'],depth(1))
; 
; EVAL TEST
; took 0.161 ms. (160.60 microseconds) 
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['succ-monotonicity-rule'],[:,'SuccMonotonicity',[->,['â\x8D\\x83\',X,Y],['â\x8D\\x83\',['S',X],['S',Y]]]])
</span><span class="ansi38-255165000">  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (â $X $Y) 
        (â 
          (S $X) 
          (S $Y)))))
</span>

      <--(4,retval('Empty'))
<span class="ansi33"> Empty

</span><span class="ansi36">(loonit_success 
  (equal_enough_for_test  
    ( (Frog Sam)) 
    ( (Frog Sam))))
</span>    <--(0,retval('Empty'))
      -->(0,'&self','Empty',depth(1))
; Evaluation took 2.09 milliseconds.
<span class="ansi33">Deterministic: Empty

</span>;; `frog` uses this declaration
<span class="ansi38-000068000">!(assertEqual 
  (frog Sam) T)

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'smallest-intersection-probability',[->,'Number','Number','Number']])
</span><span class="ansi38-255165000">  (: smallest-intersection-probability 
    (-> Number Number Number))
</span>

    -->(0,'&self',[assertEqual,[frog,'Sam'],'T'],depth(0))
<span class="ansi38-017068017">[assertEqual,[frog,'Sam'],'T']
</span><h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.B2-BACKCHAIN.02">;; HYPERON-EXPERIMENTAL-SCRIPTS.B2-BACKCHAIN.02</h3>
      -->(1,'&self',[frog,'Sam'],depth(1))
        -->(2,'&self',[match,'&self',['Frog','Sam'],'T'],depth(2))
          -->(3,'&self','T',depth(3))
        <--(2,retval('T'))
      <--(1,retval([match,'&self',['Frog','Sam'],'T']))
; 
; EVAL TEST
; took 0.372 ms. (371.60 microseconds) 
<span class="ansi36">(loonit_success 
  (equal_enough_for_test  
    (T) 
    (T)))
</span>    <--(0,retval('Empty'))
      -->(0,'&self','Empty',depth(1))
<span class="ansi33">Deterministic: Empty

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['smallest-intersection-probability',As,Bs],[clamp,[/,[-,[+,As,Bs],1],As],0,1])
</span><span class="ansi38-255165000">  (= 
    (smallest-intersection-probability $As $Bs) 
    (clamp 
      (/ 
        (- 
          (+ $As $Bs) 1) $As) 0 1))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'largest-intersection-probability',[->,'Number','Number','Number']])
</span><span class="ansi38-255165000">  (: largest-intersection-probability 
    (-> Number Number Number))
</span>

<span class="ansi38-000068000">!(assertEqualToResult 
  (frog Fritz) ())

</span>    -->(1,'&self',[assertEqualToResult,[frog,'Fritz'],[]],depth(0))
<span class="ansi38-017068017">[assertEqualToResult,[frog,'Fritz'],[]]
</span><h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.B2-BACKCHAIN.03">;; HYPERON-EXPERIMENTAL-SCRIPTS.B2-BACKCHAIN.03</h3>
      -->(2,'&self',[frog,'Fritz'],depth(1))
        -->(3,'&self',[match,'&self',['Frog','Fritz'],'T'],depth(2))
        <--(3,retval(fail))
      <--(2,retval([match,'&self',['Frog','Fritz'],'T']))
; 
; EVAL TEST
; took 0.223 ms. (222.90 microseconds) 
<span class="ansi36">(loonit_success 
  (equal_enough_for_test  () ()))
</span>    <--(1,retval('Empty'))
      -->(1,'&self','Empty',depth(1))
<span class="ansi33">Deterministic: Empty

</span>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; The result of matching is also chained
;; Example from OpenCog Classic wiki on PLN Backward Chaining
;; `And` and `T` are custom symbols (they are used here
;; to avoid mixing them up with symbols from common lib)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Some facts in the knowledge base
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self','Evaluation',[philosopher,'Plato'],[])
</span><span class="ansi38-255165000">(Evaluation 
  (philosopher Plato))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['largest-intersection-probability',As,Bs],[clamp,[/,Bs,As],0,1])
</span><span class="ansi38-255165000">  (= 
    (largest-intersection-probability $As $Bs) 
    (clamp 
      (/ $Bs $As) 0 1))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self','Evaluation',['likes-to-wrestle','Plato'],[])
</span><span class="ansi38-255165000">(Evaluation 
  (likes-to-wrestle Plato))
</span>

;; An implication rule
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'conditional-probability-consistency',[->,'Number','Number','Number','Bool']])
</span><span class="ansi38-255165000">  (: conditional-probability-consistency 
    (-> Number Number Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self','Implication',['And',['Evaluation',[philosopher,X]],['Evaluation',['likes-to-wrestle',X]]],[['Evaluation',[human,X]]])
</span><span class="ansi38-255165000">(Implication 
  (And 
    (Evaluation 
      (philosopher $X)) 
    (Evaluation 
      (likes-to-wrestle $X))) 
  (Evaluation 
    (human $X)))
</span>

;; Another implication rule
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self','Implication',['Evaluation',[human,X]],[['Evaluation',[mortal,X]]])
</span><span class="ansi38-255165000">(Implication 
  (Evaluation 
    (human $X)) 
  (Evaluation 
    (mortal $X)))
</span>

;; Deduction case when the desired evaluation is present in
;; the knowledge base
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['conditional-probability-consistency',As,Bs,ABs],[and,[<,0,As],[and,[<=,['smallest-intersection-probability',As,Bs],ABs],[<=,ABs,['largest-intersection-probability',As,Bs]]]])
</span><span class="ansi38-255165000">  (= 
    (conditional-probability-consistency $As $Bs $ABs) 
    (and 
      (< 0 $As) 
      (and 
        (<= 
          (smallest-intersection-probability $As $Bs) $ABs) 
        (<= $ABs 
          (largest-intersection-probability $As $Bs)))))
</span>

;; Main Formula
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'simple-deduction-strength-formula',[->,'Number','Number','Number','Number','Number','Number']])
</span><span class="ansi38-255165000">  (: simple-deduction-strength-formula 
    (-> Number Number Number Number Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[deduce,['Evaluation',[P,X]]],[match,'&self',['Evaluation',[P,X]],'T'])
</span><span class="ansi38-255165000">(= 
  (deduce 
    (Evaluation 
      ($P $X))) 
  (match &self 
    (Evaluation 
      ($P $X)) T))
</span>

;; Deduction case when the desired evaluation is the result
;; of an implication, which implies a recursion
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[deduce,['Evaluation',[P,X]]],[match,'&self',['Implication',A,['Evaluation',[P,X]]],[deduce,A]])
</span><span class="ansi38-255165000">(= 
  (deduce 
    (Evaluation 
      ($P $X))) 
  (match &self 
    (Implication $A 
      (Evaluation 
        ($P $X))) 
    (deduce $A)))
</span>

;; Deduction case for generic "And" expressions;
;; also recursive
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[deduce,['And',A,B]],['And',[deduce,A],[deduce,B]])
</span><span class="ansi38-255165000">(= 
  (deduce 
    (And $A $B)) 
  (And 
    (deduce $A) 
    (deduce $B)))
</span>

;; True & True = True
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['And','T','T'],'T')
</span><span class="ansi38-255165000">(= 
  (And T T) T)
</span>

;; Test deduction that Plato is mortal
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['simple-deduction-strength-formula',As,Bs,Cs,ABs,BCs],[if,[and,['conditional-probability-consistency',As,Bs,ABs],['conditional-probability-consistency',Bs,Cs,BCs]],[if,[<,0.99,Bs],Cs,[+,[*,ABs,BCs],[/,[*,[-,1,ABs],[-,Cs,[*,Bs,BCs]]],[-,1,Bs]]]],0])
</span><span class="ansi38-255165000">  (= 
    (simple-deduction-strength-formula $As $Bs $Cs $ABs $BCs) 
    (if 
      (and 
        (conditional-probability-consistency $As $Bs $ABs) 
        (conditional-probability-consistency $Bs $Cs $BCs)) 
      (if 
        (< 0.99 $Bs) $Cs 
        (+ 
          (* $ABs $BCs) 
          (/ 
            (* 
              (- 1 $ABs) 
              (- $Cs 
                (* $Bs $BCs))) 
            (- 1 $Bs)))) 0))
</span>

;; Preconditions are met
;; sB tends to 1
;; otherwise
;; Preconditions are not met
;; Alternate deduction formula hardwired for STV to make it faster.
<span class="ansi38-000068000">!(assertEqual 
  (deduce 
    (Evaluation 
      (mortal Plato))) T)

</span>    -->(2,'&self',[assertEqual,[deduce,['Evaluation',[mortal,'Plato']]],'T'],depth(0))
<span class="ansi38-017068017">[assertEqual,[deduce,['Evaluation',[mortal,'Plato']]],'T']
</span><h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.B2-BACKCHAIN.04">;; HYPERON-EXPERIMENTAL-SCRIPTS.B2-BACKCHAIN.04</h3>
      -->(3,'&self',[deduce,['Evaluation',[mortal,'Plato']]],depth(1))
        -->(4,'&self',[match,'&self',['Evaluation',[mortal,'Plato']],'T'],depth(2))
        <--(4,retval(fail))
        -->(4,'&self',[match,'&self',['Implication',_22370,['Evaluation',[mortal,'Plato']]],[deduce,_22370]],depth(2))
          -->(5,'&self',[deduce,['Evaluation',[human,'Plato']]],depth(3))
            -->(6,'&self',[match,'&self',['Evaluation',[human,'Plato']],'T'],depth(4))
            <--(6,retval(fail))
            -->(6,'&self',[match,'&self',['Implication',_24222,['Evaluation',[human,'Plato']]],[deduce,_24222]],depth(4))
              -->(7,'&self',[deduce,['And',['Evaluation',[philosopher,'Plato']],['Evaluation',['likes-to-wrestle','Plato']]]],depth(5))
                -->(8,'&self',['And',[deduce,['Evaluation',[philosopher,'Plato']]],[deduce,['Evaluation',['likes-to-wrestle','Plato']]]],depth(6))
                  -->(9,'&self',[philosopher,'Plato'],depth(7))
                  <--(9,retval(fail))
                <--(8,retval(fail))
              <--(7,retval(['And',[deduce,['Evaluation',[philosopher,'Plato']]],[deduce,['Evaluation',['likes-to-wrestle','Plato']]]]))
            <--(6,retval(fail))
          <--(5,retval([match,'&self',['Implication',_24688,['Evaluation',[human,'Plato']]],[deduce,_24688]]))
        <--(4,retval(fail))
      <--(3,retval([match,'&self',['Implication',_22836,['Evaluation',[mortal,'Plato']]],[deduce,_22836]]))
    <--(2,retval(fail))
%~ error(existence_error(procedure,eval_args80/4),context(efbug/2,_27140))
no results<span class="ansi33"> $_13776

</span>;; TODO : Some variables are not substituted
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[ift,'T',Then],Then)
</span><span class="ansi38-255165000">(= 
  (ift T $Then) $Then)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['deduction-formula',['STV',Ps,Pc],['STV',Qs,Qc],['STV',Rs,Rc],['STV',PQs,PQc],['STV',QRs,QRc]],[if,[and,['conditional-probability-consistency',Ps,Qs,PQs],['conditional-probability-consistency',Qs,Rs,QRs]],['STV',[if,[<,0.9999,Qs],Rs,[+,[*,PQs,QRs],[/,[*,[-,1,PQs],[-,Rs,[*,Qs,QRs]]],[-,1,Qs]]]],[min,Pc,[min,Qc,[min,Rc,[min,PQc,QRc]]]]],['STV',1,0]])
</span><span class="ansi38-255165000">  (= 
    (deduction-formula 
      (STV $Ps $Pc) 
      (STV $Qs $Qc) 
      (STV $Rs $Rc) 
      (STV $PQs $PQc) 
      (STV $QRs $QRc)) 
    (if 
      (and 
        (conditional-probability-consistency $Ps $Qs $PQs) 
        (conditional-probability-consistency $Qs $Rs $QRs)) 
      (STV 
        (if 
          (< 0.9999 $Qs) $Rs 
          (+ 
            (* $PQs $QRs) 
            (/ 
              (* 
                (- 1 $PQs) 
                (- $Rs 
                  (* $Qs $QRs))) 
              (- 1 $Qs)))) 
        (min $Pc 
          (min $Qc 
            (min $Rc 
              (min $PQc $QRc))))) 
      (STV 1 0)))
</span>

      <--(1,retval('Empty'))
<span class="ansi33"> Empty

</span>;; Preconditions are met
; avoid division by 0
;; Qs tends to 1
;; Otherwise
;; Preconditions are not met
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',ift,[deduce,['Evaluation',[mortal,X]]],[X])
</span><span class="ansi38-255165000">(ift 
  (deduce 
    (Evaluation 
      (mortal $X))) $X)
</span>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Another example of backchaining
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Definition of explain when the desired Evaluation is
;; in the knowledge base
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',['â\x8A\¢',['â\x89\\x9E\',P,Ptv],['â\x89\\x9E\',Q,Qtv],['â\x89\\x9E\',R,Rtv],['â\x89\\x9E\',['â\x86\\x92\',P,Q],Pqtv],['â\x89\\x9E\',['â\x86\\x92\',Q,R],Qrtv],['â\x89\\x9E\',['â\x86\\x92\',P,R],['deduction-formula',Ptv,Qtv,Rtv,Pqtv,Qrtv]]])
</span><span class="ansi38-255165000">  (â¢ 
    (â $P $Ptv) 
    (â $Q $Qtv) 
    (â $R $Rtv) 
    (â 
      (â $P $Q) $Pqtv) 
    (â 
      (â $Q $R) $Qrtv) 
    (â 
      (â $P $R) 
      (deduction-formula $Ptv $Qtv $Rtv $Pqtv $Qrtv)))
</span>

      <--(0,retval('Empty'))
<span class="ansi33"> Empty

</span>;; premises
;; conclusion
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[explain,['Evaluation',[P,X]]],[match,'&self',['Evaluation',[P,X]],[P,X]])
</span><span class="ansi38-255165000">(= 
  (explain 
    (Evaluation 
      ($P $X))) 
  (match &self 
    (Evaluation 
      ($P $X)) 
    ($P $X)))
</span>

;; Definition of explain when the desired Evaluation is
;; the result of an implication
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['P'],['â\x89\\x9E\','P',['STV',1,0.1]])
</span><span class="ansi38-255165000">  (= 
    (P) 
    (â P 
      (STV 1 0.1)))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['Q'],['â\x89\\x9E\','Q',['STV',1,0.1]])
</span><span class="ansi38-255165000">  (= 
    (Q) 
    (â Q 
      (STV 1 0.1)))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[explain,['Evaluation',[P,X]]],[match,'&self',['Implication',A,['Evaluation',[P,X]]],[[P,X],proven,by,[explain,A]]])
</span><span class="ansi38-255165000">(= 
  (explain 
    (Evaluation 
      ($P $X))) 
  (match &self 
    (Implication $A 
      (Evaluation 
        ($P $X))) 
    ( ($P $X) proven by 
      (explain $A))))
</span>

;; Definition of explain for And
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['R'],['â\x89\\x9E\','R',['STV',1,0.1]])
</span><span class="ansi38-255165000">  (= 
    (R) 
    (â R 
      (STV 1 0.1)))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['PQ'],['â\x89\\x9E\',['â\x86\\x92\','P','Q'],['STV',1,0.5]])
</span><span class="ansi38-255165000">  (= 
    (PQ) 
    (â 
      (â P Q) 
      (STV 1 0.5)))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[explain,['And',A,B]],['And',[explain,A],[explain,B]])
</span><span class="ansi38-255165000">(= 
  (explain 
    (And $A $B)) 
  (And 
    (explain $A) 
    (explain $B)))
</span>

;; Example of explain why Plato is mortal
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['QR'],['â\x89\\x9E\',['â\x86\\x92\','Q','R'],['STV',1,0.5]])
</span><span class="ansi38-255165000">  (= 
    (QR) 
    (â 
      (â Q R) 
      (STV 1 0.5)))
</span>

;; Forward chain
<span class="ansi38-000068000">!(assertEqual 
  (explain 
    (Evaluation 
      (mortal Plato))) 
  ( (mortal Plato) proven by 
    ( (human Plato) proven by 
      (And 
        (philosopher Plato) 
        (likes-to-wrestle Plato)))))

</span>    -->(2,'&self',[assertEqual,[explain,['Evaluation',[mortal,'Plato']]],[[mortal,'Plato'],proven,by,[[human,'Plato'],proven,by,['And',[philosopher,'Plato'],['likes-to-wrestle','Plato']]]]],depth(0))
<span class="ansi38-017068017">[assertEqual,[explain,['Evaluation',[mortal,'Plato']]],[[mortal,'Plato'],proven,by,[[human,'Plato'],proven,by,['And',[philosopher,'Plato'],['likes-to-wrestle','Plato']]]]]
</span><h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.B2-BACKCHAIN.05">;; HYPERON-EXPERIMENTAL-SCRIPTS.B2-BACKCHAIN.05</h3>
      -->(3,'&self',[explain,['Evaluation',[mortal,'Plato']]],depth(1))
        -->(4,'&self',[match,'&self',['Evaluation',[mortal,'Plato']],[mortal,'Plato']],depth(2))
        <--(4,retval(fail))
        -->(4,'&self',[match,'&self',['Implication',_152960,['Evaluation',[mortal,'Plato']]],[[mortal,'Plato'],proven,by,[explain,_152960]]],depth(2))
          -->(5,'&self',[[mortal,'Plato'],proven,by,[explain,['Evaluation',[human,'Plato']]]],depth(3))
          <--(5,retval(fail))
        <--(4,retval(fail))
      <--(3,retval([match,'&self',['Implication',_153534,['Evaluation',[mortal,'Plato']]],[[mortal,'Plato'],proven,by,[explain,_153534]]]))
    <--(2,retval(fail))
%~ error(existence_error(procedure,eval_args80/4),context(efbug/2,_154588))
no results<span class="ansi33"> $_142486

</span><span class="ansi32">% 393,448 inferences, 0.323 CPU in 0.323 seconds (100% CPU, 1218314 Lips)
</span> (= "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-experimental_scripts/b2_backchain.metta" 0)
<span class="ansi1">LoonIt Report
</span>------------
<span class="ansi32">Successes: 3
</span><span class="ansi32">Failures: 0
</span><br/><a href="https://github.com/logicmoo/vspace-metta/blob/main/MeTTaLog.md">Return to Summaries</a><br/>
doing(ansi2html -u < "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/TEE.ansi" > "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_2a/hyperon-experimental_scripts/b2_backchain.html" )
<span class="ansi38-000068000">!(let* 
  ( ($P 
      (P)) 
    ($Q 
      (Q)) 
    ($R 
      (R)) 
    ($Pq 
      (PQ)) 
    ($Qr 
      (QR))) 
  (match &self 
    (â¢ $P $Q $R $Pq $Qr $Res) $Res))

</span>      -->(5,'&self',['let*',[[_468892,['P']],[_469200,['Q']],[_469508,['R']],[_469816,['PQ']],[_470130,['QR']]],[match,'&self',['â\x8A\¢',_468892,_469200,_469508,_469816,_470130,_471888],_471888]],depth(1))
          -->(6,'&self',['P'],depth(3))
            -->(7,'&self',['â\x89\\x9E\','P',['STV',1,0.1]],depth(4))
                -->(8,'&self',['STV',1,0.1],depth(6))
                -->(9,'&self',['STV',1,0.1],depth(6))
                -->(10,'&self',['STV',1,0.1],depth(6))
          -->(11,'&self',['let*',[[_469200,['Q']],[_469508,['R']],[_469816,['PQ']],[_470130,['QR']]],[match,'&self',['â\x8A\¢',['â\x89\\x9E\','P',['STV',1,0.1]],_469200,_469508,_469816,_470130,_471888],_471888]],depth(3))
              -->(12,'&self',['Q'],depth(5))
                -->(13,'&self',['â\x89\\x9E\','Q',['STV',1,0.1]],depth(6))
                    -->(14,'&self',['STV',1,0.1],depth(8))
                    -->(15,'&self',['STV',1,0.1],depth(8))
                    -->(16,'&self',['STV',1,0.1],depth(8))
              -->(17,'&self',['let*',[[_469508,['R']],[_469816,['PQ']],[_470130,['QR']]],[match,'&self',['â\x8A\¢',['â\x89\\x9E\','P',['STV',1,0.1]],['â\x89\\x9E\','Q',['STV',1,0.1]],_469508,_469816,_470130,_471888],_471888]],depth(5))
                  -->(18,'&self',['R'],depth(7))
                    -->(19,'&self',['â\x89\\x9E\','R',['STV',1,0.1]],depth(8))
                        -->(20,'&self',['STV',1,0.1],depth(10))
                        -->(21,'&self',['STV',1,0.1],depth(10))
                        -->(22,'&self',['STV',1,0.1],depth(10))
                  -->(23,'&self',['let*',[[_469816,['PQ']],[_470130,['QR']]],[match,'&self',['â\x8A\¢',['â\x89\\x9E\','P',['STV',1,0.1]],['â\x89\\x9E\','Q',['STV',1,0.1]],['â\x89\\x9E\','R',['STV',1,0.1]],_469816,_470130,_471888],_471888]],depth(7))
                      -->(24,'&self',['PQ'],depth(9))
                        -->(25,'&self',['â\x89\\x9E\',['â\x86\\x92\','P','Q'],['STV',1,0.5]],depth(10))
                            -->(26,'&self',['â\x86\\x92\','P','Q'],depth(12))
                            -->(27,'&self',['â\x86\\x92\','P','Q'],depth(12))
                            -->(28,'&self',['STV',1,0.5],depth(12))
                            -->(29,'&self',['â\x86\\x92\','P','Q'],depth(12))
                            -->(30,'&self',['STV',1,0.5],depth(12))
                      -->(31,'&self',['let*',[[_470130,['QR']]],[match,'&self',['â\x8A\¢',['â\x89\\x9E\','P',['STV',1,0.1]],['â\x89\\x9E\','Q',['STV',1,0.1]],['â\x89\\x9E\','R',['STV',1,0.1]],['â\x89\\x9E\',['â\x86\\x92\','P','Q'],['STV',1,0.5]],_470130,_471888],_471888]],depth(9))
                          -->(32,'&self',['QR'],depth(11))
                            -->(33,'&self',['â\x89\\x9E\',['â\x86\\x92\','Q','R'],['STV',1,0.5]],depth(12))
                                -->(34,'&self',['â\x86\\x92\','Q','R'],depth(14))
                                -->(35,'&self',['â\x86\\x92\','Q','R'],depth(14))
                                -->(36,'&self',['STV',1,0.5],depth(14))
                                -->(37,'&self',['â\x86\\x92\','Q','R'],depth(14))
                                -->(38,'&self',['STV',1,0.5],depth(14))
                          -->(39,'&self',['let*',[],[match,'&self',['â\x8A\¢',['â\x89\\x9E\','P',['STV',1,0.1]],['â\x89\\x9E\','Q',['STV',1,0.1]],['â\x89\\x9E\','R',['STV',1,0.1]],['â\x89\\x9E\',['â\x86\\x92\','P','Q'],['STV',1,0.5]],['â\x89\\x9E\',['â\x86\\x92\','Q','R'],['STV',1,0.5]],_471888],_471888]],depth(11))
                              -->(40,'&self',[match,'&self',['â\x8A\¢',['â\x89\\x9E\','P',['STV',1,0.1]],['â\x89\\x9E\','Q',['STV',1,0.1]],['â\x89\\x9E\','R',['STV',1,0.1]],['â\x89\\x9E\',['â\x86\\x92\','P','Q'],['STV',1,0.5]],['â\x89\\x9E\',['â\x86\\x92\','Q','R'],['STV',1,0.5]],_471888],_471888],depth(13))
                                -->(41,'&self',['â\x89\\x9E\',['â\x86\\x92\','P','R'],['deduction-formula',['STV',1,0.1],['STV',1,0.1],['STV',1,0.1],['STV',1,0.5],['STV',1,0.5]]],depth(14))
                                    -->(42,'&self',['â\x86\\x92\','P','R'],depth(16))
                                    -->(43,'&self',['â\x86\\x92\','P','R'],depth(16))
                                    -->(44,'&self',['deduction-formula',['STV',1,0.1],['STV',1,0.1],['STV',1,0.1],['STV',1,0.5],['STV',1,0.5]],depth(16))
                                        -->(45,'&self',['STV',1,0.1],depth(18))
                                      -->(46,'&self',[if,[and,['conditional-probability-consistency',1,1,1],['conditional-probability-consistency',1,1,1]],['STV',[if,[<,0.9999,1],1,[+,[*,1,1],[/,[*,[-,1,1],[-,1,[*,1,1]]],[-,1,1]]]],[min,0.1,[min,0.1,[min,0.1,[min,0.5,0.5]]]]],['STV',1,0]],depth(17))
                                          -->(47,'&self',[and,['conditional-probability-consistency',1,1,1],['conditional-probability-consistency',1,1,1]],depth(19))
                                              -->(48,'&self',['conditional-probability-consistency',1,1,1],depth(21))
                                                -->(49,'&self',[and,[<,0,1],[and,[<=,['smallest-intersection-probability',1,1],1],[<=,1,['largest-intersection-probability',1,1]]]],depth(22))
                                                    -->(50,'&self',[<,0,1],depth(24))
                                                    <--(50,retval('True'))
                                                    -->(51,'&self',[and,[<=,['smallest-intersection-probability',1,1],1],[<=,1,['largest-intersection-probability',1,1]]],depth(24))
                                                        -->(52,'&self',[<=,['smallest-intersection-probability',1,1],1],depth(26))
                                                            -->(53,'&self',['smallest-intersection-probability',1,1],depth(28))
                                                              -->(54,'&self',[clamp,[/,[-,[+,1,1],1],1],0,1],depth(29))
                                                                  -->(55,'&self',[+,1,1],depth(31))
                                                                  <--(55,retval(2))
                                                                  -->(56,'&self',[clamp,[/,[-,2,1],1],0,1],depth(31))
                                                                      -->(57,'&self',[-,2,1],depth(33))
                                                                      <--(57,retval(1))
                                                                      -->(58,'&self',[clamp,[/,1,1],0,1],depth(33))
                                                                          -->(59,'&self',[/,1,1],depth(35))
                                                                          <--(59,retval(1))
                                                                          -->(60,'&self',[clamp,1,0,1],depth(35))
                                                                            -->(61,'&self',[max,0,[min,1,1]],depth(36))
                                                                                -->(62,'&self',[min,1,1],depth(38))
                                                                                  -->(63,'&self',[if,[<,1,1],1,1],depth(39))
                                                                                      -->(64,'&self',[<,1,1],depth(41))
                                                                                      <--(64,retval('False'))
                                                                                  <--(63,retval(1))
                                                                                -->(65,'&self',[max,0,1],depth(38))
                                                                                  -->(66,'&self',[if,[>,0,1],0,1],depth(39))
                                                                                      -->(67,'&self',[>,0,1],depth(41))
                                                                                      <--(67,retval('False'))
                                                                                  <--(66,retval(1))
                                                            -->(68,'&self',[<=,1,1],depth(28))
                                                              -->(69,'&self',[or,[<,1,1],[==,1,1]],depth(29))
                                                                  -->(70,'&self',[<,1,1],depth(31))
                                                                  <--(70,retval('False'))
                                                                  -->(71,'&self',[==,1,1],depth(31))
                                                                  <--(71,retval('True'))
                                                              <--(69,retval('True'))
                                                        -->(72,'&self',[<=,1,['largest-intersection-probability',1,1]],depth(26))
                                                            -->(73,'&self',['largest-intersection-probability',1,1],depth(28))
                                                              -->(74,'&self',[clamp,[/,1,1],0,1],depth(29))
                                                                  -->(75,'&self',[/,1,1],depth(31))
                                                                  <--(75,retval(1))
                                                                  -->(76,'&self',[clamp,1,0,1],depth(31))
                                                                    -->(77,'&self',[max,0,[min,1,1]],depth(32))
                                                                        -->(78,'&self',[min,1,1],depth(34))
                                                                          -->(79,'&self',[if,[<,1,1],1,1],depth(35))
                                                                              -->(80,'&self',[<,1,1],depth(37))
                                                                              <--(80,retval('False'))
                                                                          <--(79,retval(1))
                                                                        -->(81,'&self',[max,0,1],depth(34))
                                                                          -->(82,'&self',[if,[>,0,1],0,1],depth(35))
                                                                              -->(83,'&self',[>,0,1],depth(37))
                                                                              <--(83,retval('False'))
                                                                          <--(82,retval(1))
                                                            -->(84,'&self',[<=,1,1],depth(28))
                                                              -->(85,'&self',[or,[<,1,1],[==,1,1]],depth(29))
                                                                  -->(86,'&self',[<,1,1],depth(31))
                                                                  <--(86,retval('False'))
                                                                  -->(87,'&self',[==,1,1],depth(31))
                                                                  <--(87,retval('True'))
                                                              <--(85,retval('True'))
                                                            <--(84,retval([or,[<,1,1],[==,1,1]]))
                                                                        <--(81,retval([if,[>,0,1],0,1]))
                                                                        <--(78,retval([if,[<,1,1],1,1]))
                                                                    <--(77,retval(1))
                                                                  <--(76,retval([max,0,[min,1,1]]))
                                                              <--(74,retval(1))
                                                            <--(73,retval([clamp,[/,1,1],0,1]))
                                                        <--(72,retval('True'))
                                                            <--(68,retval([or,[<,1,1],[==,1,1]]))
                                                                                <--(65,retval([if,[>,0,1],0,1]))
                                                                                <--(62,retval([if,[<,1,1],1,1]))
                                                                            <--(61,retval(1))
                                                                          <--(60,retval([max,0,[min,1,1]]))
                                                                      <--(58,retval(1))
                                                                  <--(56,retval(1))
                                                              <--(54,retval(1))
                                                            <--(53,retval([clamp,[/,[-,[+,1,1],1],1],0,1]))
                                                        <--(52,retval('True'))
                                                    <--(51,retval('True'))
                                                <--(49,retval('True'))
                                              -->(88,'&self',['conditional-probability-consistency',1,1,1],depth(21))
                                                -->(89,'&self',[and,[<,0,1],[and,[<=,['smallest-intersection-probability',1,1],1],[<=,1,['largest-intersection-probability',1,1]]]],depth(22))
                                                    -->(90,'&self',[<,0,1],depth(24))
                                                    <--(90,retval('True'))
                                                    -->(91,'&self',[and,[<=,['smallest-intersection-probability',1,1],1],[<=,1,['largest-intersection-probability',1,1]]],depth(24))
                                                        -->(92,'&self',[<=,['smallest-intersection-probability',1,1],1],depth(26))
                                                            -->(93,'&self',['smallest-intersection-probability',1,1],depth(28))
                                                              -->(94,'&self',[clamp,[/,[-,[+,1,1],1],1],0,1],depth(29))
                                                                  -->(95,'&self',[+,1,1],depth(31))
                                                                  <--(95,retval(2))
                                                                  -->(96,'&self',[clamp,[/,[-,2,1],1],0,1],depth(31))
                                                                      -->(97,'&self',[-,2,1],depth(33))
                                                                      <--(97,retval(1))
                                                                      -->(98,'&self',[clamp,[/,1,1],0,1],depth(33))
                                                                          -->(99,'&self',[/,1,1],depth(35))
                                                                          <--(99,retval(1))
                                                                          -->(100,'&self',[clamp,1,0,1],depth(35))
Switched off tracing. For a longer trace !(pragma! tracelen 101))<span class="ansi33">
  (â 
    (â P R) 
    (STV 1 0.1))
</span><span class="ansi32">['Res'=['â\x89\\x9E\',['â\x86\\x92\','P','R'],['deduction-formula',['STV',1,0.1],['STV',1,0.1],['STV',1,0.1],['STV',1,0.5],['STV',1,0.5]]],'Qr'=['â\x89\\x9E\',['â\x86\\x92\','Q','R'],['STV',1,0.5]],'Pq'=['â\x89\\x9E\',['â\x86\\x92\','P','Q'],['STV',1,0.5]],'R'=['â\x89\\x9E\','R',['STV',1,0.1]],'Q'=['â\x89\\x9E\','Q',['STV',1,0.1]],'P'=['â\x89\\x9E\','P',['STV',1,0.1]]]
</span>

<span class="ansi32">% 1,552,460 inferences, 1.701 CPU in 1.701 seconds (100% CPU, 912762 Lips)
</span> (@ = "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_1a/hyperon-pln_metta/entail/DeductionEntailTest.metta" 0)
doing(ansi2html -u < "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/TEE.ansi" > "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/interp_1a/hyperon-pln_metta/entail/DeductionEntailTest.html" )
 ; (is_cmd_option halt --halt=true True)

</pre>
</body>

</html>
