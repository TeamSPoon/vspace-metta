<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>
<style type="text/css">
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content">
 (@ track_load_into_file "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/dependent-types/DeductionDTLTest.metta")
;; ;; Type definitions checker
;; !(pragma! type-check auto)
;; ;; Equality type definition
;; (: = (-> $t $t Type))
;; Import modules
<span class="ansi38-000068000">!(import! &self DeductionDTL.metta)

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&self', 'DeductionDTL.metta'], A).

</span>;; MeTTa port for deduction PLN rule
;; as DTL (Dependent Type Language)
;;
;; (â P ptv)
;; (â Q qtv)
;; (â R rtv)
;; (â (â P Q) tv1)
;; (â (â Q R) tv2)
;; â¢
;; (â (â P R) TV)
;;
;; where ptv, qtv, rtv, tv1 and tv2 are truth values of the
;; premises P, Q, R, (â P Q) and (â Q R) respectively.
;; TV represents the resulting truth value of the conclusion.
;; Import modules
<span class="ansi38-000068000">!(import! &self "../common/truthvalue/MeasEq.metta")

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&self', '../common/truthvalue/MeasEq.metta'], A).

</span>;; The symbol â, called Measured By in Unicode, and \measeq in LaTeX,
;; is used to represent the measure of an event.  This measure may be
;; boolean, probabilistic first or second order, evidential or
;; otherwise.  The idea of using a dedicated equality, as opposed to
;; regular definitional equality =, is to not conflate event and
;; measure which can lead to contradictions.
;; Define â as a dependent type, assigning a truth value to an event.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â\x89\\x9E\',[->,Event,Tv,'Type']])
</span><span class="ansi38-255165000">  (: â 
    (-> $Event $Tv Type))
</span>

; Evaluation took 1.38 ms.
<span class="ansi33"> &self

</span><span class="ansi38-000068000">!(import! &self "../common/formula/DeductionFormula.metta")

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&self', '../common/formula/DeductionFormula.metta'], A).

</span>;; Define deduction rule
;; Formula and other functions used for the deduction rule
;; Import modules
<span class="ansi38-000068000">!(import! &self "../truthvalue/TruthValue.metta")

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&self', '../truthvalue/TruthValue.metta'], A).

</span>;; Truth value type definition
;; Import modules
<span class="ansi38-000068000">!(import! &self "../Num.metta")

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&self', '../Num.metta'], A).

</span>;;;;;;;;;;
;; Type ;;
;;;;;;;;;;
;; Collection of functions operating on numbers
;; Define max
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,max,[->,A,A,A]])
</span><span class="ansi38-255165000">  (: max 
    (-> $A $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( max(X,Y,Assign_Max_Y) :-
%~                              u_assign([>,X,Y],Assign) ,
%~                              Assign=_56866 ,
%~                              u_assign([if,_56866,X,Y],Assign_Max_Y))]
%~ [convert(_4198),head_preconds_into_body((max(X,Y,_4156):-(u_assign([>,X,Y],_4236),_4236=_4232),u_assign([if,_4232,X,Y],_4156)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[max,X,Y],[if,[>,X,Y],X,Y])
</span><span class="ansi38-255165000">  (= 
    (max $X $Y) 
    (if 
      (> $X $Y) $X $Y))
</span><span class="ansi38-000082136">  :- dynamic(max,3).

  max(X, Y, A) :-
    u_assign([>, X, Y], B),
    B=C,
    u_assign([if, C, X, Y], A).

</span>

;; Define min
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,min,[->,A,A,A]])
</span><span class="ansi38-255165000">  (: min 
    (-> $A $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( min(X,Y,Assign_Min_Y) :-
%~                              u_assign([<,X,Y],Assign) ,
%~                              Assign=_181966 ,
%~                              u_assign([if,_181966,X,Y],Assign_Min_Y))]
%~ [convert(_124236),head_preconds_into_body((min(X,Y,_123000):-(u_assign([<,X,Y],_124542),_124542=_124532),u_assign([if,_124532,X,Y],_123000)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[min,X,Y],[if,[<,X,Y],X,Y])
</span><span class="ansi38-255165000">  (= 
    (min $X $Y) 
    (if 
      (< $X $Y) $X $Y))
</span><span class="ansi38-000082136">  :- dynamic(min,3).

  min(X, Y, A) :-
    u_assign([<, X, Y], B),
    B=C,
    u_assign([if, C, X, Y], A).

</span>

;; Clamp a number to be within a certain range
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,clamp,[->,A,A,A,A]])
</span><span class="ansi38-255165000">  (: clamp 
    (-> $A $A $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( clamp(X,L,U,Assign_Clamp_U) :-
%~                              u_assign([min,U,X],Assign) ,
%~                              Assign=_304988 ,
%~                              u_assign([max,L,_304988],Assign_Clamp_U))]
%~ [convert(_245260),head_preconds_into_body((clamp(X,L,U,_243954):-(u_assign([min,U,X],_245622),_245622=_245612),u_assign([max,L,_245612],_243954)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[clamp,X,L,U],[max,L,[min,U,X]])
</span><span class="ansi38-255165000">  (= 
    (clamp $X $L $U) 
    (max $L 
      (min $U $X)))
</span><span class="ansi38-000082136">  :- dynamic(clamp,4).

  clamp(X, L, U, A) :-
    u_assign([min, U, X], B),
    B=C,
    u_assign([max, L, C], A).

</span>

;; Define abs
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,abs,[->,A,A]])
</span><span class="ansi38-255165000">  (: abs 
    (-> $A $A))
</span>

%~ /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/metta_vspace/pyswip/metta_interp.pl:1054 
%~ [ convert(Convert),
%~   head_preconds_into_body( abs(X,Assign_Abs_X) :-
%~                              u_assign([<,X,0],Assign) ,
%~                              Assign=_451042 ,
%~                              u_assign([*,-1,X],Assign3) ,
%~                              Assign3=_451060 ,
%~                              u_assign([if,_451042,_451060,X],Assign_Abs_X))]
%~ [convert(_364734),head_preconds_into_body((abs(X,_363568):-((u_assign([<,X,0],_365040),_365040=_365030),u_assign([*,-1,X],_365200),_365200=_365190),u_assign([if,_365030,_365190,X],_363568)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[abs,X],[if,[<,X,0],[*,-1,X],X])
</span><span class="ansi38-255165000">  (= 
    (abs $X) 
    (if 
      (< $X 0) 
      (* -1 $X) $X))
</span><span class="ansi38-000082136">
  abs(X, A) :-
    ( u_assign([<, X, 0], B),
      B=C
    ),
    u_assign([*, -1, X], D),
    D=E,
    u_assign([if, C, E, X], A).

</span>

;; Define <=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,<=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: <= 
    (-> $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( <=(X,Y,Assign_Y) :-
%~                              u_assign([<,X,Y],Assign) ,
%~                              Assign=_110636 ,
%~                              u_assign([==,X,Y],Assign2) ,
%~                              Assign2=_110654 ,
%~                              u_assign([or,_110636,_110654],Assign_Y))]
%~ [convert(_35600),head_preconds_into_body((<=(X,Y,_34364):-((u_assign([<,X,Y],_35906),_35906=_35896),u_assign([==,X,Y],_36110),_36110=_36100),u_assign([or,_35896,_36100],_34364)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[<=,X,Y],[or,[<,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">  (= 
    (<= $X $Y) 
    (or 
      (< $X $Y) 
      (== $X $Y)))
</span><span class="ansi38-000082136">  :- dynamic(<=,3).

  <=(X, Y, A) :-
    ( u_assign([<, X, Y], B),
      B=C
    ),
    u_assign([==, X, Y], D),
    D=E,
    u_assign([or, C, E], A).

</span>

;; Define >=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,>=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: >= 
    (-> $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( >=(X,Y,Assign_Y) :-
%~                              u_assign([>,X,Y],Assign) ,
%~                              Assign=_245806 ,
%~                              u_assign([==,X,Y],Assign2) ,
%~                              Assign2=_245824 ,
%~                              u_assign([or,_245806,_245824],Assign_Y))]
%~ [convert(_170770),head_preconds_into_body((>=(X,Y,_169534):-((u_assign([>,X,Y],_171076),_171076=_171066),u_assign([==,X,Y],_171280),_171280=_171270),u_assign([or,_171066,_171270],_169534)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[>=,X,Y],[or,[>,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">  (= 
    (>= $X $Y) 
    (or 
      (> $X $Y) 
      (== $X $Y)))
</span><span class="ansi38-000082136">  :- dynamic(>=,3).

  >=(X, Y, A) :-
    ( u_assign([>, X, Y], B),
      B=C
    ),
    u_assign([==, X, Y], D),
    D=E,
    u_assign([or, C, E], A).

</span>

;; Define approximately equal
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,approxEq,[->,A,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: approxEq 
    (-> $A $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( approxEq(X,Y,Epsilon,Assign_ApproxEq_Epsilon) :-
%~                              u_assign([-,X,Y],Assign) ,
%~                              Assign=_392786 ,
%~                              u_assign([abs,_392786],Assign3) ,
%~                              Assign3=_392810 ,
%~                              u_assign([<=,_392810,Epsilon],Assign_ApproxEq_Epsilon))]
%~ [convert(_305934),head_preconds_into_body((approxEq(X,Y,Epsilon,_304628):-(((u_assign([-,X,Y],_306282),_306282=_306272),u_assign([abs,_306272],_306240)),_306240=_306230),u_assign([<=,_306230,Epsilon],_304628)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[approxEq,X,Y,Epsilon],[<=,[abs,[-,X,Y]],Epsilon])
</span><span class="ansi38-255165000">  (= 
    (approxEq $X $Y $Epsilon) 
    (<= 
      (abs 
        (- $X $Y)) $Epsilon))
</span><span class="ansi38-000082136">  :- dynamic(approxEq,4).

  approxEq(X, Y, Epsilon, A) :-
    ( u_assign([-, X, Y], B),
      B=C,
      u_assign([abs, C], D)
    ),
    D=E,
    u_assign([<=, E, Epsilon], A).

</span>

;; Define Nat
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Nat','Type'])
</span><span class="ansi38-255165000">  (: Nat Type)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Z','Nat'])
</span><span class="ansi38-255165000">  (: Z Nat)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'S',[->,'Nat','Nat']])
</span><span class="ansi38-255165000">  (: S 
    (-> Nat Nat))
</span>

;; Define cast functions between Nat and Number
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNumber,[->,'Number','Nat']])
</span><span class="ansi38-255165000">  (: fromNumber 
    (-> Number Nat))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( fromNumber(N,N) :-
%~                              u_assign([<=,N,0],Assign) ,
%~                              Assign=_102190 ,
%~                              u_assign([-,N,1],Assign2) ,
%~                              Assign2=_102232 ,
%~                              u_assign([fromNumber,_102232],Assign3) ,
%~                              Assign3=_102256 ,
%~                              u_assign(['S',_102256],Assign4) ,
%~                              Assign4=_102280 ,
%~                              u_assign([if,_102190,'Z',_102280],N))]
%~ [convert(_4488),head_preconds_into_body((fromNumber(N,_4452):-((u_assign([<=,N,0],_4526),_4526=_4522),((((u_assign([-,N,1],_4634),_4634=_4630),u_assign([fromNumber,_4630],_4608)),_4608=_4604),u_assign(['S',_4604],_4582)),_4582=_4578),u_assign([if,_4522,'Z',_4578],_4452)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNumber,N],[if,[<=,N,0],'Z',['S',[fromNumber,[-,N,1]]]])
</span><span class="ansi38-255165000">  (= 
    (fromNumber $N) 
    (if 
      (<= $N 0) Z 
      (S 
        (fromNumber 
          (- $N 1)))))
</span><span class="ansi38-000082136">  :- dynamic(fromNumber,2).

  fromNumber(N, A) :-
    ( u_assign([<=, N, 0], B),
      B=C
    ),
    ( ( u_assign([-, N, 1], D),
        D=E,
        u_assign([fromNumber, E], F)
      ),
      F=G,
      u_assign(['S', G], H)
    ),
    H=I,
    u_assign([if, C, 'Z', I], A).

</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNat,[->,'Nat','Number']])
</span><span class="ansi38-255165000">  (: fromNat 
    (-> Nat Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((fromNat('Z',0):-true))]
%~ [convert(_149258),head_preconds_into_body((fromNat('Z',0):-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,'Z'],0)
</span><span class="ansi38-255165000">  (= 
    (fromNat Z) 0)
</span><span class="ansi38-000082136">  :- dynamic(fromNat,2).

  fromNat('Z', 0).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( fromNat(FromNat,FromNat1) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=FromNat ,
%~                              u_assign([fromNat,K],Assign3) ,
%~                              [+,1,Assign3,FromNat1])]
%~ [convert(_195026),head_preconds_into_body((fromNat(_194072,_193792):-(u_assign(['S',K],_194082),_194082=_194072),u_assign([fromNat,K],_195350),[+,1,_195350,_193792]))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,['S',K]],[+,1,[fromNat,K]])
</span><span class="ansi38-255165000">  (= 
    (fromNat 
      (S $K)) 
    (+ 1 
      (fromNat $K)))
</span><span class="ansi38-000082136">  :- dynamic(fromNat,2).

  fromNat(A, B) :-
    u_assign(['S', K], C),
    C=A,
    u_assign([fromNat, K], D),
    [+, 1, D, B].

</span>

;; Define a generic less than operator, â©», for Nat.  < cannot be used
;; because it is a built-in, its type is hardwired and cannot be
;; overloaded.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Nat','Nat','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Nat Nat Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('â©»'(_,'Z',_293768):-_293768='False'))]
%~ [convert(_294960),head_preconds_into_body(('â©»'(_,'Z',_293768):-_293768='False'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',_,'Z'],'False')
</span><span class="ansi38-255165000">  (= 
    (â©» $_ Z) False)
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(_, 'Z', A) :-
    A='False'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'('Z',Z,True) :-
%~                              u_assign(['S',_],Assign) ,
%~                              Assign=Z ,
%~                              True='True')]
%~ [convert(_341338),head_preconds_into_body(('â©»'('Z',_340370,_340078):-(u_assign(['S',_],_340380),_340380=_340370),_340078='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»','Z',['S',_]],'True')
</span><span class="ansi38-255165000">  (= 
    (â©» Z 
      (S $_)) True)
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'('Z', A, B) :-
    u_assign(['S', _], C),
    C=A,
    B='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'(Â1,Â,Assign_Â2) :-
%~                              u_assign(['S',X],Assign) ,
%~                              Assign=Â1 ,
%~                              u_assign(['S',Y],Assign4) ,
%~                              Assign4=Â ,
%~                              u_assign(['â©»',X,Y],Assign_Â2))]
%~ [convert(_412992),head_preconds_into_body(('â©»'(_411876,_412010,_411596):-((u_assign(['S',X],_411886),_411886=_411876),u_assign(['S',Y],_412020),_412020=_412010),u_assign(['â©»',X,Y],_411596)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',['S',X],['S',Y]],['â©»',X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» 
      (S $X) 
      (S $Y)) 
    (â©» $X $Y))
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(A, B, C) :-
    ( u_assign(['S', X], D),
      D=A
    ),
    u_assign(['S', Y], E),
    E=B,
    u_assign(['â©»', X, Y], C).

</span>

;; Overload â©» for Number.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Number','Number','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Number Number Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'(X,Y,Assign_Â_Y) :-
%~                              u_assign([<,X,Y],Assign_Â_Y))]
%~ [convert(_4446),head_preconds_into_body(('â©»'(X,Y,_4404):-u_assign([<,X,Y],_4404)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',X,Y],[<,X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» $X $Y) 
    (< $X $Y))
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(X, Y, A) :-
    u_assign([<, X, Y], A).

</span>

;; Return the ceiling of a non negative number.  If the number is
;; negative it returns 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,ceil,[->,'Number','Number']])
</span><span class="ansi38-255165000">  (: ceil 
    (-> Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ceil(N,Assign_Ceil_N) :-
%~                              u_assign([fromNumber,N],Assign) ,
%~                              Assign=_126674 ,
%~                              u_assign([fromNat,_126674],Assign_Ceil_N))]
%~ [convert(_70360),head_preconds_into_body((ceil(N,_69194):-(u_assign([fromNumber,N],_70666),_70666=_70656),u_assign([fromNat,_70656],_69194)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[ceil,N],[fromNat,[fromNumber,N]])
</span><span class="ansi38-255165000">  (= 
    (ceil $N) 
    (fromNat 
      (fromNumber $N)))
</span><span class="ansi38-000082136">  :- dynamic(ceil,2).

  ceil(N, A) :-
    u_assign([fromNumber, N], B),
    B=C,
    u_assign([fromNat, C], A).

</span>

;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'number->bool',[->,'Number','Bool']])
</span><span class="ansi38-255165000">  (: number->bool 
    (-> Number Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'number->bool'(X,Number_c62_bool_X) :-
%~                              u_assign([<,0,X],Number_c62_bool_X))]
%~ [convert(_167970),head_preconds_into_body(('number->bool'(X,_166804):-u_assign([<,0,X],_166804)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['number->bool',X],[<,0,X])
</span><span class="ansi38-255165000">  (= 
    (number->bool $X) 
    (< 0 $X))
</span><span class="ansi38-000082136">  :- dynamic('number->bool',2).

  'number->bool'(X, A) :-
    u_assign([<, 0, X], A).

</span>

;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'bool->number',[->,'Bool','Number']])
</span><span class="ansi38-255165000">  (: bool->number 
    (-> Bool Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('bool->number'('False',0):-true))]
%~ [convert(_238458),head_preconds_into_body(('bool->number'('False',0):-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','False'],0)
</span><span class="ansi38-255165000">  (= 
    (bool->number False) 0)
</span><span class="ansi38-000082136">  :- dynamic('bool->number',2).

  'bool->number'('False', 0).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('bool->number'(_275030,1):-is_True(_275030)))]
%~ [convert(_275866),head_preconds_into_body(('bool->number'(_275030,1):-is_True(_275030)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','True'],1)
</span><span class="ansi38-255165000">  (= 
    (bool->number True) 1)
</span><span class="ansi38-000082136">  :- dynamic('bool->number',2).

  'bool->number'(A, 1) :-
    is_True(A).

</span>

;; Define a less than type.  Note that it is purposefully different
;; than â©» as it is a type, not an operator.  Inhabitants of (â x y)
;; are proofs that x â©» y == True.  For now â is only axiomatized for
;; Nat.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â\x8D\\x83\',[->,True,True,'Type']])
</span><span class="ansi38-255165000">  (: â 
    (-> $True $True Type))
</span>

;; Zero is always less than the successor of something
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['zero-lt-succ-axiom'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ['zero-lt-succ-axiom',Assign2] :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=_440708 ,
%~                              u_assign(['â\x8D\\x83\','Z',_440708],Assign1) ,
%~                              Assign1=_440738 ,
%~                              u_assign([:,'ZeroLTSucc',_440738],Assign2))]
%~ [convert(_341110),head_preconds_into_body((['zero-lt-succ-axiom',_339270]:-(((u_assign(['S',K],_341482),_341482=_341472),u_assign(['â\x8D\\x83\','Z',_341472],_341428)),_341428=_341418),u_assign([:,'ZeroLTSucc',_341418],_339270)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['zero-lt-succ-axiom'],[:,'ZeroLTSucc',['â\x8D\\x83\','Z',['S',K]]])
</span><span class="ansi38-255165000">  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (â Z 
        (S $K))))
</span><span class="ansi38-000082136">
  ['zero-lt-succ-axiom', A] :-
    ( u_assign(['S', K], B),
      B=C,
      u_assign(['â\u008D\u0083', 'Z', C], D)
    ),
    D=E,
    u_assign([:, 'ZeroLTSucc', E], A).

</span>

;; If x â y then (S x) â (S y)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['succ-monotonicity-rule'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ['succ-monotonicity-rule',Assign5] :-
%~                              u_assign(['â\x8D\\x83\',X,Y],Assign) ,
%~                              Assign=_126424 ,
%~                              u_assign(['S',X],Assign1) ,
%~                              Assign1=_126460 ,
%~                              u_assign(['S',Y],Assign2) ,
%~                              Assign2=_126478 ,
%~                              u_assign(['â\x8D\\x83\',_126460,_126478],Assign3) ,
%~                              Assign3=_126508 ,
%~                              u_assign([->,_126424,_126508],Assign4) ,
%~                              Assign4=_126538 ,
%~                              u_assign([:,'SuccMonotonicity',_126538],Assign5))]
%~ [convert(_4506),head_preconds_into_body((['succ-monotonicity-rule',_4482]:-((((u_assign(['â\x8D\\x83\',X,Y],_4576),_4576=_4572),(((u_assign(['S',X],_4652),_4652=_4648),u_assign(['S',Y],_4696),_4696=_4692),u_assign(['â\x8D\\x83\',_4648,_4692],_4626)),_4626=_4622),u_assign([->,_4572,_4622],_4550)),_4550=_4546),u_assign([:,'SuccMonotonicity',_4546],_4482)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['succ-monotonicity-rule'],[:,'SuccMonotonicity',[->,['â\x8D\\x83\',X,Y],['â\x8D\\x83\',['S',X],['S',Y]]]])
</span><span class="ansi38-255165000">  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (â $X $Y) 
        (â 
          (S $X) 
          (S $Y)))))
</span><span class="ansi38-000082136">
  ['succ-monotonicity-rule', A] :-
    ( ( u_assign(['â\u008D\u0083', X, Y], B),
        B=C
      ),
      ( ( u_assign(['S', X], D),
          D=E
        ),
        u_assign(['S', Y], F),
        F=G,
        u_assign(['â\u008D\u0083', E, G], H)
      ),
      H=I,
      u_assign([->, C, I], J)
    ),
    J=K,
    u_assign([:, 'SuccMonotonicity', K], A).

</span>

; Evaluation took 1517.18 ms.
<span class="ansi33"> &self

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'TruthValue','Type'])
</span><span class="ansi38-255165000">  (: TruthValue Type)
</span>

;;;;;;;;;;;;;;;;;;
;; Constructors ;;
;;;;;;;;;;;;;;;;;;
;; Boolean TV constructor
;; TODO: alternatively we could have (: â¤ TruthValue) and (: â¥ TruthValue)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Bl',[->,'Bool','TruthValue']])
</span><span class="ansi38-255165000">  (: Bl 
    (-> Bool TruthValue))
</span>

;; First order probability TV constructor, i.e. mere probability.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Pr',[->,'Number','TruthValue']])
</span><span class="ansi38-255165000">  (: Pr 
    (-> Number TruthValue))
</span>

;; Second order probability TV constructor, i.e. probability and
;; count.  The second order probability is distributed according to a
;; beta distribution.  The first argument of the constructor
;; represents the mode of the second order distribution.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'PrCnt',[->,'Number','Number','TruthValue']])
</span><span class="ansi38-255165000">  (: PrCnt 
    (-> Number Number TruthValue))
</span>

;; Simple Truth Value.  A Second order probability TV constructor,
;; i.e. probability and confidence.  The probability is in fact the
;; mode of the corresponding beta distribution.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'STV',[->,'Number','Number','TruthValue']])
</span><span class="ansi38-255165000">  (: STV 
    (-> Number Number TruthValue))
</span>

;;;;;;;;;;;;;;;
;; Constants ;;
;;;;;;;;;;;;;;;
;; For now the underlying beta distributions have a Jeffreys prior,
;; i.e. the prior alpha and beta are 0.5.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,prior_alpha,[->,'Number']])
</span><span class="ansi38-255165000">  (: prior_alpha 
    (-> Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(([prior_alpha,0.5]:-true))]
%~ [convert(_410122),head_preconds_into_body(([prior_alpha,0.5]:-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[prior_alpha],0.5)
</span><span class="ansi38-255165000">  (= 
    (prior_alpha) 0.5)
</span><span class="ansi38-000082136">
  [prior_alpha, 0.5].

</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,prior_beta,[->,'Number']])
</span><span class="ansi38-255165000">  (: prior_beta 
    (-> Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(([prior_beta,0.5]:-true))]
%~ [convert(_500752),head_preconds_into_body(([prior_beta,0.5]:-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[prior_beta],0.5)
</span><span class="ansi38-255165000">  (= 
    (prior_beta) 0.5)
</span><span class="ansi38-000082136">
  [prior_beta, 0.5].

</span>

;; Lookahead
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,lookahead,[->,'Number']])
</span><span class="ansi38-255165000">  (: lookahead 
    (-> Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(([lookahead,1.0]:-true))]
%~ [convert(_71064),head_preconds_into_body(([lookahead,1.0]:-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[lookahead],1.0)
</span><span class="ansi38-255165000">  (= 
    (lookahead) 1.0)
</span><span class="ansi38-000082136">
  [lookahead, 1.0].

</span>

;; Maximum supported count (till +inf is supported, possibly).
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'max-count',[->,'Number']])
</span><span class="ansi38-255165000">  (: max-count 
    (-> Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((['max-count',1000000000.0]:-true))]
%~ [convert(_161786),head_preconds_into_body((['max-count',1000000000.0]:-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['max-count'],1000000000.0)
</span><span class="ansi38-255165000">  (= 
    (max-count) 1000000000.0)
</span><span class="ansi38-000082136">
  ['max-count', 1000000000.0].

</span>

;;;;;;;;;;;;;
;; Methods ;;
;;;;;;;;;;;;;
;; Convert count to confidence using the formula
;;
;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'count->confidence',[->,'Number','Number']])
</span><span class="ansi38-255165000">  (: count->confidence 
    (-> Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'count->confidence'(Cnt,Count_c62_confidence_Cnt) :-
%~                              [lookahead,_352090] ,
%~                              _352090=_352098 ,
%~                              u_assign([+,Cnt,_352098],Assign) ,
%~                              Assign=_352128 ,
%~                              u_assign([/,Cnt,_352128],Count_c62_confidence_Cnt))]
%~ [convert(_253554),head_preconds_into_body(('count->confidence'(Cnt,_252388):-((([lookahead,_254562],_254562=_254552),u_assign([+,Cnt,_254552],_254464)),_254464=_254454),u_assign([/,Cnt,_254454],_252388)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['count->confidence',Cnt],[/,Cnt,[+,Cnt,[lookahead]]])
</span><span class="ansi38-255165000">  (= 
    (count->confidence $Cnt) 
    (/ $Cnt 
      (+ $Cnt 
        (lookahead))))
</span><span class="ansi38-000082136">  :- dynamic('count->confidence',2).

  'count->confidence'(Cnt, A) :-
    ( [lookahead, B],
      B=C,
      u_assign([+, Cnt, C], D)
    ),
    D=E,
    u_assign([/, Cnt, E], A).

</span>

;; Convert confidence to count using the formula
;;
;; count = (confidence * lookahead) / (1 - confidence)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'confidence->count',[->,'Number','Number']])
</span><span class="ansi38-255165000">  (: confidence->count 
    (-> Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'confidence->count'(Conf,Assign_Conf) :-
%~                              u_assign([approxEq,1.0,Conf,1.0e-9],Assign) ,
%~                              Assign=_105996 ,
%~                              ['max-count',_106018] ,
%~                              _106018=_106026 ,
%~                              [lookahead,_106072] ,
%~                              _106072=_106080 ,
%~                              u_assign([*,Conf,_106080],Assign2) ,
%~                              Assign2=_106110 ,
%~                              u_assign([-,1.0,Conf],Assign3) ,
%~                              Assign3=_106128 ,
%~                              u_assign([/,_106110,_106128],Assign4) ,
%~                              Assign4=_106158 ,
%~                              u_assign([if,_105996,_106026,_106158],Assign_Conf))]
%~ [convert(_4100),head_preconds_into_body(('confidence->count'(Conf,_4064):-((u_assign([approxEq,1.0,Conf,1.0e-9],_4138),_4138=_4134),(['max-count',_4194],_4194=_4190),((((([lookahead,_4284],_4284=_4280),u_assign([*,Conf,_4280],_4252)),_4252=_4248),u_assign([-,1.0,Conf],_4328),_4328=_4324),u_assign([/,_4248,_4324],_4226)),_4226=_4222),u_assign([if,_4134,_4190,_4222],_4064)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['confidence->count',Conf],[if,[approxEq,1.0,Conf,1.0e-9],['max-count'],[/,[*,Conf,[lookahead]],[-,1.0,Conf]]])
</span><span class="ansi38-255165000">  (= 
    (confidence->count $Conf) 
    (if 
      (approxEq 1.0 $Conf 1.0e-9) 
      (max-count) 
      (/ 
        (* $Conf 
          (lookahead)) 
        (- 1.0 $Conf))))
</span><span class="ansi38-000082136">  :- dynamic('confidence->count',2).

  'confidence->count'(Conf, A) :-
    ( u_assign([approxEq, 1.0, Conf, 1.0e-9], B),
      B=C
    ),
    ( ['max-count', D],
      D=E
    ),
    ( ( ( [lookahead, F],
          F=G
        ),
        u_assign([*, Conf, G], H),
        H=I
      ),
      u_assign([-, 1.0, Conf], J),
      J=K,
      u_assign([/, I, K], L)
    ),
    L=M,
    u_assign([if, C, E, M], A).

</span>

;; Increment the given count by 1
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'inc-count',[->,'Number','Number']])
</span><span class="ansi38-255165000">  (: inc-count 
    (-> Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'inc-count'(Cnt,Inc_count_Cnt) :-
%~                              u_assign([+,1,Cnt],Inc_count_Cnt))]
%~ [convert(_183328),head_preconds_into_body(('inc-count'(Cnt,_182162):-u_assign([+,1,Cnt],_182162)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['inc-count',Cnt],[+,1,Cnt])
</span><span class="ansi38-255165000">  (= 
    (inc-count $Cnt) 
    (+ 1 $Cnt))
</span><span class="ansi38-000082136">  :- dynamic('inc-count',2).

  'inc-count'(Cnt, A) :-
    u_assign([+, 1, Cnt], A).

</span>

;; Increment the corresponding count of the given confidence by 1 and
;; return the confidence of that corresponding incremented count.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'inc-confidence',[->,'Number','Number']])
</span><span class="ansi38-255165000">  (: inc-confidence 
    (-> Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'inc-confidence'(Conf,Assign_Conf) :-
%~                              u_assign(['confidence->count',Conf],Assign) ,
%~                              Assign=_383124 ,
%~                              u_assign(['inc-count',_383124],Assign2) ,
%~                              Assign2=_383148 ,
%~                              u_assign(['count->confidence',_383148],Assign_Conf))]
%~ [convert(_294696),head_preconds_into_body(('inc-confidence'(Conf,_293530):-(((u_assign(['confidence->count',Conf],_295044),_295044=_295034),u_assign(['inc-count',_295034],_295002)),_295002=_294992),u_assign(['count->confidence',_294992],_293530)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['inc-confidence',Conf],['count->confidence',['inc-count',['confidence->count',Conf]]])
</span><span class="ansi38-255165000">  (= 
    (inc-confidence $Conf) 
    (count->confidence 
      (inc-count 
        (confidence->count $Conf))))
</span><span class="ansi38-000082136">  :- dynamic('inc-confidence',2).

  'inc-confidence'(Conf, A) :-
    ( u_assign(['confidence->count', Conf], B),
      B=C,
      u_assign(['inc-count', C], D)
    ),
    D=E,
    u_assign(['count->confidence', E], A).

</span>

;; Return the strength of a truth value, given that its count has been
;; incremented by one but its positive count has not.
;;
;; The formula is derived from new_s = s*cnt / (cnt + 1), where cnt is
;; the count of the original truth value, that is cnt = c*k / (1-c).
;; Thus
;;
;; new_s = (s*c*k / (1-c)) / (c*k / (1-c) + 1)
;;       = (s*c*k / (1-c)) / ((c*k + 1-c) / (1-c))
;;       = (s*c*k) / (c*k + 1-c)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'inc-count-strength',[->,'Number','Number','Number']])
</span><span class="ansi38-255165000">  (: inc-count-strength 
    (-> Number Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'inc-count-strength'(S,C,Assign_C) :-
%~                              [lookahead,_157176] ,
%~                              _157176=_157184 ,
%~                              u_assign([*,C,_157184],Assign) ,
%~                              Assign=_157214 ,
%~                              u_assign([*,S,_157214],Assign2) ,
%~                              Assign2=_157244 ,
%~                              [lookahead,_157296] ,
%~                              _157296=_157304 ,
%~                              u_assign([*,C,_157304],Assign3) ,
%~                              Assign3=_157334 ,
%~                              u_assign([+,_157334,1],Assign4) ,
%~                              Assign4=_157358 ,
%~                              u_assign([-,_157358,C],Assign5) ,
%~                              Assign5=_157382 ,
%~                              u_assign([/,_157244,_157382],Assign_C))]
%~ [convert(_4092),head_preconds_into_body(('inc-count-strength'(S,C,_4050):-(((((([lookahead,_4194],_4194=_4190),u_assign([*,C,_4190],_4162)),_4162=_4158),u_assign([*,S,_4158],_4130)),_4130=_4126),(((((([lookahead,_4334],_4334=_4330),u_assign([*,C,_4330],_4302)),_4302=_4298),u_assign([+,_4298,1],_4276)),_4276=_4272),u_assign([-,_4272,C],_4250)),_4250=_4246),u_assign([/,_4126,_4246],_4050)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['inc-count-strength',S,C],[/,[*,S,[*,C,[lookahead]]],[-,[+,[*,C,[lookahead]],1],C]])
</span><span class="ansi38-255165000">  (= 
    (inc-count-strength $S $C) 
    (/ 
      (* $S 
        (* $C 
          (lookahead))) 
      (- 
        (+ 
          (* $C 
            (lookahead)) 1) $C)))
</span><span class="ansi38-000082136">  :- dynamic('inc-count-strength',3).

  'inc-count-strength'(S, C, A) :-
    ( ( ( [lookahead, B],
          B=C
        ),
        u_assign([*, C, C], D),
        D=E
      ),
      u_assign([*, S, E], F),
      F=G
    ),
    ( ( ( [lookahead, H],
          H=I,
          u_assign([*, C, I], J)
        ),
        J=K,
        u_assign([+, K, 1], L)
      ),
      L=M,
      u_assign([-, M, C], N)
    ),
    N=O,
    u_assign([/, G, O], A).

</span>

;; Return the first order probability mode of the second order
;; distribution associated to a truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,mode,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">  (: mode 
    (-> TruthValue Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mode(_270588,1.0) :-
%~                              is_True(True) ,
%~                              u_assign(['Bl',True],Assign) ,
%~                              Assign=_266566)]
%~ [convert(_219308),head_preconds_into_body((mode(_218404,1.0):-(is_True(_218446),u_assign(['Bl',_218446],_218414)),_218414=_218404))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mode,['Bl','True']],1.0)
</span><span class="ansi38-255165000">  (= 
    (mode 
      (Bl True)) 1.0)
</span><span class="ansi38-000082136">  :- dynamic(mode,2).

  mode(A, 1.0) :-
    is_True(B),
    u_assign(['Bl', B], C),
    C=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mode(_346160,0.0) :-
%~                              u_assign(['Bl','False'],Assign) ,
%~                              Assign=_342216)]
%~ [convert(_302968),head_preconds_into_body((mode(_302058,0.0):-u_assign(['Bl','False'],_302068),_302068=_302058))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mode,['Bl','False']],0.0)
</span><span class="ansi38-255165000">  (= 
    (mode 
      (Bl False)) 0.0)
</span><span class="ansi38-000082136">  :- dynamic(mode,2).

  mode(A, 0.0) :-
    u_assign(['Bl', 'False'], B),
    B=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mode(Pr,Pr) :-
%~                              u_assign(['Pr',Pr],Assign) ,
%~                              Assign=Pr)]
%~ [convert(_380080),head_preconds_into_body((mode(_379126,Pr):-u_assign(['Pr',Pr],_379136),_379136=_379126))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mode,['Pr',Pr]],Pr)
</span><span class="ansi38-255165000">  (= 
    (mode 
      (Pr $Pr)) $Pr)
</span><span class="ansi38-000082136">  :- dynamic(mode,2).

  mode(A, Pr) :-
    u_assign(['Pr', Pr], B),
    B=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mode(Pr,Pr) :-
%~                              u_assign(['PrCnt',Pr,_],Assign) ,
%~                              Assign=Pr)]
%~ [convert(_450844),head_preconds_into_body((mode(_449820,Pr):-u_assign(['PrCnt',Pr,_],_449830),_449830=_449820))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mode,['PrCnt',Pr,_]],Pr)
</span><span class="ansi38-255165000">  (= 
    (mode 
      (PrCnt $Pr $_)) $Pr)
</span><span class="ansi38-000082136">  :- dynamic(mode,2).

  mode(A, Pr) :-
    u_assign(['PrCnt', Pr, _], B),
    B=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mode(Pr,Pr) :-
%~                              u_assign(['STV',Pr,_],Assign) ,
%~                              Assign=Pr)]
%~ [convert(_6008),head_preconds_into_body((mode(_4984,Pr):-u_assign(['STV',Pr,_],_4994),_4994=_4984))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mode,['STV',Pr,_]],Pr)
</span><span class="ansi38-255165000">  (= 
    (mode 
      (STV $Pr $_)) $Pr)
</span><span class="ansi38-000082136">  :- dynamic(mode,2).

  mode(A, Pr) :-
    u_assign(['STV', Pr, _], B),
    B=A.

</span>

;; Return the total count of a truth value.  For truth values not
;; capturing a notion of confidence, such as Bl or Pr then the count
;; is assumed to be a very large number (cause +inf does not seem to
;; be supported at the moment).  For truth values capturing a notion
;; of confidence, such as PrCnt, the total count is the count
;; component of the truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,count,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">  (: count 
    (-> TruthValue Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( count(Count,Count1) :-
%~                              u_assign(['Bl',_],Assign) ,
%~                              Assign=Count ,
%~                              ['max-count',Count1])]
%~ [convert(_92010),head_preconds_into_body((count(_91056,_90776):-(u_assign(['Bl',_],_91066),_91066=_91056),['max-count',_90776]))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[count,['Bl',_]],['max-count'])
</span><span class="ansi38-255165000">  (= 
    (count 
      (Bl $_)) 
    (max-count))
</span><span class="ansi38-000082136">  :- dynamic(count,2).

  count(A, B) :-
    u_assign(['Bl', _], C),
    C=A,
    ['max-count', B].

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( count(Count,Count1) :-
%~                              u_assign(['Pr',_],Assign) ,
%~                              Assign=Count ,
%~                              ['max-count',Count1])]
%~ [convert(_171164),head_preconds_into_body((count(_170210,_169930):-(u_assign(['Pr',_],_170220),_170220=_170210),['max-count',_169930]))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[count,['Pr',_]],['max-count'])
</span><span class="ansi38-255165000">  (= 
    (count 
      (Pr $_)) 
    (max-count))
</span><span class="ansi38-000082136">  :- dynamic(count,2).

  count(A, B) :-
    u_assign(['Pr', _], C),
    C=A,
    ['max-count', B].

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( count(Cnt,Cnt) :-
%~                              u_assign(['PrCnt',_,Cnt],Assign) ,
%~                              Assign=Cnt)]
%~ [convert(_250804),head_preconds_into_body((count(_249780,Cnt):-u_assign(['PrCnt',_,Cnt],_249790),_249790=_249780))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[count,['PrCnt',_,Cnt]],Cnt)
</span><span class="ansi38-255165000">  (= 
    (count 
      (PrCnt $_ $Cnt)) $Cnt)
</span><span class="ansi38-000082136">  :- dynamic(count,2).

  count(A, Cnt) :-
    u_assign(['PrCnt', _, Cnt], B),
    B=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( count(Count,Assign_Count1) :-
%~                              u_assign(['STV',_,Conf],Assign) ,
%~                              Assign=Count ,
%~                              u_assign(['confidence->count',Conf],Assign_Count1))]
%~ [convert(_324804),head_preconds_into_body((count(_323780,_323500):-(u_assign(['STV',_,Conf],_323790),_323790=_323780),u_assign(['confidence->count',Conf],_323500)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[count,['STV',_,Conf]],['confidence->count',Conf])
</span><span class="ansi38-255165000">  (= 
    (count 
      (STV $_ $Conf)) 
    (confidence->count $Conf))
</span><span class="ansi38-000082136">  :- dynamic(count,2).

  count(A, B) :-
    u_assign(['STV', _, Conf], C),
    C=A,
    u_assign(['confidence->count', Conf], B).

</span>

;; Return the confidence of a truth value.  For truth values not
;; capturing a notion of confidence, such as Bl or Pr then the
;; confidence is assumed to be 1.0.  For truth values capturing a
;; notion of confidence, such as PrCnt, the formula to convert a count
;; into confidence is as follows
;;
;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,confidence,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">  (: confidence 
    (-> TruthValue Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( confidence(_457350,1.0) :-
%~                              u_assign(['Bl',_],Assign) ,
%~                              Assign=_453406)]
%~ [convert(_412476),head_preconds_into_body((confidence(_411522,1.0):-u_assign(['Bl',_],_411532),_411532=_411522))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[confidence,['Bl',_]],1.0)
</span><span class="ansi38-255165000">  (= 
    (confidence 
      (Bl $_)) 1.0)
</span><span class="ansi38-000082136">  :- dynamic(confidence,2).

  confidence(A, 1.0) :-
    u_assign(['Bl', _], B),
    B=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( confidence(_12336,1.0) :-
%~                              u_assign(['Pr',_],Assign) ,
%~                              Assign=_8392)]
%~ [convert(_4010),head_preconds_into_body((confidence(_3960,1.0):-u_assign(['Pr',_],_3964),_3964=_3960))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[confidence,['Pr',_]],1.0)
</span><span class="ansi38-255165000">  (= 
    (confidence 
      (Pr $_)) 1.0)
</span><span class="ansi38-000082136">  :- dynamic(confidence,2).

  confidence(A, 1.0) :-
    u_assign(['Pr', _], B),
    B=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( confidence(Confidence,Assign_Confidence1) :-
%~                              u_assign(['PrCnt',_,Cnt],Assign) ,
%~                              Assign=Confidence ,
%~                              u_assign(['count->confidence',Cnt],Assign_Confidence1))]
%~ [convert(_40930),head_preconds_into_body((confidence(_39906,_39626):-(u_assign(['PrCnt',_,Cnt],_39916),_39916=_39906),u_assign(['count->confidence',Cnt],_39626)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[confidence,['PrCnt',_,Cnt]],['count->confidence',Cnt])
</span><span class="ansi38-255165000">  (= 
    (confidence 
      (PrCnt $_ $Cnt)) 
    (count->confidence $Cnt))
</span><span class="ansi38-000082136">  :- dynamic(confidence,2).

  confidence(A, B) :-
    u_assign(['PrCnt', _, Cnt], C),
    C=A,
    u_assign(['count->confidence', Cnt], B).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( confidence(Conf,Conf) :-
%~                              u_assign(['STV',_,Conf],Assign) ,
%~                              Assign=Conf)]
%~ [convert(_117092),head_preconds_into_body((confidence(_116068,Conf):-u_assign(['STV',_,Conf],_116078),_116078=_116068))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[confidence,['STV',_,Conf]],Conf)
</span><span class="ansi38-255165000">  (= 
    (confidence 
      (STV $_ $Conf)) $Conf)
</span><span class="ansi38-000082136">  :- dynamic(confidence,2).

  confidence(A, Conf) :-
    u_assign(['STV', _, Conf], B),
    B=A.

</span>

;; Return the positive count of a truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,pos_count,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">  (: pos_count 
    (-> TruthValue Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( pos_count(Tv,Assign_Count_Tv) :-
%~                              u_assign([mode,Tv],Assign) ,
%~                              Assign=_276026 ,
%~                              u_assign([count,Tv],Assign3) ,
%~                              Assign3=_276044 ,
%~                              u_assign([*,_276026,_276044],Assign_Count_Tv))]
%~ [convert(_198962),head_preconds_into_body((pos_count(Tv,_197796):-((u_assign([mode,Tv],_199268),_199268=_199258),u_assign([count,Tv],_199402),_199402=_199392),u_assign([*,_199258,_199392],_197796)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[pos_count,Tv],[*,[mode,Tv],[count,Tv]])
</span><span class="ansi38-255165000">  (= 
    (pos_count $Tv) 
    (* 
      (mode $Tv) 
      (count $Tv)))
</span><span class="ansi38-000082136">  :- dynamic(pos_count,2).

  pos_count(Tv, A) :-
    ( u_assign([mode, Tv], B),
      B=C
    ),
    u_assign([count, Tv], D),
    D=E,
    u_assign([*, C, E], A).

</span>

;; Return the negative count of a truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,neg_count,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">  (: neg_count 
    (-> TruthValue Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( neg_count(Tv,Assign_Count_Tv) :-
%~                              u_assign([mode,Tv],Assign) ,
%~                              [-,1,Assign,_417672] ,
%~                              _417672=_417680 ,
%~                              u_assign([count,Tv],Assign3) ,
%~                              Assign3=_417698 ,
%~                              u_assign([*,_417680,_417698],Assign_Count_Tv))]
%~ [convert(_323424),head_preconds_into_body((neg_count(Tv,_322258):-(((u_assign([mode,Tv],_323790),[-,1,_323790,_323730]),_323730=_323720),u_assign([count,Tv],_323936),_323936=_323926),u_assign([*,_323720,_323926],_322258)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[neg_count,Tv],[*,[-,1,[mode,Tv]],[count,Tv]])
</span><span class="ansi38-255165000">  (= 
    (neg_count $Tv) 
    (* 
      (- 1 
        (mode $Tv)) 
      (count $Tv)))
</span><span class="ansi38-000082136">  :- dynamic(neg_count,2).

  neg_count(Tv, A) :-
    ( u_assign([mode, Tv], B),
      [-, 1, B, C],
      C=D
    ),
    u_assign([count, Tv], E),
    E=F,
    u_assign([*, D, F], A).

</span>

;; Return the posterior alpha of a truth value
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,post_alpha,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">  (: post_alpha 
    (-> TruthValue Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( post_alpha(Tv,Assign_Alpha_Tv) :-
%~                              [prior_alpha,_29494] ,
%~                              _29494=_29502 ,
%~                              u_assign([pos_count,Tv],Assign) ,
%~                              Assign=_29520 ,
%~                              u_assign([+,_29502,_29520],Assign_Alpha_Tv))]
%~ [convert(_3990),head_preconds_into_body((post_alpha(Tv,_3954):-(([prior_alpha,_4028],_4028=_4024),u_assign([pos_count,Tv],_4060),_4060=_4056),u_assign([+,_4024,_4056],_3954)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[post_alpha,Tv],[+,[prior_alpha],[pos_count,Tv]])
</span><span class="ansi38-255165000">  (= 
    (post_alpha $Tv) 
    (+ 
      (prior_alpha) 
      (pos_count $Tv)))
</span><span class="ansi38-000082136">  :- dynamic(post_alpha,2).

  post_alpha(Tv, A) :-
    ( [prior_alpha, B],
      B=C
    ),
    u_assign([pos_count, Tv], D),
    D=E,
    u_assign([+, C, E], A).

</span>

;; Return the posterior beta of a truth value
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,post_beta,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">  (: post_beta 
    (-> TruthValue Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( post_beta(Tv,Assign_Beta_Tv) :-
%~                              [prior_beta,_157450] ,
%~                              _157450=_157458 ,
%~                              u_assign([neg_count,Tv],Assign) ,
%~                              Assign=_157476 ,
%~                              u_assign([+,_157458,_157476],Assign_Beta_Tv))]
%~ [convert(_75774),head_preconds_into_body((post_beta(Tv,_74608):-(([prior_beta,_76548],_76548=_76538),u_assign([neg_count,Tv],_77096),_77096=_77086),u_assign([+,_76538,_77086],_74608)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[post_beta,Tv],[+,[prior_beta],[neg_count,Tv]])
</span><span class="ansi38-255165000">  (= 
    (post_beta $Tv) 
    (+ 
      (prior_beta) 
      (neg_count $Tv)))
</span><span class="ansi38-000082136">  :- dynamic(post_beta,2).

  post_beta(Tv, A) :-
    ( [prior_beta, B],
      B=C
    ),
    u_assign([neg_count, Tv], D),
    D=E,
    u_assign([+, C, E], A).

</span>

;; Return the first order probability mean of the second order
;; distribution associated to a truth value.  For truth values not
;; capturing a notion of confidence, such as Bl or Pr then the
;; confidence is assumed to be 1.0.  For truth values capturing a
;; notion of confidence, such as PrCnt, a beta distribution is
;; assumed.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,mean,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">  (: mean 
    (-> TruthValue Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mean(_242442,1.0) :-
%~                              is_True(True) ,
%~                              u_assign(['Bl',True],Assign) ,
%~                              Assign=_238420)]
%~ [convert(_191162),head_preconds_into_body((mean(_190258,1.0):-(is_True(_190300),u_assign(['Bl',_190300],_190268)),_190268=_190258))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mean,['Bl','True']],1.0)
</span><span class="ansi38-255165000">  (= 
    (mean 
      (Bl True)) 1.0)
</span><span class="ansi38-000082136">  :- dynamic(mean,2).

  mean(A, 1.0) :-
    is_True(B),
    u_assign(['Bl', B], C),
    C=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mean(_305186,0.0) :-
%~                              u_assign(['Bl','False'],Assign) ,
%~                              Assign=_301242)]
%~ [convert(_261994),head_preconds_into_body((mean(_261084,0.0):-u_assign(['Bl','False'],_261094),_261094=_261084))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mean,['Bl','False']],0.0)
</span><span class="ansi38-255165000">  (= 
    (mean 
      (Bl False)) 0.0)
</span><span class="ansi38-000082136">  :- dynamic(mean,2).

  mean(A, 0.0) :-
    u_assign(['Bl', 'False'], B),
    B=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mean(Pr,Pr) :-
%~                              u_assign(['Pr',Pr],Assign) ,
%~                              Assign=Pr)]
%~ [convert(_326278),head_preconds_into_body((mean(_325324,Pr):-u_assign(['Pr',Pr],_325334),_325334=_325324))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mean,['Pr',Pr]],Pr)
</span><span class="ansi38-255165000">  (= 
    (mean 
      (Pr $Pr)) $Pr)
</span><span class="ansi38-000082136">  :- dynamic(mean,2).

  mean(A, Pr) :-
    u_assign(['Pr', Pr], B),
    B=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mean(Mean,Assign_Mean1) :-
%~                              u_assign(['PrCnt',Pr,Cnt],Assign) ,
%~                              Assign=Mean ,
%~                              [ post_alpha,
%~                                ['PrCnt',Pr,Cnt]] =
%~                                A ,
%~                              [ post_beta,
%~                                ['PrCnt',Pr,Cnt]] =
%~                                B ,
%~                              u_assign([+,A,B],Assign3) ,
%~                              Assign3=_485216 ,
%~                              u_assign([/,A,_485216],Assign_Mean1))]
%~ [convert(_397204),head_preconds_into_body((mean(_396180,_395900):-(u_assign(['PrCnt',Pr,Cnt],_396190),_396190=_396180),([post_alpha,['PrCnt',Pr,Cnt]]=A,[post_beta,['PrCnt',Pr,Cnt]]=B),(u_assign([+,A,B],_399826),_399826=_399816),u_assign([/,A,_399816],_395900)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mean,['PrCnt',Pr,Cnt]],['let*',[[A,[post_alpha,['PrCnt',Pr,Cnt]]],[B,[post_beta,['PrCnt',Pr,Cnt]]]],[/,A,[+,A,B]]])
</span><span class="ansi38-255165000">  (= 
    (mean 
      (PrCnt $Pr $Cnt)) 
    (let* 
      ( ($A 
          (post_alpha 
            (PrCnt $Pr $Cnt))) 
        ($B 
          (post_beta 
            (PrCnt $Pr $Cnt)))) 
      (/ $A 
        (+ $A $B))))
</span><span class="ansi38-000082136">  :- dynamic(mean,2).

  mean(A, B) :-
    u_assign(['PrCnt', Pr, Cnt], C),
    C=A,
    [post_alpha, ['PrCnt', Pr, Cnt]]=A,
    [post_beta, ['PrCnt', Pr, Cnt]]=B,
    u_assign([+, A, B], D),
    D=E,
    u_assign([/, A, E], B).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mean(Mean,Assign_Mean1) :-
%~                              u_assign(['STV',Pr,Conf],Assign) ,
%~                              Assign=Mean ,
%~                              [ post_alpha,
%~                                ['STV',Pr,Conf]] =
%~                                A ,
%~                              [ post_beta,
%~                                ['STV',Pr,Conf]] =
%~                                B ,
%~                              u_assign([+,A,B],Assign3) ,
%~                              Assign3=_105538 ,
%~                              u_assign([/,A,_105538],Assign_Mean1))]
%~ [convert(_17530),head_preconds_into_body((mean(_16506,_16226):-(u_assign(['STV',Pr,Conf],_16516),_16516=_16506),([post_alpha,['STV',Pr,Conf]]=A,[post_beta,['STV',Pr,Conf]]=B),(u_assign([+,A,B],_20152),_20152=_20142),u_assign([/,A,_20142],_16226)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mean,['STV',Pr,Conf]],['let*',[[A,[post_alpha,['STV',Pr,Conf]]],[B,[post_beta,['STV',Pr,Conf]]]],[/,A,[+,A,B]]])
</span><span class="ansi38-255165000">  (= 
    (mean 
      (STV $Pr $Conf)) 
    (let* 
      ( ($A 
          (post_alpha 
            (STV $Pr $Conf))) 
        ($B 
          (post_beta 
            (STV $Pr $Conf)))) 
      (/ $A 
        (+ $A $B))))
</span><span class="ansi38-000082136">  :- dynamic(mean,2).

  mean(A, B) :-
    u_assign(['STV', Pr, Conf], C),
    C=A,
    [post_alpha, ['STV', Pr, Conf]]=A,
    [post_beta, ['STV', Pr, Conf]]=B,
    u_assign([+, A, B], D),
    D=E,
    u_assign([/, A, E], B).

</span>

; Evaluation took 4.07 seconds.
<span class="ansi33"> &self

</span><span class="ansi38-000068000">!(import! &self "../Num.metta")

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&self', '../Num.metta'], A).

</span>; Consistency Conditions
;; Collection of functions operating on numbers
;; Define max
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,max,[->,A,A,A]])
</span><span class="ansi38-255165000">  (: max 
    (-> $A $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( max(X,Y,Assign_Max_Y) :-
%~                              u_assign([>,X,Y],Assign) ,
%~                              Assign=_303540 ,
%~                              u_assign([if,_303540,X,Y],Assign_Max_Y))]
%~ [convert(_245198),head_preconds_into_body((max(X,Y,_243962):-(u_assign([>,X,Y],_245504),_245504=_245494),u_assign([if,_245494,X,Y],_243962)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[max,X,Y],[if,[>,X,Y],X,Y])
</span><span class="ansi38-255165000">  (= 
    (max $X $Y) 
    (if 
      (> $X $Y) $X $Y))
</span><span class="ansi38-000082136">  :- dynamic(max,3).

  max(X, Y, A) :-
    u_assign([>, X, Y], B),
    B=C,
    u_assign([if, C, X, Y], A).

</span>

;; Define min
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,min,[->,A,A,A]])
</span><span class="ansi38-255165000">  (: min 
    (-> $A $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( min(X,Y,Assign_Min_Y) :-
%~                              u_assign([<,X,Y],Assign) ,
%~                              Assign=_425236 ,
%~                              u_assign([if,_425236,X,Y],Assign_Min_Y))]
%~ [convert(_367506),head_preconds_into_body((min(X,Y,_366270):-(u_assign([<,X,Y],_367812),_367812=_367802),u_assign([if,_367802,X,Y],_366270)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[min,X,Y],[if,[<,X,Y],X,Y])
</span><span class="ansi38-255165000">  (= 
    (min $X $Y) 
    (if 
      (< $X $Y) $X $Y))
</span><span class="ansi38-000082136">  :- dynamic(min,3).

  min(X, Y, A) :-
    u_assign([<, X, Y], B),
    B=C,
    u_assign([if, C, X, Y], A).

</span>

;; Clamp a number to be within a certain range
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,clamp,[->,A,A,A,A]])
</span><span class="ansi38-255165000">  (: clamp 
    (-> $A $A $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( clamp(X,L,U,Assign_Clamp_U) :-
%~                              u_assign([min,U,X],Assign) ,
%~                              Assign=_32984 ,
%~                              u_assign([max,L,_32984],Assign_Clamp_U))]
%~ [convert(_4046),head_preconds_into_body((clamp(X,L,U,_3998):-(u_assign([min,U,X],_4090),_4090=_4086),u_assign([max,L,_4086],_3998)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[clamp,X,L,U],[max,L,[min,U,X]])
</span><span class="ansi38-255165000">  (= 
    (clamp $X $L $U) 
    (max $L 
      (min $U $X)))
</span><span class="ansi38-000082136">  :- dynamic(clamp,4).

  clamp(X, L, U, A) :-
    u_assign([min, U, X], B),
    B=C,
    u_assign([max, L, C], A).

</span>

;; Define abs
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,abs,[->,A,A]])
</span><span class="ansi38-255165000">  (: abs 
    (-> $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( abs(X,Assign_Abs_X) :-
%~                              u_assign([<,X,0],Assign) ,
%~                              Assign=_178418 ,
%~                              u_assign([*,-1,X],Assign3) ,
%~                              Assign3=_178436 ,
%~                              u_assign([if,_178418,_178436,X],Assign_Abs_X))]
%~ [convert(_92726),head_preconds_into_body((abs(X,_91560):-((u_assign([<,X,0],_93032),_93032=_93022),u_assign([*,-1,X],_93192),_93192=_93182),u_assign([if,_93022,_93182,X],_91560)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[abs,X],[if,[<,X,0],[*,-1,X],X])
</span><span class="ansi38-255165000">  (= 
    (abs $X) 
    (if 
      (< $X 0) 
      (* -1 $X) $X))
</span><span class="ansi38-000082136">
  abs(X, A) :-
    ( u_assign([<, X, 0], B),
      B=C
    ),
    u_assign([*, -1, X], D),
    D=E,
    u_assign([if, C, E, X], A).

</span>

;; Define <=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,<=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: <= 
    (-> $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( <=(X,Y,Assign_Y) :-
%~                              u_assign([<,X,Y],Assign) ,
%~                              Assign=_314348 ,
%~                              u_assign([==,X,Y],Assign2) ,
%~                              Assign2=_314366 ,
%~                              u_assign([or,_314348,_314366],Assign_Y))]
%~ [convert(_239312),head_preconds_into_body((<=(X,Y,_238076):-((u_assign([<,X,Y],_239618),_239618=_239608),u_assign([==,X,Y],_239822),_239822=_239812),u_assign([or,_239608,_239812],_238076)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[<=,X,Y],[or,[<,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">  (= 
    (<= $X $Y) 
    (or 
      (< $X $Y) 
      (== $X $Y)))
</span><span class="ansi38-000082136">  :- dynamic(<=,3).

  <=(X, Y, A) :-
    ( u_assign([<, X, Y], B),
      B=C
    ),
    u_assign([==, X, Y], D),
    D=E,
    u_assign([or, C, E], A).

</span>

;; Define >=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,>=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: >= 
    (-> $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( >=(X,Y,Assign_Y) :-
%~                              u_assign([>,X,Y],Assign) ,
%~                              Assign=_450134 ,
%~                              u_assign([==,X,Y],Assign2) ,
%~                              Assign2=_450152 ,
%~                              u_assign([or,_450134,_450152],Assign_Y))]
%~ [convert(_374486),head_preconds_into_body((>=(X,Y,_373250):-((u_assign([>,X,Y],_374792),_374792=_374782),u_assign([==,X,Y],_374996),_374996=_374986),u_assign([or,_374782,_374986],_373250)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[>=,X,Y],[or,[>,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">  (= 
    (>= $X $Y) 
    (or 
      (> $X $Y) 
      (== $X $Y)))
</span><span class="ansi38-000082136">  :- dynamic(>=,3).

  >=(X, Y, A) :-
    ( u_assign([>, X, Y], B),
      B=C
    ),
    u_assign([==, X, Y], D),
    D=E,
    u_assign([or, C, E], A).

</span>

;; Define approximately equal
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,approxEq,[->,A,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: approxEq 
    (-> $A $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( approxEq(X,Y,Epsilon,Assign_ApproxEq_Epsilon) :-
%~                              u_assign([-,X,Y],Assign) ,
%~                              Assign=_80772 ,
%~                              u_assign([abs,_80772],Assign3) ,
%~                              Assign3=_80796 ,
%~                              u_assign([<=,_80796,Epsilon],Assign_ApproxEq_Epsilon))]
%~ [convert(_4044),head_preconds_into_body((approxEq(X,Y,Epsilon,_3996):-(((u_assign([-,X,Y],_4108),_4108=_4104),u_assign([abs,_4104],_4082)),_4082=_4078),u_assign([<=,_4078,Epsilon],_3996)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[approxEq,X,Y,Epsilon],[<=,[abs,[-,X,Y]],Epsilon])
</span><span class="ansi38-255165000">  (= 
    (approxEq $X $Y $Epsilon) 
    (<= 
      (abs 
        (- $X $Y)) $Epsilon))
</span><span class="ansi38-000082136">  :- dynamic(approxEq,4).

  approxEq(X, Y, Epsilon, A) :-
    ( u_assign([-, X, Y], B),
      B=C,
      u_assign([abs, C], D)
    ),
    D=E,
    u_assign([<=, E, Epsilon], A).

</span>

;; Define Nat
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Nat','Type'])
</span><span class="ansi38-255165000">  (: Nat Type)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Z','Nat'])
</span><span class="ansi38-255165000">  (: Z Nat)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'S',[->,'Nat','Nat']])
</span><span class="ansi38-255165000">  (: S 
    (-> Nat Nat))
</span>

;; Define cast functions between Nat and Number
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNumber,[->,'Number','Nat']])
</span><span class="ansi38-255165000">  (: fromNumber 
    (-> Number Nat))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( fromNumber(N,N) :-
%~                              u_assign([<=,N,0],Assign) ,
%~                              Assign=_304578 ,
%~                              u_assign([-,N,1],Assign2) ,
%~                              Assign2=_304620 ,
%~                              u_assign([fromNumber,_304620],Assign3) ,
%~                              Assign3=_304644 ,
%~                              u_assign(['S',_304644],Assign4) ,
%~                              Assign4=_304668 ,
%~                              u_assign([if,_304578,'Z',_304668],N))]
%~ [convert(_182422),head_preconds_into_body((fromNumber(N,_181256):-((u_assign([<=,N,0],_182728),_182728=_182718),((((u_assign([-,N,1],_182984),_182984=_182974),u_assign([fromNumber,_182974],_182942)),_182942=_182932),u_assign(['S',_182932],_182900)),_182900=_182890),u_assign([if,_182718,'Z',_182890],_181256)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNumber,N],[if,[<=,N,0],'Z',['S',[fromNumber,[-,N,1]]]])
</span><span class="ansi38-255165000">  (= 
    (fromNumber $N) 
    (if 
      (<= $N 0) Z 
      (S 
        (fromNumber 
          (- $N 1)))))
</span><span class="ansi38-000082136">  :- dynamic(fromNumber,2).

  fromNumber(N, A) :-
    ( u_assign([<=, N, 0], B),
      B=C
    ),
    ( ( u_assign([-, N, 1], D),
        D=E,
        u_assign([fromNumber, E], F)
      ),
      F=G,
      u_assign(['S', G], H)
    ),
    H=I,
    u_assign([if, C, 'Z', I], A).

</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNat,[->,'Nat','Number']])
</span><span class="ansi38-255165000">  (: fromNat 
    (-> Nat Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((fromNat('Z',0):-true))]
%~ [convert(_351656),head_preconds_into_body((fromNat('Z',0):-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,'Z'],0)
</span><span class="ansi38-255165000">  (= 
    (fromNat Z) 0)
</span><span class="ansi38-000082136">  :- dynamic(fromNat,2).

  fromNat('Z', 0).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( fromNat(FromNat,FromNat1) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=FromNat ,
%~                              u_assign([fromNat,K],Assign3) ,
%~                              [+,1,Assign3,FromNat1])]
%~ [convert(_396812),head_preconds_into_body((fromNat(_395858,_395578):-(u_assign(['S',K],_395868),_395868=_395858),u_assign([fromNat,K],_397136),[+,1,_397136,_395578]))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,['S',K]],[+,1,[fromNat,K]])
</span><span class="ansi38-255165000">  (= 
    (fromNat 
      (S $K)) 
    (+ 1 
      (fromNat $K)))
</span><span class="ansi38-000082136">  :- dynamic(fromNat,2).

  fromNat(A, B) :-
    u_assign(['S', K], C),
    C=A,
    u_assign([fromNat, K], D),
    [+, 1, D, B].

</span>

;; Define a generic less than operator, â©», for Nat.  < cannot be used
;; because it is a built-in, its type is hardwired and cannot be
;; overloaded.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Nat','Nat','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Nat Nat Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('â©»'(_,'Z',_496166):-_496166='False'))]
%~ [convert(_3966),head_preconds_into_body(('â©»'(_,'Z',_3924):-_3924='False'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',_,'Z'],'False')
</span><span class="ansi38-255165000">  (= 
    (â©» $_ Z) False)
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(_, 'Z', A) :-
    A='False'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'('Z',Z,True) :-
%~                              u_assign(['S',_],Assign) ,
%~                              Assign=Z ,
%~                              True='True')]
%~ [convert(_27716),head_preconds_into_body(('â©»'('Z',_26748,_26456):-(u_assign(['S',_],_26758),_26758=_26748),_26456='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»','Z',['S',_]],'True')
</span><span class="ansi38-255165000">  (= 
    (â©» Z 
      (S $_)) True)
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'('Z', A, B) :-
    u_assign(['S', _], C),
    C=A,
    B='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'(Â1,Â,Assign_Â2) :-
%~                              u_assign(['S',X],Assign) ,
%~                              Assign=Â1 ,
%~                              u_assign(['S',Y],Assign4) ,
%~                              Assign4=Â ,
%~                              u_assign(['â©»',X,Y],Assign_Â2))]
%~ [convert(_99368),head_preconds_into_body(('â©»'(_98252,_98386,_97972):-((u_assign(['S',X],_98262),_98262=_98252),u_assign(['S',Y],_98396),_98396=_98386),u_assign(['â©»',X,Y],_97972)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',['S',X],['S',Y]],['â©»',X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» 
      (S $X) 
      (S $Y)) 
    (â©» $X $Y))
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(A, B, C) :-
    ( u_assign(['S', X], D),
      D=A
    ),
    u_assign(['S', Y], E),
    E=B,
    u_assign(['â©»', X, Y], C).

</span>

;; Overload â©» for Number.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Number','Number','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Number Number Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'(X,Y,Assign_Â_Y) :-
%~                              u_assign([<,X,Y],Assign_Â_Y))]
%~ [convert(_197068),head_preconds_into_body(('â©»'(X,Y,_195832):-u_assign([<,X,Y],_195832)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',X,Y],[<,X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» $X $Y) 
    (< $X $Y))
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(X, Y, A) :-
    u_assign([<, X, Y], A).

</span>

;; Return the ceiling of a non negative number.  If the number is
;; negative it returns 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,ceil,[->,'Number','Number']])
</span><span class="ansi38-255165000">  (: ceil 
    (-> Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ceil(N,Assign_Ceil_N) :-
%~                              u_assign([fromNumber,N],Assign) ,
%~                              Assign=_328526 ,
%~                              u_assign([fromNat,_328526],Assign_Ceil_N))]
%~ [convert(_272824),head_preconds_into_body((ceil(N,_271658):-(u_assign([fromNumber,N],_273130),_273130=_273120),u_assign([fromNat,_273120],_271658)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[ceil,N],[fromNat,[fromNumber,N]])
</span><span class="ansi38-255165000">  (= 
    (ceil $N) 
    (fromNat 
      (fromNumber $N)))
</span><span class="ansi38-000082136">  :- dynamic(ceil,2).

  ceil(N, A) :-
    u_assign([fromNumber, N], B),
    B=C,
    u_assign([fromNat, C], A).

</span>

;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'number->bool',[->,'Number','Bool']])
</span><span class="ansi38-255165000">  (: number->bool 
    (-> Number Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'number->bool'(X,Number_c62_bool_X) :-
%~                              u_assign([<,0,X],Number_c62_bool_X))]
%~ [convert(_369822),head_preconds_into_body(('number->bool'(X,_368656):-u_assign([<,0,X],_368656)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['number->bool',X],[<,0,X])
</span><span class="ansi38-255165000">  (= 
    (number->bool $X) 
    (< 0 $X))
</span><span class="ansi38-000082136">  :- dynamic('number->bool',2).

  'number->bool'(X, A) :-
    u_assign([<, 0, X], A).

</span>

;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'bool->number',[->,'Bool','Number']])
</span><span class="ansi38-255165000">  (: bool->number 
    (-> Bool Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('bool->number'('False',0):-true))]
%~ [convert(_440310),head_preconds_into_body(('bool->number'('False',0):-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','False'],0)
</span><span class="ansi38-255165000">  (= 
    (bool->number False) 0)
</span><span class="ansi38-000082136">  :- dynamic('bool->number',2).

  'bool->number'('False', 0).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('bool->number'(_476882,1):-is_True(_476882)))]
%~ [convert(_477718),head_preconds_into_body(('bool->number'(_476882,1):-is_True(_476882)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','True'],1)
</span><span class="ansi38-255165000">  (= 
    (bool->number True) 1)
</span><span class="ansi38-000082136">  :- dynamic('bool->number',2).

  'bool->number'(A, 1) :-
    is_True(A).

</span>

;; Define a less than type.  Note that it is purposefully different
;; than â©» as it is a type, not an operator.  Inhabitants of (â x y)
;; are proofs that x â©» y == True.  For now â is only axiomatized for
;; Nat.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â\x8D\\x83\',[->,True,True,'Type']])
</span><span class="ansi38-255165000">  (: â 
    (-> $True $True Type))
</span>

;; Zero is always less than the successor of something
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['zero-lt-succ-axiom'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ['zero-lt-succ-axiom',Assign2] :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=_121226 ,
%~                              u_assign(['â\x8D\\x83\','Z',_121226],Assign1) ,
%~                              Assign1=_121256 ,
%~                              u_assign([:,'ZeroLTSucc',_121256],Assign2))]
%~ [convert(_21628),head_preconds_into_body((['zero-lt-succ-axiom',_19788]:-(((u_assign(['S',K],_22000),_22000=_21990),u_assign(['â\x8D\\x83\','Z',_21990],_21946)),_21946=_21936),u_assign([:,'ZeroLTSucc',_21936],_19788)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['zero-lt-succ-axiom'],[:,'ZeroLTSucc',['â\x8D\\x83\','Z',['S',K]]])
</span><span class="ansi38-255165000">  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (â Z 
        (S $K))))
</span><span class="ansi38-000082136">
  ['zero-lt-succ-axiom', A] :-
    ( u_assign(['S', K], B),
      B=C,
      u_assign(['â\u008D\u0083', 'Z', C], D)
    ),
    D=E,
    u_assign([:, 'ZeroLTSucc', E], A).

</span>

;; If x â y then (S x) â (S y)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['succ-monotonicity-rule'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ['succ-monotonicity-rule',Assign5] :-
%~                              u_assign(['â\x8D\\x83\',X,Y],Assign) ,
%~                              Assign=_321566 ,
%~                              u_assign(['S',X],Assign1) ,
%~                              Assign1=_321602 ,
%~                              u_assign(['S',Y],Assign2) ,
%~                              Assign2=_321620 ,
%~                              u_assign(['â\x8D\\x83\',_321602,_321620],Assign3) ,
%~                              Assign3=_321650 ,
%~                              u_assign([->,_321566,_321650],Assign4) ,
%~                              Assign4=_321680 ,
%~                              u_assign([:,'SuccMonotonicity',_321680],Assign5))]
%~ [convert(_160870),head_preconds_into_body((['succ-monotonicity-rule',_159030]:-((((u_assign(['â\x8D\\x83\',X,Y],_161230),_161230=_161220),(((u_assign(['S',X],_161476),_161476=_161466),u_assign(['S',Y],_161610),_161610=_161600),u_assign(['â\x8D\\x83\',_161466,_161600],_161434)),_161434=_161424),u_assign([->,_161220,_161424],_161188)),_161188=_161178),u_assign([:,'SuccMonotonicity',_161178],_159030)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['succ-monotonicity-rule'],[:,'SuccMonotonicity',[->,['â\x8D\\x83\',X,Y],['â\x8D\\x83\',['S',X],['S',Y]]]])
</span><span class="ansi38-255165000">  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (â $X $Y) 
        (â 
          (S $X) 
          (S $Y)))))
</span><span class="ansi38-000082136">
  ['succ-monotonicity-rule', A] :-
    ( ( u_assign(['â\u008D\u0083', X, Y], B),
        B=C
      ),
      ( ( u_assign(['S', X], D),
          D=E
        ),
        u_assign(['S', Y], F),
        F=G,
        u_assign(['â\u008D\u0083', E, G], H)
      ),
      H=I,
      u_assign([->, C, I], J)
    ),
    J=K,
    u_assign([:, 'SuccMonotonicity', K], A).

</span>

; Evaluation took 1431.91 ms.
<span class="ansi33"> &self

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'smallest-intersection-probability',[->,'Number','Number','Number']])
</span><span class="ansi38-255165000">  (: smallest-intersection-probability 
    (-> Number Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'smallest-intersection-probability'(As,Bs,Smallest_intersection_probability_Bs) :-
%~                              u_assign([+,As,Bs],Assign) ,
%~                              Assign=_7436 ,
%~                              u_assign([-,_7436,1],Assign3) ,
%~                              Assign3=_7460 ,
%~                              u_assign([/,_7460,As],Assign4) ,
%~                              Assign4=_7484 ,
%~                              u_assign([clamp,_7484,0,1],Smallest_intersection_probability_Bs))]
%~ [convert(_3594),head_preconds_into_body(('smallest-intersection-probability'(As,Bs,_3552):-(((((u_assign([+,As,Bs],_3684),_3684=_3680),u_assign([-,_3680,1],_3658)),_3658=_3654),u_assign([/,_3654,As],_3632)),_3632=_3628),u_assign([clamp,_3628,0,1],_3552)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['smallest-intersection-probability',As,Bs],[clamp,[/,[-,[+,As,Bs],1],As],0,1])
</span><span class="ansi38-255165000">  (= 
    (smallest-intersection-probability $As $Bs) 
    (clamp 
      (/ 
        (- 
          (+ $As $Bs) 1) $As) 0 1))
</span><span class="ansi38-000082136">  :- dynamic('smallest-intersection-probability',3).

  'smallest-intersection-probability'(As, Bs, A) :-
    ( ( u_assign([+, As, Bs], B),
        B=C,
        u_assign([-, C, 1], D)
      ),
      D=E,
      u_assign([/, E, As], F)
    ),
    F=G,
    u_assign([clamp, G, 0, 1], A).

</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'largest-intersection-probability',[->,'Number','Number','Number']])
</span><span class="ansi38-255165000">  (: largest-intersection-probability 
    (-> Number Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'largest-intersection-probability'(As,Bs,Largest_intersection_probability_Bs) :-
%~                              u_assign([/,Bs,As],Assign) ,
%~                              Assign=_138452 ,
%~                              u_assign([clamp,_138452,0,1],Largest_intersection_probability_Bs))]
%~ [convert(_67964),head_preconds_into_body(('largest-intersection-probability'(As,Bs,_66728):-(u_assign([/,Bs,As],_68270),_68270=_68260),u_assign([clamp,_68260,0,1],_66728)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['largest-intersection-probability',As,Bs],[clamp,[/,Bs,As],0,1])
</span><span class="ansi38-255165000">  (= 
    (largest-intersection-probability $As $Bs) 
    (clamp 
      (/ $Bs $As) 0 1))
</span><span class="ansi38-000082136">  :- dynamic('largest-intersection-probability',3).

  'largest-intersection-probability'(As, Bs, A) :-
    u_assign([/, Bs, As], B),
    B=C,
    u_assign([clamp, C, 0, 1], A).

</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'conditional-probability-consistency',[->,'Number','Number','Number','Bool']])
</span><span class="ansi38-255165000">  (: conditional-probability-consistency 
    (-> Number Number Number Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'conditional-probability-consistency'( As,
%~                              Bs,  ABs, Conditional_probability_consistency_True_Bs) :-
%~                              Conditional_probability_consistency_True_Bs='True')]
%~ [convert(_199512),head_preconds_into_body(('conditional-probability-consistency'(As,Bs,ABs,_198206):-_198206='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['conditional-probability-consistency',As,Bs,ABs],'True')
</span><span class="ansi38-255165000">  (= 
    (conditional-probability-consistency $As $Bs $ABs) True)
</span><span class="ansi38-000082136">  :- dynamic('conditional-probability-consistency',4).

  'conditional-probability-consistency'(As, Bs, ABs, A) :-
    A='True'.

</span>

;; (and (< 0 $As)
;;      (and (<= (smallest-intersection-probability $As $Bs) $ABs)
;;           (<= $ABs (largest-intersection-probability $As $Bs)))))
;; Main Formula
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'simple-deduction-strength-formula',[->,'Number','Number','Number','Number','Number','Number']])
</span><span class="ansi38-255165000">  (: simple-deduction-strength-formula 
    (-> Number Number Number Number Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'simple-deduction-strength-formula'( As,
%~                              Bs, Cs,ABs,BCs,
%~                              Simple_deduction_strength_formula_Cs) :-
%~                              u_assign( ['conditional-probability-consistency',As,Bs,ABs],
%~                                Assign_True) ,
%~                              Assign_True='True' ,
%~                              u_assign( ['conditional-probability-consistency',Bs,Cs,BCs],
%~                                Assign) ,
%~                              Assign=_174888 ,
%~                              u_assign([<,0.99,Bs],Assign5) ,
%~                              Assign5=_174924 ,
%~                              u_assign([*,ABs,BCs],Assign6) ,
%~                              Assign6=_174960 ,
%~                              u_assign([-,1,ABs],Assign7) ,
%~                              Assign7=_175014 ,
%~                              u_assign([*,Bs,BCs],Assign8) ,
%~                              Assign8=_175044 ,
%~                              u_assign([-,Cs,_175044],Assign9) ,
%~                              Assign9=_175074 ,
%~                              u_assign([*,_175014,_175074],Assign10) ,
%~                              Assign10=_175104 ,
%~                              u_assign([-,1,Bs],Assign11) ,
%~                              Assign11=_175122 ,
%~                              u_assign([/,_175104,_175122],Assign12) ,
%~                              Assign12=_175152 ,
%~                              u_assign([+,_174960,_175152],Assign13) ,
%~                              Assign13=_175182 ,
%~                              u_assign([if,_174924,Cs,_175182],Assign14) ,
%~                              Assign14=_175218 ,
%~                              u_assign([if,_174888,_175218,0],Simple_deduction_strength_formula_Cs))]
%~ [convert(_3906),head_preconds_into_body(('simple-deduction-strength-formula'(As,Bs,Cs,ABs,BCs,_3846):-(((u_assign(['conditional-probability-consistency',As,Bs,ABs],_3946),_3946='True',u_assign(['conditional-probability-consistency',Bs,Cs,BCs],_3944)),_3944=_3940),(((u_assign([<,0.99,Bs],_4082),_4082=_4078),(((u_assign([*,ABs,BCs],_4164),_4164=_4160),((((((u_assign([-,1,ABs],_4266),_4266=_4262),((u_assign([*,Bs,BCs],_4348),_4348=_4344),u_assign([-,Cs,_4344],_4316)),_4316=_4312),u_assign([*,_4262,_4312],_4240)),_4240=_4236),u_assign([-,1,Bs],_4428),_4428=_4424),u_assign([/,_4236,_4424],_4214)),_4214=_4210),u_assign([+,_4160,_4210],_4138)),_4138=_4134),u_assign([if,_4078,Cs,_4134],_4056)),_4056=_4052),u_assign([if,_3940,_4052,0],_3846)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['simple-deduction-strength-formula',As,Bs,Cs,ABs,BCs],[if,[and,['conditional-probability-consistency',As,Bs,ABs],['conditional-probability-consistency',Bs,Cs,BCs]],[if,[<,0.99,Bs],Cs,[+,[*,ABs,BCs],[/,[*,[-,1,ABs],[-,Cs,[*,Bs,BCs]]],[-,1,Bs]]]],0])
</span><span class="ansi38-255165000">  (= 
    (simple-deduction-strength-formula $As $Bs $Cs $ABs $BCs) 
    (if 
      (and 
        (conditional-probability-consistency $As $Bs $ABs) 
        (conditional-probability-consistency $Bs $Cs $BCs)) 
      (if 
        (< 0.99 $Bs) $Cs 
        (+ 
          (* $ABs $BCs) 
          (/ 
            (* 
              (- 1 $ABs) 
              (- $Cs 
                (* $Bs $BCs))) 
            (- 1 $Bs)))) 0))
</span><span class="ansi38-000082136">  :- dynamic('simple-deduction-strength-formula',6).

  'simple-deduction-strength-formula'(As,
                                      Bs,
                                      Cs,
                                      ABs,
                                      BCs,
                                      A) :-
    ( u_assign([ 'conditional-probability-consistency',
                 As,
                 Bs,
                 ABs
               ],
               B),
      B='True',
      u_assign([ 'conditional-probability-consistency',
                 Bs,
                 Cs,
                 BCs
               ],
               C),
      C=D
    ),
    ( ( u_assign([<, 0.99, Bs], E),
        E=F
      ),
      ( ( u_assign([*, ABs, BCs], G),
          G=H
        ),
        ( ( ( u_assign([-, 1, ABs], I),
              I=J,
              ( u_assign([*, Bs, BCs], K),
                K=L
              ),
              u_assign([-, Cs, L], M),
              M=N
            ),
            u_assign([*, J, N], O),
            O=P
          ),
          u_assign([-, 1, Bs], Q),
          Q=R,
          u_assign([/, P, R], S)
        ),
        S=T,
        u_assign([+, H, T], U)
      ),
      U=V,
      u_assign([if, F, Cs, V], W)
    ),
    W=X,
    u_assign([if, D, X, 0], A).

</span>

;; Preconditions are met
;; sB tends to 1
;; otherwise
;; Preconditions are not met
;; Deduction formula
%~ [ convert(Convert),
%~   head_preconds_into_body( ded_formula(Ptv,Qtv,Rtv,Pqtv,Qrtv,Assign_Formula_Qrtv) :-
%~                              [confidence,Ptv]=Pc ,
%~                              [confidence,Qtv]=Qc ,
%~                              [confidence,Rtv]=Rc ,
%~                              [confidence,Pqtv]=PQc ,
%~                              [confidence,Qrtv]=QRc ,
%~                              [mode,Pqtv]=PQs ,
%~                              [mode,Qrtv]=QRs ,
%~                              [mode,Ptv]=Ps ,
%~                              [mode,Qtv]=Qs ,
%~                              [mode,Rtv]=Rs ,
%~                              [ 'simple-deduction-strength-formula', Ps,Qs,Rs,
%~                                PQs,QRs] =
%~                                PRs ,
%~                              [ min,
%~                                Pc,
%~                                [ min,
%~                                  Qc,
%~                                  [ min,
%~                                    Rc,
%~                                    [min,PQc,QRc]]]] =
%~                                PRc ,
%~                              u_assign([==,PRs,0],Assign) ,
%~                              Assign=_456620 ,
%~                              u_assign(['PrCnt',1,0],Assign3) ,
%~                              Assign3=_456644 ,
%~                              u_assign(['PrCnt',PRs,PRs],Assign4) ,
%~                              Assign4=_456662 ,
%~                              u_assign([if,_456620,_456644,_456662],Assign_Formula_Qrtv))]
%~ [convert(_287850),head_preconds_into_body((ded_formula(Ptv,Qtv,Rtv,Pqtv,Qrtv,_286404):-([confidence,Ptv]=Pc,[confidence,Qtv]=Qc,[confidence,Rtv]=Rc,[confidence,Pqtv]=PQc,[confidence,Qrtv]=QRc,[mode,Pqtv]=PQs,[mode,Qrtv]=QRs,[mode,Ptv]=Ps,[mode,Qtv]=Qs,[mode,Rtv]=Rs),(['simple-deduction-strength-formula',Ps,Qs,Rs,PQs,QRs]=PRs,[min,Pc,[min,Qc,[min,Rc,[min,PQc,QRc]]]]=PRc),((u_assign([==,PRs,0],_299636),_299636=_299626),(u_assign(['PrCnt',1,0],_299796),_299796=_299786),u_assign(['PrCnt',PRs,PRs],_299912),_299912=_299902),u_assign([if,_299626,_299786,_299902],_286404)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[ded_formula,Ptv,Qtv,Rtv,Pqtv,Qrtv],['let*',[[Pc,[confidence,Ptv]],[Qc,[confidence,Qtv]],[Rc,[confidence,Rtv]],[PQc,[confidence,Pqtv]],[QRc,[confidence,Qrtv]],[PQs,[mode,Pqtv]],[QRs,[mode,Qrtv]],[Ps,[mode,Ptv]],[Qs,[mode,Qtv]],[Rs,[mode,Rtv]]],['let*',[[PRs,['simple-deduction-strength-formula',Ps,Qs,Rs,PQs,QRs]],[PRc,[min,Pc,[min,Qc,[min,Rc,[min,PQc,QRc]]]]]],[if,[==,PRs,0],['PrCnt',1,0],['PrCnt',PRs,PRs]]]])
</span><span class="ansi38-255165000">  (= 
    (ded_formula $Ptv $Qtv $Rtv $Pqtv $Qrtv) 
    (let* 
      ( ($Pc 
          (confidence $Ptv)) 
        ($Qc 
          (confidence $Qtv)) 
        ($Rc 
          (confidence $Rtv)) 
        ($PQc 
          (confidence $Pqtv)) 
        ($QRc 
          (confidence $Qrtv)) 
        ($PQs 
          (mode $Pqtv)) 
        ($QRs 
          (mode $Qrtv)) 
        ($Ps 
          (mode $Ptv)) 
        ($Qs 
          (mode $Qtv)) 
        ($Rs 
          (mode $Rtv))) 
      (let* 
        ( ($PRs 
            (simple-deduction-strength-formula $Ps $Qs $Rs $PQs $QRs)) 
          ($PRc 
            (min $Pc 
              (min $Qc 
                (min $Rc 
                  (min $PQc $QRc)))))) 
        (if 
          (== $PRs 0) 
          (PrCnt 1 0) 
          (PrCnt $PRs $PRs)))))
</span><span class="ansi38-000082136">  :- dynamic(ded_formula,6).

  ded_formula(Ptv, Qtv, Rtv, Pqtv, Qrtv, A) :-
    [confidence, Ptv]=Pc,
    [confidence, Qtv]=Qc,
    [confidence, Rtv]=Rc,
    [confidence, Pqtv]=PQc,
    [confidence, Qrtv]=QRc,
    [mode, Pqtv]=PQs,
    [mode, Qrtv]=QRs,
    [mode, Ptv]=Ps,
    [mode, Qtv]=Qs,
    [mode, Rtv]=Rs,
    ['simple-deduction-strength-formula', Ps, Qs, Rs, PQs, QRs]=PRs,
    [min, Pc, [min, Qc, [min, Rc, [min, PQc, QRc]]]]=PRc,
    ( u_assign([==, PRs, 0], B),
      B=C
    ),
    ( u_assign(['PrCnt', 1, 0], D),
      D=E
    ),
    u_assign(['PrCnt', PRs, PRs], F),
    F=G,
    u_assign([if, C, E, G], A).

</span>

;; Alternate deduction formula hardwired for STV to make it faster.
%~ [ convert(Convert),
%~   head_preconds_into_body( 'deduction-formula'( Deduction_formula4,
%~                              Deduction_formula3,  Deduction_formula2, Deduction_formula1, Deduction_formula, Assign_Deduction_formula6) :-
%~                              u_assign(['STV',Ps,Pc],Assign) ,
%~                              Assign=Deduction_formula4 ,
%~                              u_assign(['STV',Qs,Qc],Assign8) ,
%~                              Assign8=Deduction_formula3 ,
%~                              u_assign(['STV',Rs,Rc],Assign9) ,
%~                              Assign9=Deduction_formula2 ,
%~                              u_assign(['STV',PQs,PQc],Assign10) ,
%~                              Assign10=Deduction_formula1 ,
%~                              u_assign(['STV',QRs,QRc],Assign11) ,
%~                              Assign11=Deduction_formula ,
%~                              u_assign( ['conditional-probability-consistency',Ps,Qs,PQs],
%~                                Assign_True) ,
%~                              Assign_True='True' ,
%~                              u_assign( ['conditional-probability-consistency',Qs,Rs,QRs],
%~                                Assign13) ,
%~                              Assign13=_109164 ,
%~                              u_assign([<,0.9999,Qs],Assign14) ,
%~                              Assign14=_109224 ,
%~                              u_assign([*,PQs,QRs],Assign15) ,
%~                              Assign15=_109260 ,
%~                              u_assign([-,1,PQs],Assign16) ,
%~                              Assign16=_109314 ,
%~                              u_assign([*,Qs,QRs],Assign17) ,
%~                              Assign17=_109344 ,
%~                              u_assign([-,Rs,_109344],Assign18) ,
%~                              Assign18=_109374 ,
%~                              u_assign([*,_109314,_109374],Assign19) ,
%~                              Assign19=_109404 ,
%~                              u_assign([-,1,Qs],Assign20) ,
%~                              Assign20=_109422 ,
%~                              u_assign([/,_109404,_109422],Assign21) ,
%~                              Assign21=_109452 ,
%~                              u_assign([+,_109260,_109452],Assign22) ,
%~                              Assign22=_109482 ,
%~                              u_assign([if,_109224,Rs,_109482],Assign23) ,
%~                              Assign23=_109518 ,
%~                              u_assign([min,PQc,QRc],Assign24) ,
%~                              Assign24=_109572 ,
%~                              u_assign([min,Rc,_109572],Assign25) ,
%~                              Assign25=_109602 ,
%~                              u_assign([min,Qc,_109602],Assign26) ,
%~                              Assign26=_109632 ,
%~                              u_assign([min,Pc,_109632],Assign27) ,
%~                              Assign27=_109662 ,
%~                              u_assign(['STV',_109518,_109662],Assign28) ,
%~                              Assign28=_109692 ,
%~                              u_assign(['STV',1,0],Assign29) ,
%~                              Assign29=_109710 ,
%~                              u_assign([if,_109164,_109692,_109710],Assign_Deduction_formula6))]
%~ [convert(_4350),head_preconds_into_body(('deduction-formula'(_4070,_4120,_4170,_4220,_4270,_4046):-((u_assign(['STV',Ps,Pc],_4074),_4074=_4070),(u_assign(['STV',Qs,Qc],_4124),_4124=_4120),(u_assign(['STV',Rs,Rc],_4174),_4174=_4170),(u_assign(['STV',PQs,PQc],_4224),_4224=_4220),u_assign(['STV',QRs,QRc],_4274),_4274=_4270),(((u_assign(['conditional-probability-consistency',Ps,Qs,PQs],_4390),_4390='True',u_assign(['conditional-probability-consistency',Qs,Rs,QRs],_4388)),_4388=_4384),(((((((u_assign([<,0.9999,Qs],_4552),_4552=_4548),(((u_assign([*,PQs,QRs],_4634),_4634=_4630),((((((u_assign([-,1,PQs],_4736),_4736=_4732),((u_assign([*,Qs,QRs],_4818),_4818=_4814),u_assign([-,Rs,_4814],_4786)),_4786=_4782),u_assign([*,_4732,_4782],_4710)),_4710=_4706),u_assign([-,1,Qs],_4898),_4898=_4894),u_assign([/,_4706,_4894],_4684)),_4684=_4680),u_assign([+,_4630,_4680],_4608)),_4608=_4604),u_assign([if,_4548,Rs,_4604],_4526)),_4526=_4522),((((((u_assign([min,PQc,QRc],_5098),_5098=_5094),u_assign([min,Rc,_5094],_5066)),_5066=_5062),u_assign([min,Qc,_5062],_5034)),_5034=_5030),u_assign([min,Pc,_5030],_5002)),_5002=_4998),u_assign(['STV',_4522,_4998],_4500)),_4500=_4496),u_assign(['STV',1,0],_5202),_5202=_5198),u_assign([if,_4384,_4496,_5198],_4046)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['deduction-formula',['STV',Ps,Pc],['STV',Qs,Qc],['STV',Rs,Rc],['STV',PQs,PQc],['STV',QRs,QRc]],[if,[and,['conditional-probability-consistency',Ps,Qs,PQs],['conditional-probability-consistency',Qs,Rs,QRs]],['STV',[if,[<,0.9999,Qs],Rs,[+,[*,PQs,QRs],[/,[*,[-,1,PQs],[-,Rs,[*,Qs,QRs]]],[-,1,Qs]]]],[min,Pc,[min,Qc,[min,Rc,[min,PQc,QRc]]]]],['STV',1,0]])
</span><span class="ansi38-255165000">  (= 
    (deduction-formula 
      (STV $Ps $Pc) 
      (STV $Qs $Qc) 
      (STV $Rs $Rc) 
      (STV $PQs $PQc) 
      (STV $QRs $QRc)) 
    (if 
      (and 
        (conditional-probability-consistency $Ps $Qs $PQs) 
        (conditional-probability-consistency $Qs $Rs $QRs)) 
      (STV 
        (if 
          (< 0.9999 $Qs) $Rs 
          (+ 
            (* $PQs $QRs) 
            (/ 
              (* 
                (- 1 $PQs) 
                (- $Rs 
                  (* $Qs $QRs))) 
              (- 1 $Qs)))) 
        (min $Pc 
          (min $Qc 
            (min $Rc 
              (min $PQc $QRc))))) 
      (STV 1 0)))
</span><span class="ansi38-000082136">  :- dynamic('deduction-formula',6).

  'deduction-formula'(A, B, C, D, E, F) :-
    ( u_assign(['STV', Ps, Pc], G),
      G=A
    ),
    ( u_assign(['STV', Qs, Qc], H),
      H=B
    ),
    ( u_assign(['STV', Rs, Rc], I),
      I=C
    ),
    ( u_assign(['STV', PQs, PQc], J),
      J=D
    ),
    u_assign(['STV', QRs, QRc], K),
    K=E,
    ( u_assign([ 'conditional-probability-consistency',
                 Ps,
                 Qs,
                 PQs
               ],
               L),
      L='True',
      u_assign([ 'conditional-probability-consistency',
                 Qs,
                 Rs,
                 QRs
               ],
               M),
      M=N
    ),
    ( ( ( ( u_assign([<, 0.9999, Qs], O),
            O=P
          ),
          ( ( u_assign([*, PQs, QRs], Q),
              Q=R
            ),
            ( ( ( u_assign([-, 1, PQs], S),
                  S=T,
                  ( u_assign([*, Qs, QRs], U),
                    U=V
                  ),
                  u_assign([-, Rs, V], W),
                  W=X
                ),
                u_assign([*, T, X], Y),
                Y=Z
              ),
              u_assign([-, 1, Qs], A1),
              A1=B1,
              u_assign([/, Z, B1], C1)
            ),
            C1=D1,
            u_assign([+, R, D1], E1)
          ),
          E1=F1,
          u_assign([if, P, Rs, F1], G1)
        ),
        G1=H1,
        ( ( ( u_assign([min, PQc, QRc], I1),
              I1=J1
            ),
            u_assign([min, Rc, J1], K1),
            K1=L1
          ),
          u_assign([min, Qc, L1], M1),
          M1=N1
        ),
        u_assign([min, Pc, N1], O1),
        O1=P1
      ),
      u_assign(['STV', H1, P1], Q1),
      Q1=R1
    ),
    u_assign(['STV', 1, 0], S1),
    S1=T1,
    u_assign([if, N, R1, T1], F).

</span>

; Evaluation took 7.65 seconds.
<span class="ansi33"> &self

</span>;; Preconditions are met
; avoid division by 0
;; Qs tends to 1
;; Otherwise
;; Preconditions are not met
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'deduction-rule',[->,'Atom']])
</span><span class="ansi38-255165000">  (: deduction-rule 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ['deduction-rule',Assign11] :-
%~                              u_assign(['â\x89\\x9E\',P,Ptv],Assign) ,
%~                              Assign=_58020 ,
%~                              u_assign(['â\x89\\x9E\',Q,Qtv],Assign1) ,
%~                              Assign1=_58044 ,
%~                              u_assign(['â\x89\\x9E\',R,Rtv],Assign2) ,
%~                              Assign2=_58068 ,
%~                              u_assign(['â\x86\\x92\',P,Q],Assign3) ,
%~                              Assign3=_58104 ,
%~                              u_assign(['â\x89\\x9E\',_58104,Pqtv],Assign4) ,
%~                              Assign4=_58128 ,
%~                              u_assign(['â\x86\\x92\',Q,R],Assign5) ,
%~                              Assign5=_58164 ,
%~                              u_assign(['â\x89\\x9E\',_58164,Qrtv],Assign6) ,
%~                              Assign6=_58188 ,
%~                              u_assign(['â\x86\\x92\',P,R],Assign7) ,
%~                              Assign7=_58224 ,
%~                              u_assign(
%~                                 [ 'deduction-formula', Ptv,Qtv,Rtv,
%~                                   Pqtv,Qrtv],
%~                                 Assign8) ,
%~                              Assign8=_58242 ,
%~                              u_assign(['â\x89\\x9E\',_58224,_58242],Assign9) ,
%~                              Assign9=_58272 ,
%~                              u_assign(
%~                                 [ ->, _103110,_103116,_103122,_103128,_103134,
%~                                   _103140],
%~                                 Assign10) ,
%~                              Assign10=_58326 ,
%~                              u_assign([:,'Deduction',_58326],Assign11))]
%~ [convert(_3344),head_preconds_into_body((['deduction-rule',_3320]:-((((u_assign(['â\x89\\x9E\',P,Ptv],_3414),_3414=_3410),(u_assign(['â\x89\\x9E\',Q,Qtv],_3464),_3464=_3460),(u_assign(['â\x89\\x9E\',R,Rtv],_3514),_3514=_3510),(((u_assign(['â\x86\\x92\',P,Q],_3590),_3590=_3586),u_assign(['â\x89\\x9E\',_3586,Pqtv],_3564)),_3564=_3560),(((u_assign(['â\x86\\x92\',Q,R],_3690),_3690=_3686),u_assign(['â\x89\\x9E\',_3686,Qrtv],_3664)),_3664=_3660),(((u_assign(['â\x86\\x92\',P,R],_3790),_3790=_3786),u_assign(['deduction-formula',Ptv,Qtv,Rtv,Pqtv,Qrtv],_3840),_3840=_3836),u_assign(['â\x89\\x9E\',_3786,_3836],_3764)),_3764=_3760),u_assign([->,_3410,_3460,_3510,_3560,_3660,_3760],_3388)),_3388=_3384),u_assign([:,'Deduction',_3384],_3320)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['deduction-rule'],[:,'Deduction',[->,['â\x89\\x9E\',P,Ptv],['â\x89\\x9E\',Q,Qtv],['â\x89\\x9E\',R,Rtv],['â\x89\\x9E\',['â\x86\\x92\',P,Q],Pqtv],['â\x89\\x9E\',['â\x86\\x92\',Q,R],Qrtv],['â\x89\\x9E\',['â\x86\\x92\',P,R],['deduction-formula',Ptv,Qtv,Rtv,Pqtv,Qrtv]]]])
</span><span class="ansi38-255165000">  (= 
    (deduction-rule) 
    (: Deduction 
      (-> 
        (â $P $Ptv) 
        (â $Q $Qtv) 
        (â $R $Rtv) 
        (â 
          (â $P $Q) $Pqtv) 
        (â 
          (â $Q $R) $Qrtv) 
        (â 
          (â $P $R) 
          (deduction-formula $Ptv $Qtv $Rtv $Pqtv $Qrtv)))))
</span><span class="ansi38-000082136">
  ['deduction-rule', A] :-
    ( ( u_assign(['â\u0089\u009E', P, Ptv], B),
        B=C
      ),
      ( u_assign(['â\u0089\u009E', Q, Qtv], D),
        D=E
      ),
      ( u_assign(['â\u0089\u009E', R, Rtv], F),
        F=G
      ),
      ( ( u_assign(['â\u0086\u0092', P, Q], H),
          H=I
        ),
        u_assign(['â\u0089\u009E', I, Pqtv], J),
        J=K
      ),
      ( ( u_assign(['â\u0086\u0092', Q, R], L),
          L=M
        ),
        u_assign(['â\u0089\u009E', M, Qrtv], N),
        N=O
      ),
      ( ( u_assign(['â\u0086\u0092', P, R], P),
          P=Q
        ),
        u_assign([ 'deduction-formula',
                   Ptv,
                   Qtv,
                   Rtv,
                   Pqtv,
                   Qrtv
                 ],
                 R),
        R=S,
        u_assign(['â\u0089\u009E', Q, S], T)
      ),
      T=U,
      u_assign([->, C, E, G, K, O, U],
               V)
    ),
    V=W,
    u_assign([:, 'Deduction', W], A).

</span>

; Evaluation took 8.13 seconds.
<span class="ansi33"> &self

</span><span class="ansi38-000068000">!(import! &self "../synthesis/Synthesize.metta")

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&self', '../synthesis/Synthesize.metta'], A).

</span>;; Import modules
<span class="ansi38-000068000">!(import! &self "../common/Num.metta")

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&self', '../common/Num.metta'], A).

</span>;; !(import! &self Unify.metta)
;; Enumerate all programs up to a given depth that are consistent with
;; the query, using the given axiom non-deterministic functions and rules.
;;
;; The arguments are:
;;
;; $query: an Atom under the form (: TERM TYPE).  The atom may contain
;;         free variables within TERM and TYPE to form various sort of
;;         queries, such as:
;;         1. Backward chaining: (: $term (Inheritance $x Mammal))
;;         2. Forward chaining: (: ($rule $premise AXIOM) $type)
;;         3. Mixed chaining: (: ($rule $premise AXIOM) (Inheritance $x Mammal))
;;         4. Type checking: (: TERM TYPE)
;;         5. Type inference: (: TERM $type)
;;
;; $axiom: a nullary function to axiom, to non-deterministically pick
;;         up an axiom.  An axiom is an Atom of the form
;;         (: TERM TYPE).
;;
;; $rule: a nullary function to rule, to non-deterministically pick up
;;        a rule.  A rule is a function mapping premises to
;;        conclusion, where premises and conclusion have the form
;;        (: TERM TYPE).
;;
;; $depth: a Nat representing the maximum depth of the generated
;;         programs.
;;
;; TODO: recurse over curried rules instead of duplicating code over
;; tuples.
;; Collection of functions operating on numbers
;; Define max
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,max,[->,A,A,A]])
</span><span class="ansi38-255165000">  (: max 
    (-> $A $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( max(X,Y,Assign_Max_Y) :-
%~                              u_assign([>,X,Y],Assign) ,
%~                              Assign=_362544 ,
%~                              u_assign([if,_362544,X,Y],Assign_Max_Y))]
%~ [convert(_304814),head_preconds_into_body((max(X,Y,_303578):-(u_assign([>,X,Y],_305120),_305120=_305110),u_assign([if,_305110,X,Y],_303578)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[max,X,Y],[if,[>,X,Y],X,Y])
</span><span class="ansi38-255165000">  (= 
    (max $X $Y) 
    (if 
      (> $X $Y) $X $Y))
</span><span class="ansi38-000082136">  :- dynamic(max,3).

  max(X, Y, A) :-
    u_assign([>, X, Y], B),
    B=C,
    u_assign([if, C, X, Y], A).

</span>

;; Define min
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,min,[->,A,A,A]])
</span><span class="ansi38-255165000">  (: min 
    (-> $A $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( min(X,Y,Assign_Min_Y) :-
%~                              u_assign([<,X,Y],Assign) ,
%~                              Assign=_484240 ,
%~                              u_assign([if,_484240,X,Y],Assign_Min_Y))]
%~ [convert(_426510),head_preconds_into_body((min(X,Y,_425274):-(u_assign([<,X,Y],_426816),_426816=_426806),u_assign([if,_426806,X,Y],_425274)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[min,X,Y],[if,[<,X,Y],X,Y])
</span><span class="ansi38-255165000">  (= 
    (min $X $Y) 
    (if 
      (< $X $Y) $X $Y))
</span><span class="ansi38-000082136">  :- dynamic(min,3).

  min(X, Y, A) :-
    u_assign([<, X, Y], B),
    B=C,
    u_assign([if, C, X, Y], A).

</span>

;; Clamp a number to be within a certain range
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,clamp,[->,A,A,A,A]])
</span><span class="ansi38-255165000">  (: clamp 
    (-> $A $A $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( clamp(X,L,U,Assign_Clamp_U) :-
%~                              u_assign([min,U,X],Assign) ,
%~                              Assign=_89956 ,
%~                              u_assign([max,L,_89956],Assign_Clamp_U))]
%~ [convert(_30228),head_preconds_into_body((clamp(X,L,U,_28922):-(u_assign([min,U,X],_30590),_30590=_30580),u_assign([max,L,_30580],_28922)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[clamp,X,L,U],[max,L,[min,U,X]])
</span><span class="ansi38-255165000">  (= 
    (clamp $X $L $U) 
    (max $L 
      (min $U $X)))
</span><span class="ansi38-000082136">  :- dynamic(clamp,4).

  clamp(X, L, U, A) :-
    u_assign([min, U, X], B),
    B=C,
    u_assign([max, L, C], A).

</span>

;; Define abs
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,abs,[->,A,A]])
</span><span class="ansi38-255165000">  (: abs 
    (-> $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( abs(X,Assign_Abs_X) :-
%~                              u_assign([<,X,0],Assign) ,
%~                              Assign=_235392 ,
%~                              u_assign([*,-1,X],Assign3) ,
%~                              Assign3=_235410 ,
%~                              u_assign([if,_235392,_235410,X],Assign_Abs_X))]
%~ [convert(_149700),head_preconds_into_body((abs(X,_148534):-((u_assign([<,X,0],_150006),_150006=_149996),u_assign([*,-1,X],_150166),_150166=_150156),u_assign([if,_149996,_150156,X],_148534)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[abs,X],[if,[<,X,0],[*,-1,X],X])
</span><span class="ansi38-255165000">  (= 
    (abs $X) 
    (if 
      (< $X 0) 
      (* -1 $X) $X))
</span><span class="ansi38-000082136">
  abs(X, A) :-
    ( u_assign([<, X, 0], B),
      B=C
    ),
    u_assign([*, -1, X], D),
    D=E,
    u_assign([if, C, E, X], A).

</span>

;; Define <=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,<=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: <= 
    (-> $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( <=(X,Y,Assign_Y) :-
%~                              u_assign([<,X,Y],Assign) ,
%~                              Assign=_371326 ,
%~                              u_assign([==,X,Y],Assign2) ,
%~                              Assign2=_371344 ,
%~                              u_assign([or,_371326,_371344],Assign_Y))]
%~ [convert(_296290),head_preconds_into_body((<=(X,Y,_295054):-((u_assign([<,X,Y],_296596),_296596=_296586),u_assign([==,X,Y],_296800),_296800=_296790),u_assign([or,_296586,_296790],_295054)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[<=,X,Y],[or,[<,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">  (= 
    (<= $X $Y) 
    (or 
      (< $X $Y) 
      (== $X $Y)))
</span><span class="ansi38-000082136">  :- dynamic(<=,3).

  <=(X, Y, A) :-
    ( u_assign([<, X, Y], B),
      B=C
    ),
    u_assign([==, X, Y], D),
    D=E,
    u_assign([or, C, E], A).

</span>

;; Define >=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,>=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: >= 
    (-> $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( >=(X,Y,Assign_Y) :-
%~                              u_assign([>,X,Y],Assign) ,
%~                              Assign=_506500 ,
%~                              u_assign([==,X,Y],Assign2) ,
%~                              Assign2=_506518 ,
%~                              u_assign([or,_506500,_506518],Assign_Y))]
%~ [convert(_431464),head_preconds_into_body((>=(X,Y,_430228):-((u_assign([>,X,Y],_431770),_431770=_431760),u_assign([==,X,Y],_431974),_431974=_431964),u_assign([or,_431760,_431964],_430228)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[>=,X,Y],[or,[>,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">  (= 
    (>= $X $Y) 
    (or 
      (> $X $Y) 
      (== $X $Y)))
</span><span class="ansi38-000082136">  :- dynamic(>=,3).

  >=(X, Y, A) :-
    ( u_assign([>, X, Y], B),
      B=C
    ),
    u_assign([==, X, Y], D),
    D=E,
    u_assign([or, C, E], A).

</span>

;; Define approximately equal
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,approxEq,[->,A,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: approxEq 
    (-> $A $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( approxEq(X,Y,Epsilon,Assign_ApproxEq_Epsilon) :-
%~                              u_assign([-,X,Y],Assign) ,
%~                              Assign=_135214 ,
%~                              u_assign([abs,_135214],Assign3) ,
%~                              Assign3=_135238 ,
%~                              u_assign([<=,_135238,Epsilon],Assign_ApproxEq_Epsilon))]
%~ [convert(_48974),head_preconds_into_body((approxEq(X,Y,Epsilon,_47668):-(((u_assign([-,X,Y],_49322),_49322=_49312),u_assign([abs,_49312],_49280)),_49280=_49270),u_assign([<=,_49270,Epsilon],_47668)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[approxEq,X,Y,Epsilon],[<=,[abs,[-,X,Y]],Epsilon])
</span><span class="ansi38-255165000">  (= 
    (approxEq $X $Y $Epsilon) 
    (<= 
      (abs 
        (- $X $Y)) $Epsilon))
</span><span class="ansi38-000082136">  :- dynamic(approxEq,4).

  approxEq(X, Y, Epsilon, A) :-
    ( u_assign([-, X, Y], B),
      B=C,
      u_assign([abs, C], D)
    ),
    D=E,
    u_assign([<=, E, Epsilon], A).

</span>

;; Define Nat
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Nat','Type'])
</span><span class="ansi38-255165000">  (: Nat Type)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Z','Nat'])
</span><span class="ansi38-255165000">  (: Z Nat)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'S',[->,'Nat','Nat']])
</span><span class="ansi38-255165000">  (: S 
    (-> Nat Nat))
</span>

;; Define cast functions between Nat and Number
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNumber,[->,'Number','Nat']])
</span><span class="ansi38-255165000">  (: fromNumber 
    (-> Number Nat))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( fromNumber(N,N) :-
%~                              u_assign([<=,N,0],Assign) ,
%~                              Assign=_359026 ,
%~                              u_assign([-,N,1],Assign2) ,
%~                              Assign2=_359068 ,
%~                              u_assign([fromNumber,_359068],Assign3) ,
%~                              Assign3=_359092 ,
%~                              u_assign(['S',_359092],Assign4) ,
%~                              Assign4=_359116 ,
%~                              u_assign([if,_359026,'Z',_359116],N))]
%~ [convert(_236870),head_preconds_into_body((fromNumber(N,_235704):-((u_assign([<=,N,0],_237176),_237176=_237166),((((u_assign([-,N,1],_237432),_237432=_237422),u_assign([fromNumber,_237422],_237390)),_237390=_237380),u_assign(['S',_237380],_237348)),_237348=_237338),u_assign([if,_237166,'Z',_237338],_235704)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNumber,N],[if,[<=,N,0],'Z',['S',[fromNumber,[-,N,1]]]])
</span><span class="ansi38-255165000">  (= 
    (fromNumber $N) 
    (if 
      (<= $N 0) Z 
      (S 
        (fromNumber 
          (- $N 1)))))
</span><span class="ansi38-000082136">  :- dynamic(fromNumber,2).

  fromNumber(N, A) :-
    ( u_assign([<=, N, 0], B),
      B=C
    ),
    ( ( u_assign([-, N, 1], D),
        D=E,
        u_assign([fromNumber, E], F)
      ),
      F=G,
      u_assign(['S', G], H)
    ),
    H=I,
    u_assign([if, C, 'Z', I], A).

</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNat,[->,'Nat','Number']])
</span><span class="ansi38-255165000">  (: fromNat 
    (-> Nat Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((fromNat('Z',0):-true))]
%~ [convert(_406104),head_preconds_into_body((fromNat('Z',0):-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,'Z'],0)
</span><span class="ansi38-255165000">  (= 
    (fromNat Z) 0)
</span><span class="ansi38-000082136">  :- dynamic(fromNat,2).

  fromNat('Z', 0).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( fromNat(FromNat,FromNat1) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=FromNat ,
%~                              u_assign([fromNat,K],Assign3) ,
%~                              [+,1,Assign3,FromNat1])]
%~ [convert(_451260),head_preconds_into_body((fromNat(_450306,_450026):-(u_assign(['S',K],_450316),_450316=_450306),u_assign([fromNat,K],_451584),[+,1,_451584,_450026]))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,['S',K]],[+,1,[fromNat,K]])
</span><span class="ansi38-255165000">  (= 
    (fromNat 
      (S $K)) 
    (+ 1 
      (fromNat $K)))
</span><span class="ansi38-000082136">  :- dynamic(fromNat,2).

  fromNat(A, B) :-
    u_assign(['S', K], C),
    C=A,
    u_assign([fromNat, K], D),
    [+, 1, D, B].

</span>

;; Define a generic less than operator, â©», for Nat.  < cannot be used
;; because it is a built-in, its type is hardwired and cannot be
;; overloaded.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Nat','Nat','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Nat Nat Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('â©»'(_,'Z',_32188):-_32188='False'))]
%~ [convert(_33380),head_preconds_into_body(('â©»'(_,'Z',_32188):-_32188='False'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',_,'Z'],'False')
</span><span class="ansi38-255165000">  (= 
    (â©» $_ Z) False)
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(_, 'Z', A) :-
    A='False'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'('Z',Z,True) :-
%~                              u_assign(['S',_],Assign) ,
%~                              Assign=Z ,
%~                              True='True')]
%~ [convert(_79758),head_preconds_into_body(('â©»'('Z',_78790,_78498):-(u_assign(['S',_],_78800),_78800=_78790),_78498='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»','Z',['S',_]],'True')
</span><span class="ansi38-255165000">  (= 
    (â©» Z 
      (S $_)) True)
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'('Z', A, B) :-
    u_assign(['S', _], C),
    C=A,
    B='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'(Â1,Â,Assign_Â2) :-
%~                              u_assign(['S',X],Assign) ,
%~                              Assign=Â1 ,
%~                              u_assign(['S',Y],Assign4) ,
%~                              Assign4=Â ,
%~                              u_assign(['â©»',X,Y],Assign_Â2))]
%~ [convert(_151410),head_preconds_into_body(('â©»'(_150294,_150428,_150014):-((u_assign(['S',X],_150304),_150304=_150294),u_assign(['S',Y],_150438),_150438=_150428),u_assign(['â©»',X,Y],_150014)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',['S',X],['S',Y]],['â©»',X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» 
      (S $X) 
      (S $Y)) 
    (â©» $X $Y))
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(A, B, C) :-
    ( u_assign(['S', X], D),
      D=A
    ),
    u_assign(['S', Y], E),
    E=B,
    u_assign(['â©»', X, Y], C).

</span>

;; Overload â©» for Number.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Number','Number','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Number Number Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'(X,Y,Assign_Â_Y) :-
%~                              u_assign([<,X,Y],Assign_Â_Y))]
%~ [convert(_249112),head_preconds_into_body(('â©»'(X,Y,_247876):-u_assign([<,X,Y],_247876)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',X,Y],[<,X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» $X $Y) 
    (< $X $Y))
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(X, Y, A) :-
    u_assign([<, X, Y], A).

</span>

;; Return the ceiling of a non negative number.  If the number is
;; negative it returns 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,ceil,[->,'Number','Number']])
</span><span class="ansi38-255165000">  (: ceil 
    (-> Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ceil(N,Assign_Ceil_N) :-
%~                              u_assign([fromNumber,N],Assign) ,
%~                              Assign=_381182 ,
%~                              u_assign([fromNat,_381182],Assign_Ceil_N))]
%~ [convert(_324868),head_preconds_into_body((ceil(N,_323702):-(u_assign([fromNumber,N],_325174),_325174=_325164),u_assign([fromNat,_325164],_323702)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[ceil,N],[fromNat,[fromNumber,N]])
</span><span class="ansi38-255165000">  (= 
    (ceil $N) 
    (fromNat 
      (fromNumber $N)))
</span><span class="ansi38-000082136">  :- dynamic(ceil,2).

  ceil(N, A) :-
    u_assign([fromNumber, N], B),
    B=C,
    u_assign([fromNat, C], A).

</span>

;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'number->bool',[->,'Number','Bool']])
</span><span class="ansi38-255165000">  (: number->bool 
    (-> Number Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'number->bool'(X,Number_c62_bool_X) :-
%~                              u_assign([<,0,X],Number_c62_bool_X))]
%~ [convert(_422478),head_preconds_into_body(('number->bool'(X,_421312):-u_assign([<,0,X],_421312)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['number->bool',X],[<,0,X])
</span><span class="ansi38-255165000">  (= 
    (number->bool $X) 
    (< 0 $X))
</span><span class="ansi38-000082136">  :- dynamic('number->bool',2).

  'number->bool'(X, A) :-
    u_assign([<, 0, X], A).

</span>

;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'bool->number',[->,'Bool','Number']])
</span><span class="ansi38-255165000">  (: bool->number 
    (-> Bool Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('bool->number'('False',0):-true))]
%~ [convert(_492966),head_preconds_into_body(('bool->number'('False',0):-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','False'],0)
</span><span class="ansi38-255165000">  (= 
    (bool->number False) 0)
</span><span class="ansi38-000082136">  :- dynamic('bool->number',2).

  'bool->number'('False', 0).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('bool->number'(_8114,1):-is_True(_8114)))]
%~ [convert(_8950),head_preconds_into_body(('bool->number'(_8114,1):-is_True(_8114)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','True'],1)
</span><span class="ansi38-255165000">  (= 
    (bool->number True) 1)
</span><span class="ansi38-000082136">  :- dynamic('bool->number',2).

  'bool->number'(A, 1) :-
    is_True(A).

</span>

;; Define a less than type.  Note that it is purposefully different
;; than â©» as it is a type, not an operator.  Inhabitants of (â x y)
;; are proofs that x â©» y == True.  For now â is only axiomatized for
;; Nat.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â\x8D\\x83\',[->,True,True,'Type']])
</span><span class="ansi38-255165000">  (: â 
    (-> $True $True Type))
</span>

;; Zero is always less than the successor of something
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['zero-lt-succ-axiom'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ['zero-lt-succ-axiom',Assign2] :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=_172562 ,
%~                              u_assign(['â\x8D\\x83\','Z',_172562],Assign1) ,
%~                              Assign1=_172592 ,
%~                              u_assign([:,'ZeroLTSucc',_172592],Assign2))]
%~ [convert(_73576),head_preconds_into_body((['zero-lt-succ-axiom',_71736]:-(((u_assign(['S',K],_73948),_73948=_73938),u_assign(['â\x8D\\x83\','Z',_73938],_73894)),_73894=_73884),u_assign([:,'ZeroLTSucc',_73884],_71736)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['zero-lt-succ-axiom'],[:,'ZeroLTSucc',['â\x8D\\x83\','Z',['S',K]]])
</span><span class="ansi38-255165000">  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (â Z 
        (S $K))))
</span><span class="ansi38-000082136">
  ['zero-lt-succ-axiom', A] :-
    ( u_assign(['S', K], B),
      B=C,
      u_assign(['â\u008D\u0083', 'Z', C], D)
    ),
    D=E,
    u_assign([:, 'ZeroLTSucc', E], A).

</span>

;; If x â y then (S x) â (S y)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['succ-monotonicity-rule'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ['succ-monotonicity-rule',Assign5] :-
%~                              u_assign(['â\x8D\\x83\',X,Y],Assign) ,
%~                              Assign=_373514 ,
%~                              u_assign(['S',X],Assign1) ,
%~                              Assign1=_373550 ,
%~                              u_assign(['S',Y],Assign2) ,
%~                              Assign2=_373568 ,
%~                              u_assign(['â\x8D\\x83\',_373550,_373568],Assign3) ,
%~                              Assign3=_373598 ,
%~                              u_assign([->,_373514,_373598],Assign4) ,
%~                              Assign4=_373628 ,
%~                              u_assign([:,'SuccMonotonicity',_373628],Assign5))]
%~ [convert(_212206),head_preconds_into_body((['succ-monotonicity-rule',_210366]:-((((u_assign(['â\x8D\\x83\',X,Y],_212566),_212566=_212556),(((u_assign(['S',X],_212812),_212812=_212802),u_assign(['S',Y],_212946),_212946=_212936),u_assign(['â\x8D\\x83\',_212802,_212936],_212770)),_212770=_212760),u_assign([->,_212556,_212760],_212524)),_212524=_212514),u_assign([:,'SuccMonotonicity',_212514],_210366)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['succ-monotonicity-rule'],[:,'SuccMonotonicity',[->,['â\x8D\\x83\',X,Y],['â\x8D\\x83\',['S',X],['S',Y]]]])
</span><span class="ansi38-255165000">  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (â $X $Y) 
        (â 
          (S $X) 
          (S $Y)))))
</span><span class="ansi38-000082136">
  ['succ-monotonicity-rule', A] :-
    ( ( u_assign(['â\u008D\u0083', X, Y], B),
        B=C
      ),
      ( ( u_assign(['S', X], D),
          D=E
        ),
        u_assign(['S', Y], F),
        F=G,
        u_assign(['â\u008D\u0083', E, G], H)
      ),
      H=I,
      u_assign([->, C, I], J)
    ),
    J=K,
    u_assign([:, 'SuccMonotonicity', K], A).

</span>

; Evaluation took 1400.12 ms.
<span class="ansi33"> &self

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,synthesize,[->,'Atom',[->,'Atom'],[->,'Atom'],'Nat','Atom']])
</span><span class="ansi38-255165000">  (: synthesize 
    (-> Atom 
      (-> Atom) 
      (-> Atom) Nat Atom))
</span>

;; Nullary rule (axiom)
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Depth,Query) :-
%~                              u_assign([Axiom],VAR_Query) ,
%~                              Query=VAR_Query)]
%~ [convert(_448892),head_preconds_into_body((synthesize(Query,Axiom,Rule,Depth,Query):-u_assign([Axiom],_449196),Query=_449196))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,Depth],[let,Query,[Axiom],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule $Depth) 
    (let $Query 
      ($Axiom) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, Depth, Query) :-
    u_assign([Axiom], A),
    Query=A.

</span>

;; Unary rule
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Rule,Query) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=Rule ,
%~                              u_assign([->,Premise,Conclusion],Assign5) ,
%~                              Assign5=_173714 ,
%~                              u_assign([:,Ructor,_173714],Assign_List) ,
%~                              [Rule]=Assign_List ,
%~                              u_assign([Ructor,Proof],Assign7) ,
%~                              Assign7=_173780 ,
%~                              u_assign([:,_173780,Conclusion],VAR_Query) ,
%~                              Query=VAR_Query ,
%~                              u_assign([:,Proof,Premise],Assign_List3) ,
%~                              [ synthesize,
%~                                [:,Proof,Premise], Axiom,Rule,K] =
%~                                Assign_List3)]
%~ [convert(_26426),head_preconds_into_body((synthesize(Query,Axiom,Rule,_25430,Query):-(u_assign(['S',K],_25440),_25440=_25430),(((u_assign([->,Premise,Conclusion],_27626),_27626=_27616),u_assign([:,Ructor,_27616],_27010)),[Rule]=_27010),(((u_assign([Ructor,Proof],_28682),_28682=_28672),u_assign([:,_28672,Conclusion],_28122)),Query=_28122),u_assign([:,Proof,Premise],_29232),[synthesize,[:,Proof,Premise],Axiom,Rule,K]=_29232))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,['S',K]],['let*',[[[:,Ructor,[->,Premise,Conclusion]],[Rule]],[[:,[Ructor,Proof],Conclusion],Query],[[:,Proof,Premise],[synthesize,[:,Proof,Premise],Axiom,Rule,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise $Conclusion)) 
          ($Rule)) 
        ( (: 
            ($Ructor $Proof) $Conclusion) $Query) 
        ( (: $Proof $Premise) 
          (synthesize 
            (: $Proof $Premise) $Axiom $Rule $K))) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, A, Query) :-
    u_assign(['S', K], B),
    B=A,
    ( u_assign([->, Premise, Conclusion], C),
      C=D,
      u_assign([:, Ructor, D], E)
    ),
    [Rule]=E,
    ( u_assign([Ructor, Proof], F),
      F=G,
      u_assign([:, G, Conclusion], H)
    ),
    Query=H,
    u_assign([:, Proof, Premise], I),
    [synthesize, [:, Proof, Premise], Axiom, Rule, K]=I.

</span>

;; Binary rule
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Rule,Query) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=Rule ,
%~                              u_assign( [->,Premise1,Premise2,Conclusion],
%~                                Assign6) ,
%~                              Assign6=_437472 ,
%~                              u_assign([:,Ructor,_437472],Assign_List) ,
%~                              [Rule]=Assign_List ,
%~                              u_assign([Ructor,Proof1,Proof2],Assign8) ,
%~                              Assign8=_437538 ,
%~                              u_assign([:,_437538,Conclusion],VAR_Query) ,
%~                              Query=VAR_Query ,
%~                              u_assign([:,Proof1,Premise1],Assign_List3) ,
%~                              [ synthesize,
%~                                [:,Proof1,Premise1], Axiom,Rule,K] =
%~                                Assign_List3 ,
%~                              u_assign([:,Proof2,Premise2],Assign_List4) ,
%~                              [ synthesize,
%~                                [:,Proof2,Premise2], Axiom,Rule,K] =
%~                                Assign_List4)]
%~ [convert(_262132),head_preconds_into_body((synthesize(Query,Axiom,Rule,_261136,Query):-(u_assign(['S',K],_261146),_261146=_261136),(((u_assign([->,Premise1,Premise2,Conclusion],_263332),_263332=_263322),u_assign([:,Ructor,_263322],_262716)),[Rule]=_262716),(((u_assign([Ructor,Proof1,Proof2],_264458),_264458=_264448),u_assign([:,_264448,Conclusion],_263898)),Query=_263898),(u_assign([:,Proof1,Premise1],_265078),[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]=_265078),u_assign([:,Proof2,Premise2],_266052),[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]=_266052))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,['S',K]],['let*',[[[:,Ructor,[->,Premise1,Premise2,Conclusion]],[Rule]],[[:,[Ructor,Proof1,Proof2],Conclusion],Query],[[:,Proof1,Premise1],[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]],[[:,Proof2,Premise2],[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise1 $Premise2 $Conclusion)) 
          ($Rule)) 
        ( (: 
            ($Ructor $Proof1 $Proof2) $Conclusion) $Query) 
        ( (: $Proof1 $Premise1) 
          (synthesize 
            (: $Proof1 $Premise1) $Axiom $Rule $K)) 
        ( (: $Proof2 $Premise2) 
          (synthesize 
            (: $Proof2 $Premise2) $Axiom $Rule $K))) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, A, Query) :-
    u_assign(['S', K], B),
    B=A,
    ( u_assign([->, Premise1, Premise2, Conclusion], C),
      C=D,
      u_assign([:, Ructor, D], E)
    ),
    [Rule]=E,
    ( u_assign([Ructor, Proof1, Proof2], F),
      F=G,
      u_assign([:, G, Conclusion], H)
    ),
    Query=H,
    u_assign([:, Proof1, Premise1], I),
    [synthesize, [:, Proof1, Premise1], Axiom, Rule, K]=I,
    u_assign([:, Proof2, Premise2], J),
    [synthesize, [:, Proof2, Premise2], Axiom, Rule, K]=J.

</span>

;; Trinary rule
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Rule,Query) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=Rule ,
%~                              u_assign(
%~                                 [ ->, Premise1,Premise2,
%~                                   Premise3,Conclusion],
%~                                 Assign7) ,
%~                              Assign7=_242436 ,
%~                              u_assign([:,Ructor,_242436],Assign_List) ,
%~                              [Rule]=Assign_List ,
%~                              u_assign( [Ructor,Proof1,Proof2,Proof3],
%~                                Assign9) ,
%~                              Assign9=_242502 ,
%~                              u_assign([:,_242502,Conclusion],VAR_Query) ,
%~                              Query=VAR_Query ,
%~                              u_assign([:,Proof1,Premise1],Assign_List3) ,
%~                              [ synthesize,
%~                                [:,Proof1,Premise1], Axiom,Rule,K] =
%~                                Assign_List3 ,
%~                              u_assign([:,Proof2,Premise2],Assign_List4) ,
%~                              [ synthesize,
%~                                [:,Proof2,Premise2], Axiom,Rule,K] =
%~                                Assign_List4 ,
%~                              u_assign([:,Proof3,Premise3],Assign_List5) ,
%~                              [ synthesize,
%~                                [:,Proof3,Premise3], Axiom,Rule,K] =
%~                                Assign_List5)]
%~ [convert(_29332),head_preconds_into_body((synthesize(Query,Axiom,Rule,_28336,Query):-(u_assign(['S',K],_28346),_28346=_28336),(((u_assign([->,Premise1,Premise2,Premise3,Conclusion],_30532),_30532=_30522),u_assign([:,Ructor,_30522],_29916)),[Rule]=_29916),(((u_assign([Ructor,Proof1,Proof2,Proof3],_31728),_31728=_31718),u_assign([:,_31718,Conclusion],_31168)),Query=_31168),(u_assign([:,Proof1,Premise1],_32418),[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]=_32418),(u_assign([:,Proof2,Premise2],_33392),[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]=_33392),u_assign([:,Proof3,Premise3],_34366),[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]=_34366))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,['S',K]],['let*',[[[:,Ructor,[->,Premise1,Premise2,Premise3,Conclusion]],[Rule]],[[:,[Ructor,Proof1,Proof2,Proof3],Conclusion],Query],[[:,Proof1,Premise1],[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]],[[:,Proof2,Premise2],[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]],[[:,Proof3,Premise3],[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise1 $Premise2 $Premise3 $Conclusion)) 
          ($Rule)) 
        ( (: 
            ($Ructor $Proof1 $Proof2 $Proof3) $Conclusion) $Query) 
        ( (: $Proof1 $Premise1) 
          (synthesize 
            (: $Proof1 $Premise1) $Axiom $Rule $K)) 
        ( (: $Proof2 $Premise2) 
          (synthesize 
            (: $Proof2 $Premise2) $Axiom $Rule $K)) 
        ( (: $Proof3 $Premise3) 
          (synthesize 
            (: $Proof3 $Premise3) $Axiom $Rule $K))) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, A, Query) :-
    u_assign(['S', K], B),
    B=A,
    ( u_assign([ ->,
                 Premise1,
                 Premise2,
                 Premise3,
                 Conclusion
               ],
               C),
      C=D,
      u_assign([:, Ructor, D], E)
    ),
    [Rule]=E,
    ( u_assign([Ructor, Proof1, Proof2, Proof3], F),
      F=G,
      u_assign([:, G, Conclusion], H)
    ),
    Query=H,
    u_assign([:, Proof1, Premise1], I),
    [synthesize, [:, Proof1, Premise1], Axiom, Rule, K]=I,
    u_assign([:, Proof2, Premise2], J),
    [synthesize, [:, Proof2, Premise2], Axiom, Rule, K]=J,
    u_assign([:, Proof3, Premise3], K),
    [synthesize, [:, Proof3, Premise3], Axiom, Rule, K]=K.

</span>

;; Quaternary rule
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Rule,Query) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=Rule ,
%~                              u_assign(
%~                                 [ ->, Premise1,Premise2,
%~                                   Premise3,Premise4,
%~                                   Conclusion],
%~                                 Assign8) ,
%~                              Assign8=_118482 ,
%~                              u_assign([:,Ructor,_118482],Assign_List) ,
%~                              [Rule]=Assign_List ,
%~                              u_assign(
%~                                 [ Ructor, Proof1,Proof2,Proof3,
%~                                   Proof4],
%~                                 Assign10) ,
%~                              Assign10=_118548 ,
%~                              u_assign([:,_118548,Conclusion],VAR_Query) ,
%~                              Query=VAR_Query ,
%~                              u_assign([:,Proof1,Premise1],Assign_List3) ,
%~                              [ synthesize,
%~                                [:,Proof1,Premise1], Axiom,Rule,K] =
%~                                Assign_List3 ,
%~                              u_assign([:,Proof2,Premise2],Assign_List4) ,
%~                              [ synthesize,
%~                                [:,Proof2,Premise2], Axiom,Rule,K] =
%~                                Assign_List4 ,
%~                              u_assign([:,Proof3,Premise3],Assign_List5) ,
%~                              [ synthesize,
%~                                [:,Proof3,Premise3], Axiom,Rule,K] =
%~                                Assign_List5 ,
%~                              u_assign([:,Proof4,Premise4],Assign_List6) ,
%~                              [ synthesize,
%~                                [:,Proof4,Premise4], Axiom,Rule,K] =
%~                                Assign_List6)]
%~ [convert(_3800),head_preconds_into_body((synthesize(Query,Axiom,Rule,_3750,Query):-(u_assign(['S',K],_3754),_3754=_3750),(((u_assign([->,Premise1,Premise2,Premise3,Premise4,Conclusion],_3856),_3856=_3852),u_assign([:,Ructor,_3852],_3824)),[Rule]=_3824),(((u_assign([Ructor,Proof1,Proof2,Proof3,Proof4],_3954),_3954=_3950),u_assign([:,_3950,Conclusion],_3928)),Query=_3928),(u_assign([:,Proof1,Premise1],_4032),[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]=_4032),(u_assign([:,Proof2,Premise2],_4074),[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]=_4074),(u_assign([:,Proof3,Premise3],_4116),[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]=_4116),u_assign([:,Proof4,Premise4],_4158),[synthesize,[:,Proof4,Premise4],Axiom,Rule,K]=_4158))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,['S',K]],['let*',[[[:,Ructor,[->,Premise1,Premise2,Premise3,Premise4,Conclusion]],[Rule]],[[:,[Ructor,Proof1,Proof2,Proof3,Proof4],Conclusion],Query],[[:,Proof1,Premise1],[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]],[[:,Proof2,Premise2],[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]],[[:,Proof3,Premise3],[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]],[[:,Proof4,Premise4],[synthesize,[:,Proof4,Premise4],Axiom,Rule,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise1 $Premise2 $Premise3 $Premise4 $Conclusion)) 
          ($Rule)) 
        ( (: 
            ($Ructor $Proof1 $Proof2 $Proof3 $Proof4) $Conclusion) $Query) 
        ( (: $Proof1 $Premise1) 
          (synthesize 
            (: $Proof1 $Premise1) $Axiom $Rule $K)) 
        ( (: $Proof2 $Premise2) 
          (synthesize 
            (: $Proof2 $Premise2) $Axiom $Rule $K)) 
        ( (: $Proof3 $Premise3) 
          (synthesize 
            (: $Proof3 $Premise3) $Axiom $Rule $K)) 
        ( (: $Proof4 $Premise4) 
          (synthesize 
            (: $Proof4 $Premise4) $Axiom $Rule $K))) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, A, Query) :-
    u_assign(['S', K], B),
    B=A,
    ( u_assign([ ->,
                 Premise1,
                 Premise2,
                 Premise3,
                 Premise4,
                 Conclusion
               ],
               C),
      C=D,
      u_assign([:, Ructor, D], E)
    ),
    [Rule]=E,
    ( u_assign([ Ructor,
                 Proof1,
                 Proof2,
                 Proof3,
                 Proof4
               ],
               F),
      F=G,
      u_assign([:, G, Conclusion], H)
    ),
    Query=H,
    u_assign([:, Proof1, Premise1], I),
    [synthesize, [:, Proof1, Premise1], Axiom, Rule, K]=I,
    u_assign([:, Proof2, Premise2], J),
    [synthesize, [:, Proof2, Premise2], Axiom, Rule, K]=J,
    u_assign([:, Proof3, Premise3], K),
    [synthesize, [:, Proof3, Premise3], Axiom, Rule, K]=K,
    u_assign([:, Proof4, Premise4], L),
    [synthesize, [:, Proof4, Premise4], Axiom, Rule, K]=L.

</span>

;; Quintenary rule
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Rule,Query) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=Rule ,
%~                              u_assign(
%~                                 [ ->, Premise1,Premise2,
%~                                   Premise3,Premise4,
%~                                   Premise5,Conclusion],
%~                                 Assign9) ,
%~                              Assign9=_40662 ,
%~                              u_assign([:,Ructor,_40662],Assign_List) ,
%~                              [Rule]=Assign_List ,
%~                              u_assign(
%~                                 [ Ructor, Proof1,Proof2,Proof3,
%~                                   Proof4,Proof5],
%~                                 Assign11) ,
%~                              Assign11=_40728 ,
%~                              u_assign([:,_40728,Conclusion],VAR_Query) ,
%~                              Query=VAR_Query ,
%~                              u_assign([:,Proof1,Premise1],Assign_List3) ,
%~                              [ synthesize,
%~                                [:,Proof1,Premise1], Axiom,Rule,K] =
%~                                Assign_List3 ,
%~                              u_assign([:,Proof2,Premise2],Assign_List4) ,
%~                              [ synthesize,
%~                                [:,Proof2,Premise2], Axiom,Rule,K] =
%~                                Assign_List4 ,
%~                              u_assign([:,Proof3,Premise3],Assign_List5) ,
%~                              [ synthesize,
%~                                [:,Proof3,Premise3], Axiom,Rule,K] =
%~                                Assign_List5 ,
%~                              u_assign([:,Proof4,Premise4],Assign_List6) ,
%~                              [ synthesize,
%~                                [:,Proof4,Premise4], Axiom,Rule,K] =
%~                                Assign_List6 ,
%~                              u_assign([:,Proof5,Premise5],Assign_List7) ,
%~                              [ synthesize,
%~                                [:,Proof5,Premise5], Axiom,Rule,K] =
%~                                Assign_List7)]
%~ [convert(_3926),head_preconds_into_body((synthesize(Query,Axiom,Rule,_3876,Query):-(u_assign(['S',K],_3880),_3880=_3876),(((u_assign([->,Premise1,Premise2,Premise3,Premise4,Premise5,Conclusion],_3982),_3982=_3978),u_assign([:,Ructor,_3978],_3950)),[Rule]=_3950),(((u_assign([Ructor,Proof1,Proof2,Proof3,Proof4,Proof5],_4086),_4086=_4082),u_assign([:,_4082,Conclusion],_4060)),Query=_4060),(u_assign([:,Proof1,Premise1],_4170),[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]=_4170),(u_assign([:,Proof2,Premise2],_4212),[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]=_4212),(u_assign([:,Proof3,Premise3],_4254),[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]=_4254),(u_assign([:,Proof4,Premise4],_4296),[synthesize,[:,Proof4,Premise4],Axiom,Rule,K]=_4296),u_assign([:,Proof5,Premise5],_4338),[synthesize,[:,Proof5,Premise5],Axiom,Rule,K]=_4338))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,['S',K]],['let*',[[[:,Ructor,[->,Premise1,Premise2,Premise3,Premise4,Premise5,Conclusion]],[Rule]],[[:,[Ructor,Proof1,Proof2,Proof3,Proof4,Proof5],Conclusion],Query],[[:,Proof1,Premise1],[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]],[[:,Proof2,Premise2],[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]],[[:,Proof3,Premise3],[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]],[[:,Proof4,Premise4],[synthesize,[:,Proof4,Premise4],Axiom,Rule,K]],[[:,Proof5,Premise5],[synthesize,[:,Proof5,Premise5],Axiom,Rule,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise1 $Premise2 $Premise3 $Premise4 $Premise5 $Conclusion)) 
          ($Rule)) 
        ( (: 
            ($Ructor $Proof1 $Proof2 $Proof3 $Proof4 $Proof5) $Conclusion) $Query) 
        ( (: $Proof1 $Premise1) 
          (synthesize 
            (: $Proof1 $Premise1) $Axiom $Rule $K)) 
        ( (: $Proof2 $Premise2) 
          (synthesize 
            (: $Proof2 $Premise2) $Axiom $Rule $K)) 
        ( (: $Proof3 $Premise3) 
          (synthesize 
            (: $Proof3 $Premise3) $Axiom $Rule $K)) 
        ( (: $Proof4 $Premise4) 
          (synthesize 
            (: $Proof4 $Premise4) $Axiom $Rule $K)) 
        ( (: $Proof5 $Premise5) 
          (synthesize 
            (: $Proof5 $Premise5) $Axiom $Rule $K))) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, A, Query) :-
    u_assign(['S', K], B),
    B=A,
    ( u_assign([ ->,
                 Premise1,
                 Premise2,
                 Premise3,
                 Premise4,
                 Premise5,
                 Conclusion
               ],
               C),
      C=D,
      u_assign([:, Ructor, D], E)
    ),
    [Rule]=E,
    ( u_assign([ Ructor,
                 Proof1,
                 Proof2,
                 Proof3,
                 Proof4,
                 Proof5
               ],
               F),
      F=G,
      u_assign([:, G, Conclusion], H)
    ),
    Query=H,
    u_assign([:, Proof1, Premise1], I),
    [synthesize, [:, Proof1, Premise1], Axiom, Rule, K]=I,
    u_assign([:, Proof2, Premise2], J),
    [synthesize, [:, Proof2, Premise2], Axiom, Rule, K]=J,
    u_assign([:, Proof3, Premise3], K),
    [synthesize, [:, Proof3, Premise3], Axiom, Rule, K]=K,
    u_assign([:, Proof4, Premise4], L),
    [synthesize, [:, Proof4, Premise4], Axiom, Rule, K]=L,
    u_assign([:, Proof5, Premise5], M),
    [synthesize, [:, Proof5, Premise5], Axiom, Rule, K]=M.

</span>

; Evaluation took 2.71 seconds.
<span class="ansi33"> &self

</span><span class="ansi38-000068000">!(import! &self "../common/Record.metta")

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&self', '../common/Record.metta'], A).

</span>;; Knowledge base
;; Given a function call, produce records of that function call.
;; There can be multiple records with only one call due to the
;; non-determinism of MeTTa.  Each record is represented by (â· f x y)
;; which can be read as
;;
;; "under f, the image of x is y"
;;
;; It was chosen because it is described as IMAGE OF in UTF-8.  It is
;; the MeTTa equivalent of ExecutionLink in Atomese.  The character â·
;; has description: IMAGE OF, hexadecimal code: 0x22B7, unicode-math
;; code: \imageof and latex code: \multimapdotbothB.
%~ [ convert(Convert),
%~   head_preconds_into_body( record(False,False,Assign_Record) :-
%~                              u_assign([Arg],Assign) ,
%~                              Assign=False ,
%~                              u_assign([False,Arg],Assign3) ,
%~                              Assign3=_294036 ,
%~                              u_assign(['â\x8A\·',False,Arg,_294036],Assign_Record))]
%~ [convert(_208372),head_preconds_into_body((record(False,_207430,_207094):-(u_assign([Arg],_207440),_207440=_207430),(u_assign([False,Arg],_208790),_208790=_208780),u_assign(['â\x8A\·',False,Arg,_208780],_207094)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[record,False,[Arg]],['â\x8A\·',False,Arg,[False,Arg]])
</span><span class="ansi38-255165000">  (= 
    (record $False 
      ($Arg)) 
    (â· $False $Arg 
      ($False $Arg)))
</span><span class="ansi38-000082136">  :- dynamic(record,3).

  record(False, A, B) :-
    u_assign([Arg], C),
    C=A,
    u_assign([False, Arg], D),
    D=E,
    u_assign(['â\u008A·', False, Arg, E], B).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( record(False,False,Assign_Record) :-
%~                              u_assign([Arg1,Arg2],Assign) ,
%~                              Assign=False ,
%~                              u_assign([Arg1,Arg2],Assign3) ,
%~                              Assign3=_430312 ,
%~                              u_assign([False,Arg1,Arg2],Assign4) ,
%~                              Assign4=_430330 ,
%~                              u_assign(['â\x8A\·',False,_430312,_430330],Assign_Record))]
%~ [convert(_326944),head_preconds_into_body((record(False,_325932,_325596):-(u_assign([Arg1,Arg2],_325942),_325942=_325932),((u_assign([Arg1,Arg2],_327306),_327306=_327296),u_assign([False,Arg1,Arg2],_327484),_327484=_327474),u_assign(['â\x8A\·',False,_327296,_327474],_325596)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[record,False,[Arg1,Arg2]],['â\x8A\·',False,[Arg1,Arg2],[False,Arg1,Arg2]])
</span><span class="ansi38-255165000">  (= 
    (record $False 
      ($Arg1 $Arg2)) 
    (â· $False 
      ($Arg1 $Arg2) 
      ($False $Arg1 $Arg2)))
</span><span class="ansi38-000082136">  :- dynamic(record,3).

  record(False, A, B) :-
    u_assign([Arg1, Arg2], C),
    C=A,
    ( u_assign([Arg1, Arg2], D),
      D=E
    ),
    u_assign([False, Arg1, Arg2], F),
    F=G,
    u_assign(['â\u008A·', False, E, G], B).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( record(False,False,Assign_Record) :-
%~                              u_assign([Arg1,Arg2,Arg3],Assign) ,
%~                              Assign=False ,
%~                              u_assign([Arg1,Arg2,Arg3],Assign3) ,
%~                              Assign3=_60312 ,
%~                              u_assign( [False,Arg1,Arg2,Arg3],
%~                                Assign4) ,
%~                              Assign4=_60330 ,
%~                              u_assign(['â\x8A\·',False,_60312,_60330],Assign_Record))]
%~ [convert(_3254),head_preconds_into_body((record(False,_3198,_3168):-(u_assign([Arg1,Arg2,Arg3],_3202),_3202=_3198),((u_assign([Arg1,Arg2,Arg3],_3298),_3298=_3294),u_assign([False,Arg1,Arg2,Arg3],_3348),_3348=_3344),u_assign(['â\x8A\·',False,_3294,_3344],_3168)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[record,False,[Arg1,Arg2,Arg3]],['â\x8A\·',False,[Arg1,Arg2,Arg3],[False,Arg1,Arg2,Arg3]])
</span><span class="ansi38-255165000">  (= 
    (record $False 
      ($Arg1 $Arg2 $Arg3)) 
    (â· $False 
      ($Arg1 $Arg2 $Arg3) 
      ($False $Arg1 $Arg2 $Arg3)))
</span><span class="ansi38-000082136">  :- dynamic(record,3).

  record(False, A, B) :-
    u_assign([Arg1, Arg2, Arg3], C),
    C=A,
    ( u_assign([Arg1, Arg2, Arg3], D),
      D=E
    ),
    u_assign([False, Arg1, Arg2, Arg3], F),
    F=G,
    u_assign(['â\u008A·', False, E, G], B).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( record(False,False,Assign_Record) :-
%~                              u_assign([Arg1,Arg2,Arg3,Arg4],Assign) ,
%~                              Assign=False ,
%~                              u_assign( [Arg1,Arg2,Arg3,Arg4],
%~                                Assign3) ,
%~                              Assign3=_229438 ,
%~                              u_assign(
%~                                 [ False, Arg1,Arg2,Arg3,
%~                                   Arg4],
%~                                 Assign4) ,
%~                              Assign4=_229456 ,
%~                              u_assign(['â\x8A\·',False,_229438,_229456],Assign_Record))]
%~ [convert(_107190),head_preconds_into_body((record(False,_106038,_105702):-(u_assign([Arg1,Arg2,Arg3,Arg4],_106048),_106048=_106038),((u_assign([Arg1,Arg2,Arg3,Arg4],_107552),_107552=_107542),u_assign([False,Arg1,Arg2,Arg3,Arg4],_107870),_107870=_107860),u_assign(['â\x8A\·',False,_107542,_107860],_105702)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[record,False,[Arg1,Arg2,Arg3,Arg4]],['â\x8A\·',False,[Arg1,Arg2,Arg3,Arg4],[False,Arg1,Arg2,Arg3,Arg4]])
</span><span class="ansi38-255165000">  (= 
    (record $False 
      ($Arg1 $Arg2 $Arg3 $Arg4)) 
    (â· $False 
      ($Arg1 $Arg2 $Arg3 $Arg4) 
      ($False $Arg1 $Arg2 $Arg3 $Arg4)))
</span><span class="ansi38-000082136">  :- dynamic(record,3).

  record(False, A, B) :-
    u_assign([Arg1, Arg2, Arg3, Arg4], C),
    C=A,
    ( u_assign([Arg1, Arg2, Arg3, Arg4], D),
      D=E
    ),
    u_assign([False, Arg1, Arg2, Arg3, Arg4],
             F),
    F=G,
    u_assign(['â\u008A·', False, E, G], B).

</span>

; Evaluation took 398.88 ms.
<span class="ansi33"> &self

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Predicate','Type'])
</span><span class="ansi38-255165000">  (: Predicate Type)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â\x86\\x92\',[->,'Predicate','Predicate','Type']])
</span><span class="ansi38-255165000">  (: â 
    (-> Predicate Predicate Type))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'P','Predicate'])
</span><span class="ansi38-255165000">  (: P Predicate)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Q','Predicate'])
</span><span class="ansi38-255165000">  (: Q Predicate)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'R','Predicate'])
</span><span class="ansi38-255165000">  (: R Predicate)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,kb,[->,'Atom']])
</span><span class="ansi38-255165000">  (: kb 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( [kb,_331086] :-
%~                              ( ( u_assign(['STV',0.5,0.1],Assign)  ,
%~                                  Assign=VAR_Assign ,
%~                                  u_assign(['â\x89\\x9E\','P',VAR_Assign],Assign1) ,
%~                                  Assign1=VAR_Assign1 ,
%~                                  u_assign([:,'Pm',VAR_Assign1],Assign2) ,
%~                                  Assign2=VAR_Assign2)  ;
%~                                ( u_assign(['STV',0.6,0.2],Assign3)  ,
%~                                  Assign3=VAR_Assign3 ,
%~                                  u_assign(['â\x89\\x9E\','Q',VAR_Assign3],Assign4) ,
%~                                  Assign4=VAR_Assign4 ,
%~                                  u_assign([:,'Qm',VAR_Assign4],Assign5) ,
%~                                  Assign5=VAR_Assign2) ;
%~                                ( u_assign(['STV',0.7,0.3],Assign6)  ,
%~                                  Assign6=VAR_Assign6 ,
%~                                  u_assign(['â\x89\\x9E\','R',VAR_Assign6],Assign7) ,
%~                                  Assign7=VAR_Assign7 ,
%~                                  u_assign([:,'Rm',VAR_Assign7],Assign8) ,
%~                                  Assign8=VAR_Assign2) ;
%~                                ( u_assign(['â\x86\\x92\','P','Q'],Assign9)  ,
%~                                  Assign9=VAR_Assign9 ,
%~                                  u_assign(['STV',0.8,0.4],Assign10) ,
%~                                  Assign10=VAR_Assign10 ,
%~                                  u_assign(['â\x89\\x9E\',VAR_Assign9,VAR_Assign10],Assign11) ,
%~                                  Assign11=VAR_Assign11 ,
%~                                  u_assign([:,'PQm',VAR_Assign11],Assign12) ,
%~                                  Assign12=VAR_Assign2) ;
%~                                ( u_assign(['â\x86\\x92\','Q','R'],Assign13)  ,
%~                                  Assign13=VAR_Assign13 ,
%~                                  u_assign(['STV',0.9,0.5],Assign14) ,
%~                                  Assign14=VAR_Assign14 ,
%~                                  u_assign(['â\x89\\x9E\',VAR_Assign13,VAR_Assign14],Assign15) ,
%~                                  Assign15=VAR_Assign15 ,
%~                                  u_assign([:,'QRm',VAR_Assign15],Assign16) ,
%~                                  Assign16=VAR_Assign2)))]
%~ [convert(_3012),head_preconds_into_body(([kb,_2988]:-((((u_assign(['STV',0.5,0.1],_3090),_3090=_3086),u_assign(['â\x89\\x9E\','P',_3086],_3058)),_3058=_3054),u_assign([:,'Pm',_3054],_3026)),_3026=_2988;((((u_assign(['STV',0.6,0.2],_3222),_3222=_3218),u_assign(['â\x89\\x9E\','Q',_3218],_3190)),_3190=_3186),u_assign([:,'Qm',_3186],_3158)),_3158=_2988;((((u_assign(['STV',0.7,0.3],_3354),_3354=_3350),u_assign(['â\x89\\x9E\','R',_3350],_3322)),_3322=_3318),u_assign([:,'Rm',_3318],_3290)),_3290=_2988;(((((u_assign(['â\x86\\x92\','P','Q'],_3480),_3480=_3476),u_assign(['STV',0.8,0.4],_3530),_3530=_3526),u_assign(['â\x89\\x9E\',_3476,_3526],_3454)),_3454=_3450),u_assign([:,'PQm',_3450],_3422)),_3422=_2988;(((((u_assign(['â\x86\\x92\','Q','R'],_3662),_3662=_3658),u_assign(['STV',0.9,0.5],_3712),_3712=_3708),u_assign(['â\x89\\x9E\',_3658,_3708],_3636)),_3636=_3632),u_assign([:,'QRm',_3632],_3604)),_3604=_2988))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[kb],[superpose,[[:,'Pm',['â\x89\\x9E\','P',['STV',0.5,0.1]]],[:,'Qm',['â\x89\\x9E\','Q',['STV',0.6,0.2]]],[:,'Rm',['â\x89\\x9E\','R',['STV',0.7,0.3]]],[:,'PQm',['â\x89\\x9E\',['â\x86\\x92\','P','Q'],['STV',0.8,0.4]]],[:,'QRm',['â\x89\\x9E\',['â\x86\\x92\','Q','R'],['STV',0.9,0.5]]]]])
</span><span class="ansi38-255165000">  (= 
    (kb) 
    (superpose 
      ( (: Pm 
          (â P 
            (STV 0.5 0.1))) 
        (: Qm 
          (â Q 
            (STV 0.6 0.2))) 
        (: Rm 
          (â R 
            (STV 0.7 0.3))) 
        (: PQm 
          (â 
            (â P Q) 
            (STV 0.8 0.4))) 
        (: QRm 
          (â 
            (â Q R) 
            (STV 0.9 0.5))))))
</span><span class="ansi38-000082136">
  [kb, A] :-
    (   ( ( u_assign(['STV', 0.5, 0.1], B),
            B=C
          ),
          u_assign(['â\u0089\u009E', 'P', C], D),
          D=E
        ),
        u_assign([:, 'Pm', E], F),
        F=A
    ;   ( ( u_assign(['STV', 0.6, 0.2], G),
            G=H
          ),
          u_assign(['â\u0089\u009E', 'Q', H], I),
          I=J
        ),
        u_assign([:, 'Qm', J], K),
        K=A
    ;   ( ( u_assign(['STV', 0.7, 0.3], L),
            L=M
          ),
          u_assign(['â\u0089\u009E', 'R', M], N),
          N=O
        ),
        u_assign([:, 'Rm', O], P),
        P=A
    ;   ( ( u_assign(['â\u0086\u0092', 'P', 'Q'], Q),
            Q=R,
            u_assign(['STV', 0.8, 0.4], S),
            S=T
          ),
          u_assign(['â\u0089\u009E', R, T], U),
          U=V
        ),
        u_assign([:, 'PQm', V], W),
        W=A
    ;   ( ( u_assign(['â\u0086\u0092', 'Q', 'R'], X),
            X=Y,
            u_assign(['STV', 0.9, 0.5], Z),
            Z=A1
          ),
          u_assign(['â\u0089\u009E', Y, A1], B1),
          B1=C1
        ),
        u_assign([:, 'QRm', C1], D1),
        D1=A
    ).

</span>

;; Rule base
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,rb,[->,'Atom']])
</span><span class="ansi38-255165000">  (: rb 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(([rb,_25788]:-['deduction-rule',_25788]))]
%~ [convert(_27628),head_preconds_into_body(([rb,_25788]:-['deduction-rule',_25788]))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[rb],['deduction-rule'])
</span><span class="ansi38-255165000">  (= 
    (rb) 
    (deduction-rule))
</span><span class="ansi38-000082136">
  [rb, A] :-
    ['deduction-rule', A].

</span>

;; Test deduction rule
;;
;; Build the following inference tree
;;
;; ------------(Pm)  ----------(Qm)  ------------(Rm)  ------------  --(PQm)  ----------------(QRm)
;; P â <0.5 0.1>     Q â <0.6 0.2>   R â <0.7 0.1>     P â Q â <0.8 0.5>      Q â R â <0.9 0.5>
;; -------------------------------------------------------------------------------------------(Deduction)
;;                                          P â R â $tv
;; The following is disabled till the type checker supports running functions inside types
;; ! "===== Test type checker on deduction rule ====="
;; (: deduction_prf (â (â P R) $tv))
;; (= deduction_prf (Deduction Pm Qm Rm PQm QRm))
;; !(deduction_prf)
;; !(get-type deduction_prf)
;; Test synthesizer
<span class="ansi38-000068000">!"===== Test synthesizer ===="

</span><span class="ansi38-017068017">exec(A) :-
    A="===== Test synthesizer ====".

</span>; Evaluation took 0.010 ms. (10.00 microseconds) 
<span class="ansi33"> "===== Test synthesizer ===="

</span><span class="ansi38-000068000">!(record synthesize ((: $Proof (â (â P Q) $Tv)) kb rb Z))

</span><span class="ansi38-017068017">exec(A) :-
    ( ( ( ( ( true,
              u_assign(['â\u0086\u0092', 'P', 'Q'], B)
            ),
            B=C,
            true
          ),
          u_assign(['â\u0089\u009E', C, Tv], D),
          D=E
        ),
        u_assign([:, Proof, E], F),
        F=G
      ),
      true,
      u_assign([G, kb, rb, 'Z'], H)
    ),
    H=I,
    u_assign([record, synthesize, I], A).

</span>; Evaluation took 10.61 ms.
<span class="ansi33">  (â· synthesize 
    ( (: PQm 
        (â 
          (â P Q) 
          (STV 0.8 0.4))) kb rb Z) 
    (: PQm 
      (â 
        (â P Q) 
        (STV 0.8 0.4))))
</span><span class="ansi32">['Tv'=['STV',0.8,0.4],'Proof'='PQm']
</span>

; (: PQm (â (â P Q) (STV 0.8 0.4)))
<span class="ansi38-000068000">!(record synthesize ((: $Proof (â (â Q R) $Tv)) kb rb Z))

</span><span class="ansi38-017068017">exec(A) :-
    ( ( ( ( ( true,
              u_assign(['â\u0086\u0092', 'Q', 'R'], B)
            ),
            B=C,
            true
          ),
          u_assign(['â\u0089\u009E', C, Tv], D),
          D=E
        ),
        u_assign([:, Proof, E], F),
        F=G
      ),
      true,
      u_assign([G, kb, rb, 'Z'], H)
    ),
    H=I,
    u_assign([record, synthesize, I], A).

</span>; Evaluation took 12.35 ms.
<span class="ansi33">  (â· synthesize 
    ( (: QRm 
        (â 
          (â Q R) 
          (STV 0.9 0.5))) kb rb Z) 
    (: QRm 
      (â 
        (â Q R) 
        (STV 0.9 0.5))))
</span><span class="ansi32">['Tv'=['STV',0.9,0.5],'Proof'='QRm']
</span>

; (: QRm (â (â Q R) (STV 0.9 0.5)))
<span class="ansi38-000068000">!(record synthesize ((: $Proof (â (â P R) $Tv)) kb rb (S Z)))

</span><span class="ansi38-017068017">exec(A) :-
    ( ( ( ( ( true,
              u_assign(['â\u0086\u0092', 'P', 'R'], B)
            ),
            B=C,
            true
          ),
          u_assign(['â\u0089\u009E', C, Tv], D),
          D=E
        ),
        u_assign([:, Proof, E], F),
        F=G
      ),
      ( true,
        u_assign(['S', 'Z'], H)
      ),
      H=I,
      u_assign([G, kb, rb, I], J)
    ),
    J=K,
    u_assign([record, synthesize, K], A).

</span>; Evaluation took 145.27 ms.
<span class="ansi33">  (â· synthesize 
    ( (: 
        (Deduction Pm Qm Rm PQm QRm) 
        (â 
          (â P R) 
          (STV 0.7 0.1))) kb rb 
      (S Z)) 
    (: 
      (Deduction Pm Qm Rm PQm QRm) 
      (â 
        (â P R) 
        (STV 0.7 0.1))))
</span><span class="ansi32">['Tv'=['STV',0.7,0.1],'Proof'=['Deduction','Pm','Qm','Rm','PQm','QRm']]
</span>

<span class="ansi32">% 79,284,022 inferences, 12.300 CPU in 12.300 seconds (100% CPU, 6445775 Lips)
</span> (@ = "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/dependent-types/DeductionDTLTest.metta" 0)
<br/><a href="https://github.com/logicmoo/vspace-metta/blob/main/MeTTaLog.md">Return to Summaries</a><br/>
doing(ansi2html -u < "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/TEE.ansi" > "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/dependent-types/DeductionDTLTest.html" )

</pre>
</body>

</html>
