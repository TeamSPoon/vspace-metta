<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>
<style type="text/css">
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content">
 (@ track_load_into_file "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/dependent-types/ModusPonensDTLTest.metta")
;; Import modules
<span class="ansi38-000068000">!(import! &self ModusPonensDTL.metta)

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&self', 'ModusPonensDTL.metta'], A).

</span>;; MeTTa port for modus ponens PLN rule
;; as DTL (Dependent Type Language)
;;
;; (â A atv)
;; (â (â A B) abtv)
;; â¢
;; (â B btv)
;;
;; where atv and abtv are truth values of the premises A and (â A B) respectively,
;; and btv represents the resulting truth value of the conclusion.
;;
;; This rule contains less premises but thus is less precise.
;; In order to properly calculate P(B) it must
;; account for P(B|A) and P(B|Not A), as follows
;;
;; P(B) = P(B|A)*P(A) + P(B|Not A)*P(Not A)
;;
;; However in this rule to avoid requiring too many premises it is
;; assumed
;;
;; P(B|Not A) = 0.2
;;
;; which is a temporary hack. Maybe the resulting confidence could at
;; least be degraded to conpensate for that hack. But ideally one
;; should use a precise modus ponens (requiring P(B|Not A) as
;; premises), and then if missing, these premises could be estimated
;; via other rules.
;; Import modules
<span class="ansi38-000068000">!(import! &self "../common/truthvalue/MeasEq.metta")

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&self', '../common/truthvalue/MeasEq.metta'], A).

</span>;; The symbol â, called Measured By in Unicode, and \measeq in LaTeX,
;; is used to represent the measure of an event.  This measure may be
;; boolean, probabilistic first or second order, evidential or
;; otherwise.  The idea of using a dedicated equality, as opposed to
;; regular definitional equality =, is to not conflate event and
;; measure which can lead to contradictions.
;; Define â as a dependent type, assigning a truth value to an event.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â\x89\\x9E\',[->,Event,Tv,'Type']])
</span><span class="ansi38-255165000">  (: â 
    (-> $Event $Tv Type))
</span>

; Evaluation took 1.28 ms.
<span class="ansi33"> &self

</span><span class="ansi38-000068000">!(import! &self "../common/formula/ModusPonensFormula.metta")

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&self', '../common/formula/ModusPonensFormula.metta'],
             A).

</span>;; Define modus ponens rule
;; Formula for the modus ponens rule
;; Import modules
<span class="ansi38-000068000">!(import! &self "../truthvalue/TruthValue.metta")

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&self', '../truthvalue/TruthValue.metta'], A).

</span>;; Truth value type definition
;; Import modules
<span class="ansi38-000068000">!(import! &self "../Num.metta")

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&self', '../Num.metta'], A).

</span>;;;;;;;;;;
;; Type ;;
;;;;;;;;;;
;; Collection of functions operating on numbers
;; Define max
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,max,[->,A,A,A]])
</span><span class="ansi38-255165000">  (: max 
    (-> $A $A $A))
</span>

%~ /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/metta_vspace/pyswip/metta_interp.pl:1054 
%~ [ convert(Convert),
%~   head_preconds_into_body( max(X,Y,Assign_Max_Y) :-
%~                              u_assign([>,X,Y],Assign) ,
%~                              Assign=_7680 ,
%~                              u_assign([if,_7680,X,Y],Assign_Max_Y))]
%~ [convert(_4186),head_preconds_into_body((max(X,Y,_4144):-(u_assign([>,X,Y],_4224),_4224=_4220),u_assign([if,_4220,X,Y],_4144)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[max,X,Y],[if,[>,X,Y],X,Y])
</span><span class="ansi38-255165000">  (= 
    (max $X $Y) 
    (if 
      (> $X $Y) $X $Y))
</span><span class="ansi38-000082136">  :- dynamic(max,3).

  max(X, Y, A) :-
    u_assign([>, X, Y], B),
    B=C,
    u_assign([if, C, X, Y], A).

</span>

;; Define min
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,min,[->,A,A,A]])
</span><span class="ansi38-255165000">  (: min 
    (-> $A $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( min(X,Y,Assign_Min_Y) :-
%~                              u_assign([<,X,Y],Assign) ,
%~                              Assign=_131880 ,
%~                              u_assign([if,_131880,X,Y],Assign_Min_Y))]
%~ [convert(_73538),head_preconds_into_body((min(X,Y,_72302):-(u_assign([<,X,Y],_73844),_73844=_73834),u_assign([if,_73834,X,Y],_72302)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[min,X,Y],[if,[<,X,Y],X,Y])
</span><span class="ansi38-255165000">  (= 
    (min $X $Y) 
    (if 
      (< $X $Y) $X $Y))
</span><span class="ansi38-000082136">  :- dynamic(min,3).

  min(X, Y, A) :-
    u_assign([<, X, Y], B),
    B=C,
    u_assign([if, C, X, Y], A).

</span>

;; Clamp a number to be within a certain range
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,clamp,[->,A,A,A,A]])
</span><span class="ansi38-255165000">  (: clamp 
    (-> $A $A $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( clamp(X,L,U,Assign_Clamp_U) :-
%~                              u_assign([min,U,X],Assign) ,
%~                              Assign=_254900 ,
%~                              u_assign([max,L,_254900],Assign_Clamp_U))]
%~ [convert(_195172),head_preconds_into_body((clamp(X,L,U,_193866):-(u_assign([min,U,X],_195534),_195534=_195524),u_assign([max,L,_195524],_193866)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[clamp,X,L,U],[max,L,[min,U,X]])
</span><span class="ansi38-255165000">  (= 
    (clamp $X $L $U) 
    (max $L 
      (min $U $X)))
</span><span class="ansi38-000082136">  :- dynamic(clamp,4).

  clamp(X, L, U, A) :-
    u_assign([min, U, X], B),
    B=C,
    u_assign([max, L, C], A).

</span>

;; Define abs
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,abs,[->,A,A]])
</span><span class="ansi38-255165000">  (: abs 
    (-> $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( abs(X,Assign_Abs_X) :-
%~                              u_assign([<,X,0],Assign) ,
%~                              Assign=_400308 ,
%~                              u_assign([*,-1,X],Assign3) ,
%~                              Assign3=_400326 ,
%~                              u_assign([if,_400308,_400326,X],Assign_Abs_X))]
%~ [convert(_314646),head_preconds_into_body((abs(X,_313480):-((u_assign([<,X,0],_314952),_314952=_314942),u_assign([*,-1,X],_315112),_315112=_315102),u_assign([if,_314942,_315102,X],_313480)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[abs,X],[if,[<,X,0],[*,-1,X],X])
</span><span class="ansi38-255165000">  (= 
    (abs $X) 
    (if 
      (< $X 0) 
      (* -1 $X) $X))
</span><span class="ansi38-000082136">
  abs(X, A) :-
    ( u_assign([<, X, 0], B),
      B=C
    ),
    u_assign([*, -1, X], D),
    D=E,
    u_assign([if, C, E, X], A).

</span>

;; Define <=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,<=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: <= 
    (-> $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( <=(X,Y,Assign_Y) :-
%~                              u_assign([<,X,Y],Assign) ,
%~                              Assign=_65158 ,
%~                              u_assign([==,X,Y],Assign2) ,
%~                              Assign2=_65176 ,
%~                              u_assign([or,_65158,_65176],Assign_Y))]
%~ [convert(_4478),head_preconds_into_body((<=(X,Y,_4436):-((u_assign([<,X,Y],_4516),_4516=_4512),u_assign([==,X,Y],_4566),_4566=_4562),u_assign([or,_4512,_4562],_4436)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[<=,X,Y],[or,[<,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">  (= 
    (<= $X $Y) 
    (or 
      (< $X $Y) 
      (== $X $Y)))
</span><span class="ansi38-000082136">  :- dynamic(<=,3).

  <=(X, Y, A) :-
    ( u_assign([<, X, Y], B),
      B=C
    ),
    u_assign([==, X, Y], D),
    D=E,
    u_assign([or, C, E], A).

</span>

;; Define >=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,>=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: >= 
    (-> $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( >=(X,Y,Assign_Y) :-
%~                              u_assign([>,X,Y],Assign) ,
%~                              Assign=_200936 ,
%~                              u_assign([==,X,Y],Assign2) ,
%~                              Assign2=_200954 ,
%~                              u_assign([or,_200936,_200954],Assign_Y))]
%~ [convert(_125288),head_preconds_into_body((>=(X,Y,_124052):-((u_assign([>,X,Y],_125594),_125594=_125584),u_assign([==,X,Y],_125798),_125798=_125788),u_assign([or,_125584,_125788],_124052)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[>=,X,Y],[or,[>,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">  (= 
    (>= $X $Y) 
    (or 
      (> $X $Y) 
      (== $X $Y)))
</span><span class="ansi38-000082136">  :- dynamic(>=,3).

  >=(X, Y, A) :-
    ( u_assign([>, X, Y], B),
      B=C
    ),
    u_assign([==, X, Y], D),
    D=E,
    u_assign([or, C, E], A).

</span>

;; Define approximately equal
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,approxEq,[->,A,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: approxEq 
    (-> $A $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( approxEq(X,Y,Epsilon,Assign_ApproxEq_Epsilon) :-
%~                              u_assign([-,X,Y],Assign) ,
%~                              Assign=_347304 ,
%~                              u_assign([abs,_347304],Assign3) ,
%~                              Assign3=_347328 ,
%~                              u_assign([<=,_347328,Epsilon],Assign_ApproxEq_Epsilon))]
%~ [convert(_261064),head_preconds_into_body((approxEq(X,Y,Epsilon,_259758):-(((u_assign([-,X,Y],_261412),_261412=_261402),u_assign([abs,_261402],_261370)),_261370=_261360),u_assign([<=,_261360,Epsilon],_259758)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[approxEq,X,Y,Epsilon],[<=,[abs,[-,X,Y]],Epsilon])
</span><span class="ansi38-255165000">  (= 
    (approxEq $X $Y $Epsilon) 
    (<= 
      (abs 
        (- $X $Y)) $Epsilon))
</span><span class="ansi38-000082136">  :- dynamic(approxEq,4).

  approxEq(X, Y, Epsilon, A) :-
    ( u_assign([-, X, Y], B),
      B=C,
      u_assign([abs, C], D)
    ),
    D=E,
    u_assign([<=, E, Epsilon], A).

</span>

;; Define Nat
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Nat','Type'])
</span><span class="ansi38-255165000">  (: Nat Type)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Z','Nat'])
</span><span class="ansi38-255165000">  (: Z Nat)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'S',[->,'Nat','Nat']])
</span><span class="ansi38-255165000">  (: S 
    (-> Nat Nat))
</span>

;; Define cast functions between Nat and Number
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNumber,[->,'Number','Nat']])
</span><span class="ansi38-255165000">  (: fromNumber 
    (-> Number Nat))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( fromNumber(N,N) :-
%~                              u_assign([<=,N,0],Assign) ,
%~                              Assign=_57094 ,
%~                              u_assign([-,N,1],Assign2) ,
%~                              Assign2=_57136 ,
%~                              u_assign([fromNumber,_57136],Assign3) ,
%~                              Assign3=_57160 ,
%~                              u_assign(['S',_57160],Assign4) ,
%~                              Assign4=_57184 ,
%~                              u_assign([if,_57094,'Z',_57184],N))]
%~ [convert(_4484),head_preconds_into_body((fromNumber(N,_4448):-((u_assign([<=,N,0],_4522),_4522=_4518),((((u_assign([-,N,1],_4630),_4630=_4626),u_assign([fromNumber,_4626],_4604)),_4604=_4600),u_assign(['S',_4600],_4578)),_4578=_4574),u_assign([if,_4518,'Z',_4574],_4448)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNumber,N],[if,[<=,N,0],'Z',['S',[fromNumber,[-,N,1]]]])
</span><span class="ansi38-255165000">  (= 
    (fromNumber $N) 
    (if 
      (<= $N 0) Z 
      (S 
        (fromNumber 
          (- $N 1)))))
</span><span class="ansi38-000082136">  :- dynamic(fromNumber,2).

  fromNumber(N, A) :-
    ( u_assign([<=, N, 0], B),
      B=C
    ),
    ( ( u_assign([-, N, 1], D),
        D=E,
        u_assign([fromNumber, E], F)
      ),
      F=G,
      u_assign(['S', G], H)
    ),
    H=I,
    u_assign([if, C, 'Z', I], A).

</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNat,[->,'Nat','Number']])
</span><span class="ansi38-255165000">  (: fromNat 
    (-> Nat Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((fromNat('Z',0):-true))]
%~ [convert(_104158),head_preconds_into_body((fromNat('Z',0):-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,'Z'],0)
</span><span class="ansi38-255165000">  (= 
    (fromNat Z) 0)
</span><span class="ansi38-000082136">  :- dynamic(fromNat,2).

  fromNat('Z', 0).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( fromNat(FromNat,FromNat1) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=FromNat ,
%~                              u_assign([fromNat,K],Assign3) ,
%~                              [+,1,Assign3,FromNat1])]
%~ [convert(_149314),head_preconds_into_body((fromNat(_148360,_148080):-(u_assign(['S',K],_148370),_148370=_148360),u_assign([fromNat,K],_149638),[+,1,_149638,_148080]))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,['S',K]],[+,1,[fromNat,K]])
</span><span class="ansi38-255165000">  (= 
    (fromNat 
      (S $K)) 
    (+ 1 
      (fromNat $K)))
</span><span class="ansi38-000082136">  :- dynamic(fromNat,2).

  fromNat(A, B) :-
    u_assign(['S', K], C),
    C=A,
    u_assign([fromNat, K], D),
    [+, 1, D, B].

</span>

;; Define a generic less than operator, â©», for Nat.  < cannot be used
;; because it is a built-in, its type is hardwired and cannot be
;; overloaded.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Nat','Nat','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Nat Nat Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('â©»'(_,'Z',_248056):-_248056='False'))]
%~ [convert(_249248),head_preconds_into_body(('â©»'(_,'Z',_248056):-_248056='False'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',_,'Z'],'False')
</span><span class="ansi38-255165000">  (= 
    (â©» $_ Z) False)
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(_, 'Z', A) :-
    A='False'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'('Z',Z,True) :-
%~                              u_assign(['S',_],Assign) ,
%~                              Assign=Z ,
%~                              True='True')]
%~ [convert(_295626),head_preconds_into_body(('â©»'('Z',_294658,_294366):-(u_assign(['S',_],_294668),_294668=_294658),_294366='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»','Z',['S',_]],'True')
</span><span class="ansi38-255165000">  (= 
    (â©» Z 
      (S $_)) True)
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'('Z', A, B) :-
    u_assign(['S', _], C),
    C=A,
    B='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'(Â1,Â,Assign_Â2) :-
%~                              u_assign(['S',X],Assign) ,
%~                              Assign=Â1 ,
%~                              u_assign(['S',Y],Assign4) ,
%~                              Assign4=Â ,
%~                              u_assign(['â©»',X,Y],Assign_Â2))]
%~ [convert(_366668),head_preconds_into_body(('â©»'(_365552,_365686,_365272):-((u_assign(['S',X],_365562),_365562=_365552),u_assign(['S',Y],_365696),_365696=_365686),u_assign(['â©»',X,Y],_365272)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',['S',X],['S',Y]],['â©»',X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» 
      (S $X) 
      (S $Y)) 
    (â©» $X $Y))
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(A, B, C) :-
    ( u_assign(['S', X], D),
      D=A
    ),
    u_assign(['S', Y], E),
    E=B,
    u_assign(['â©»', X, Y], C).

</span>

;; Overload â©» for Number.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Number','Number','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Number Number Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'(X,Y,Assign_Â_Y) :-
%~                              u_assign([<,X,Y],Assign_Â_Y))]
%~ [convert(_464370),head_preconds_into_body(('â©»'(X,Y,_463134):-u_assign([<,X,Y],_463134)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',X,Y],[<,X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» $X $Y) 
    (< $X $Y))
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(X, Y, A) :-
    u_assign([<, X, Y], A).

</span>

;; Return the ceiling of a non negative number.  If the number is
;; negative it returns 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,ceil,[->,'Number','Number']])
</span><span class="ansi38-255165000">  (: ceil 
    (-> Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ceil(N,Assign_Ceil_N) :-
%~                              u_assign([fromNumber,N],Assign) ,
%~                              Assign=_77600 ,
%~                              u_assign([fromNat,_77600],Assign_Ceil_N))]
%~ [convert(_21286),head_preconds_into_body((ceil(N,_20120):-(u_assign([fromNumber,N],_21592),_21592=_21582),u_assign([fromNat,_21582],_20120)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[ceil,N],[fromNat,[fromNumber,N]])
</span><span class="ansi38-255165000">  (= 
    (ceil $N) 
    (fromNat 
      (fromNumber $N)))
</span><span class="ansi38-000082136">  :- dynamic(ceil,2).

  ceil(N, A) :-
    u_assign([fromNumber, N], B),
    B=C,
    u_assign([fromNat, C], A).

</span>

;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'number->bool',[->,'Number','Bool']])
</span><span class="ansi38-255165000">  (: number->bool 
    (-> Number Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'number->bool'(X,Number_c62_bool_X) :-
%~                              u_assign([<,0,X],Number_c62_bool_X))]
%~ [convert(_118896),head_preconds_into_body(('number->bool'(X,_117730):-u_assign([<,0,X],_117730)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['number->bool',X],[<,0,X])
</span><span class="ansi38-255165000">  (= 
    (number->bool $X) 
    (< 0 $X))
</span><span class="ansi38-000082136">  :- dynamic('number->bool',2).

  'number->bool'(X, A) :-
    u_assign([<, 0, X], A).

</span>

;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'bool->number',[->,'Bool','Number']])
</span><span class="ansi38-255165000">  (: bool->number 
    (-> Bool Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('bool->number'('False',0):-true))]
%~ [convert(_189384),head_preconds_into_body(('bool->number'('False',0):-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','False'],0)
</span><span class="ansi38-255165000">  (= 
    (bool->number False) 0)
</span><span class="ansi38-000082136">  :- dynamic('bool->number',2).

  'bool->number'('False', 0).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('bool->number'(_225956,1):-is_True(_225956)))]
%~ [convert(_226792),head_preconds_into_body(('bool->number'(_225956,1):-is_True(_225956)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','True'],1)
</span><span class="ansi38-255165000">  (= 
    (bool->number True) 1)
</span><span class="ansi38-000082136">  :- dynamic('bool->number',2).

  'bool->number'(A, 1) :-
    is_True(A).

</span>

;; Define a less than type.  Note that it is purposefully different
;; than â©» as it is a type, not an operator.  Inhabitants of (â x y)
;; are proofs that x â©» y == True.  For now â is only axiomatized for
;; Nat.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â\x8D\\x83\',[->,True,True,'Type']])
</span><span class="ansi38-255165000">  (: â 
    (-> $True $True Type))
</span>

;; Zero is always less than the successor of something
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['zero-lt-succ-axiom'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ['zero-lt-succ-axiom',Assign2] :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=_391022 ,
%~                              u_assign(['â\x8D\\x83\','Z',_391022],Assign1) ,
%~                              Assign1=_391052 ,
%~                              u_assign([:,'ZeroLTSucc',_391052],Assign2))]
%~ [convert(_292036),head_preconds_into_body((['zero-lt-succ-axiom',_290196]:-(((u_assign(['S',K],_292408),_292408=_292398),u_assign(['â\x8D\\x83\','Z',_292398],_292354)),_292354=_292344),u_assign([:,'ZeroLTSucc',_292344],_290196)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['zero-lt-succ-axiom'],[:,'ZeroLTSucc',['â\x8D\\x83\','Z',['S',K]]])
</span><span class="ansi38-255165000">  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (â Z 
        (S $K))))
</span><span class="ansi38-000082136">
  ['zero-lt-succ-axiom', A] :-
    ( u_assign(['S', K], B),
      B=C,
      u_assign(['â\u008D\u0083', 'Z', C], D)
    ),
    D=E,
    u_assign([:, 'ZeroLTSucc', E], A).

</span>

;; If x â y then (S x) â (S y)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['succ-monotonicity-rule'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ['succ-monotonicity-rule',Assign5] :-
%~                              u_assign(['â\x8D\\x83\',X,Y],Assign) ,
%~                              Assign=_77128 ,
%~                              u_assign(['S',X],Assign1) ,
%~                              Assign1=_77164 ,
%~                              u_assign(['S',Y],Assign2) ,
%~                              Assign2=_77182 ,
%~                              u_assign(['â\x8D\\x83\',_77164,_77182],Assign3) ,
%~                              Assign3=_77212 ,
%~                              u_assign([->,_77128,_77212],Assign4) ,
%~                              Assign4=_77242 ,
%~                              u_assign([:,'SuccMonotonicity',_77242],Assign5))]
%~ [convert(_4498),head_preconds_into_body((['succ-monotonicity-rule',_4474]:-((((u_assign(['â\x8D\\x83\',X,Y],_4568),_4568=_4564),(((u_assign(['S',X],_4644),_4644=_4640),u_assign(['S',Y],_4688),_4688=_4684),u_assign(['â\x8D\\x83\',_4640,_4684],_4618)),_4618=_4614),u_assign([->,_4564,_4614],_4542)),_4542=_4538),u_assign([:,'SuccMonotonicity',_4538],_4474)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['succ-monotonicity-rule'],[:,'SuccMonotonicity',[->,['â\x8D\\x83\',X,Y],['â\x8D\\x83\',['S',X],['S',Y]]]])
</span><span class="ansi38-255165000">  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (â $X $Y) 
        (â 
          (S $X) 
          (S $Y)))))
</span><span class="ansi38-000082136">
  ['succ-monotonicity-rule', A] :-
    ( ( u_assign(['â\u008D\u0083', X, Y], B),
        B=C
      ),
      ( ( u_assign(['S', X], D),
          D=E
        ),
        u_assign(['S', Y], F),
        F=G,
        u_assign(['â\u008D\u0083', E, G], H)
      ),
      H=I,
      u_assign([->, C, I], J)
    ),
    J=K,
    u_assign([:, 'SuccMonotonicity', K], A).

</span>

; Evaluation took 1466.09 ms.
<span class="ansi33"> &self

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'TruthValue','Type'])
</span><span class="ansi38-255165000">  (: TruthValue Type)
</span>

;;;;;;;;;;;;;;;;;;
;; Constructors ;;
;;;;;;;;;;;;;;;;;;
;; Boolean TV constructor
;; TODO: alternatively we could have (: â¤ TruthValue) and (: â¥ TruthValue)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Bl',[->,'Bool','TruthValue']])
</span><span class="ansi38-255165000">  (: Bl 
    (-> Bool TruthValue))
</span>

;; First order probability TV constructor, i.e. mere probability.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Pr',[->,'Number','TruthValue']])
</span><span class="ansi38-255165000">  (: Pr 
    (-> Number TruthValue))
</span>

;; Second order probability TV constructor, i.e. probability and
;; count.  The second order probability is distributed according to a
;; beta distribution.  The first argument of the constructor
;; represents the mode of the second order distribution.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'PrCnt',[->,'Number','Number','TruthValue']])
</span><span class="ansi38-255165000">  (: PrCnt 
    (-> Number Number TruthValue))
</span>

;; Simple Truth Value.  A Second order probability TV constructor,
;; i.e. probability and confidence.  The probability is in fact the
;; mode of the corresponding beta distribution.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'STV',[->,'Number','Number','TruthValue']])
</span><span class="ansi38-255165000">  (: STV 
    (-> Number Number TruthValue))
</span>

;;;;;;;;;;;;;;;
;; Constants ;;
;;;;;;;;;;;;;;;
;; For now the underlying beta distributions have a Jeffreys prior,
;; i.e. the prior alpha and beta are 0.5.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,prior_alpha,[->,'Number']])
</span><span class="ansi38-255165000">  (: prior_alpha 
    (-> Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(([prior_alpha,0.5]:-true))]
%~ [convert(_360820),head_preconds_into_body(([prior_alpha,0.5]:-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[prior_alpha],0.5)
</span><span class="ansi38-255165000">  (= 
    (prior_alpha) 0.5)
</span><span class="ansi38-000082136">
  [prior_alpha, 0.5].

</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,prior_beta,[->,'Number']])
</span><span class="ansi38-255165000">  (: prior_beta 
    (-> Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(([prior_beta,0.5]:-true))]
%~ [convert(_451450),head_preconds_into_body(([prior_beta,0.5]:-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[prior_beta],0.5)
</span><span class="ansi38-255165000">  (= 
    (prior_beta) 0.5)
</span><span class="ansi38-000082136">
  [prior_beta, 0.5].

</span>

;; Lookahead
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,lookahead,[->,'Number']])
</span><span class="ansi38-255165000">  (: lookahead 
    (-> Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(([lookahead,1.0]:-true))]
%~ [convert(_37744),head_preconds_into_body(([lookahead,1.0]:-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[lookahead],1.0)
</span><span class="ansi38-255165000">  (= 
    (lookahead) 1.0)
</span><span class="ansi38-000082136">
  [lookahead, 1.0].

</span>

;; Maximum supported count (till +inf is supported, possibly).
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'max-count',[->,'Number']])
</span><span class="ansi38-255165000">  (: max-count 
    (-> Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((['max-count',1000000000.0]:-true))]
%~ [convert(_128466),head_preconds_into_body((['max-count',1000000000.0]:-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['max-count'],1000000000.0)
</span><span class="ansi38-255165000">  (= 
    (max-count) 1000000000.0)
</span><span class="ansi38-000082136">
  ['max-count', 1000000000.0].

</span>

;;;;;;;;;;;;;
;; Methods ;;
;;;;;;;;;;;;;
;; Convert count to confidence using the formula
;;
;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'count->confidence',[->,'Number','Number']])
</span><span class="ansi38-255165000">  (: count->confidence 
    (-> Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'count->confidence'(Cnt,Count_c62_confidence_Cnt) :-
%~                              [lookahead,_318770] ,
%~                              _318770=_318778 ,
%~                              u_assign([+,Cnt,_318778],Assign) ,
%~                              Assign=_318808 ,
%~                              u_assign([/,Cnt,_318808],Count_c62_confidence_Cnt))]
%~ [convert(_220234),head_preconds_into_body(('count->confidence'(Cnt,_219068):-((([lookahead,_221242],_221242=_221232),u_assign([+,Cnt,_221232],_221144)),_221144=_221134),u_assign([/,Cnt,_221134],_219068)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['count->confidence',Cnt],[/,Cnt,[+,Cnt,[lookahead]]])
</span><span class="ansi38-255165000">  (= 
    (count->confidence $Cnt) 
    (/ $Cnt 
      (+ $Cnt 
        (lookahead))))
</span><span class="ansi38-000082136">  :- dynamic('count->confidence',2).

  'count->confidence'(Cnt, A) :-
    ( [lookahead, B],
      B=C,
      u_assign([+, Cnt, C], D)
    ),
    D=E,
    u_assign([/, Cnt, E], A).

</span>

;; Convert confidence to count using the formula
;;
;; count = (confidence * lookahead) / (1 - confidence)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'confidence->count',[->,'Number','Number']])
</span><span class="ansi38-255165000">  (: confidence->count 
    (-> Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'confidence->count'(Conf,Assign_Conf) :-
%~                              u_assign([approxEq,1.0,Conf,1.0e-9],Assign) ,
%~                              Assign=_72028 ,
%~                              ['max-count',_72050] ,
%~                              _72050=_72058 ,
%~                              [lookahead,_72104] ,
%~                              _72104=_72112 ,
%~                              u_assign([*,Conf,_72112],Assign2) ,
%~                              Assign2=_72142 ,
%~                              u_assign([-,1.0,Conf],Assign3) ,
%~                              Assign3=_72160 ,
%~                              u_assign([/,_72142,_72160],Assign4) ,
%~                              Assign4=_72190 ,
%~                              u_assign([if,_72028,_72058,_72190],Assign_Conf))]
%~ [convert(_4094),head_preconds_into_body(('confidence->count'(Conf,_4058):-((u_assign([approxEq,1.0,Conf,1.0e-9],_4132),_4132=_4128),(['max-count',_4188],_4188=_4184),((((([lookahead,_4278],_4278=_4274),u_assign([*,Conf,_4274],_4246)),_4246=_4242),u_assign([-,1.0,Conf],_4322),_4322=_4318),u_assign([/,_4242,_4318],_4220)),_4220=_4216),u_assign([if,_4128,_4184,_4216],_4058)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['confidence->count',Conf],[if,[approxEq,1.0,Conf,1.0e-9],['max-count'],[/,[*,Conf,[lookahead]],[-,1.0,Conf]]])
</span><span class="ansi38-255165000">  (= 
    (confidence->count $Conf) 
    (if 
      (approxEq 1.0 $Conf 1.0e-9) 
      (max-count) 
      (/ 
        (* $Conf 
          (lookahead)) 
        (- 1.0 $Conf))))
</span><span class="ansi38-000082136">  :- dynamic('confidence->count',2).

  'confidence->count'(Conf, A) :-
    ( u_assign([approxEq, 1.0, Conf, 1.0e-9], B),
      B=C
    ),
    ( ['max-count', D],
      D=E
    ),
    ( ( ( [lookahead, F],
          F=G
        ),
        u_assign([*, Conf, G], H),
        H=I
      ),
      u_assign([-, 1.0, Conf], J),
      J=K,
      u_assign([/, I, K], L)
    ),
    L=M,
    u_assign([if, C, E, M], A).

</span>

;; Increment the given count by 1
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'inc-count',[->,'Number','Number']])
</span><span class="ansi38-255165000">  (: inc-count 
    (-> Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'inc-count'(Cnt,Inc_count_Cnt) :-
%~                              u_assign([+,1,Cnt],Inc_count_Cnt))]
%~ [convert(_149352),head_preconds_into_body(('inc-count'(Cnt,_148186):-u_assign([+,1,Cnt],_148186)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['inc-count',Cnt],[+,1,Cnt])
</span><span class="ansi38-255165000">  (= 
    (inc-count $Cnt) 
    (+ 1 $Cnt))
</span><span class="ansi38-000082136">  :- dynamic('inc-count',2).

  'inc-count'(Cnt, A) :-
    u_assign([+, 1, Cnt], A).

</span>

;; Increment the corresponding count of the given confidence by 1 and
;; return the confidence of that corresponding incremented count.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'inc-confidence',[->,'Number','Number']])
</span><span class="ansi38-255165000">  (: inc-confidence 
    (-> Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'inc-confidence'(Conf,Assign_Conf) :-
%~                              u_assign(['confidence->count',Conf],Assign) ,
%~                              Assign=_349148 ,
%~                              u_assign(['inc-count',_349148],Assign2) ,
%~                              Assign2=_349172 ,
%~                              u_assign(['count->confidence',_349172],Assign_Conf))]
%~ [convert(_260720),head_preconds_into_body(('inc-confidence'(Conf,_259554):-(((u_assign(['confidence->count',Conf],_261068),_261068=_261058),u_assign(['inc-count',_261058],_261026)),_261026=_261016),u_assign(['count->confidence',_261016],_259554)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['inc-confidence',Conf],['count->confidence',['inc-count',['confidence->count',Conf]]])
</span><span class="ansi38-255165000">  (= 
    (inc-confidence $Conf) 
    (count->confidence 
      (inc-count 
        (confidence->count $Conf))))
</span><span class="ansi38-000082136">  :- dynamic('inc-confidence',2).

  'inc-confidence'(Conf, A) :-
    ( u_assign(['confidence->count', Conf], B),
      B=C,
      u_assign(['inc-count', C], D)
    ),
    D=E,
    u_assign(['count->confidence', E], A).

</span>

;; Return the strength of a truth value, given that its count has been
;; incremented by one but its positive count has not.
;;
;; The formula is derived from new_s = s*cnt / (cnt + 1), where cnt is
;; the count of the original truth value, that is cnt = c*k / (1-c).
;; Thus
;;
;; new_s = (s*c*k / (1-c)) / (c*k / (1-c) + 1)
;;       = (s*c*k / (1-c)) / ((c*k + 1-c) / (1-c))
;;       = (s*c*k) / (c*k + 1-c)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'inc-count-strength',[->,'Number','Number','Number']])
</span><span class="ansi38-255165000">  (: inc-count-strength 
    (-> Number Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'inc-count-strength'(S,C,Assign_C) :-
%~                              [lookahead,_124544] ,
%~                              _124544=_124552 ,
%~                              u_assign([*,C,_124552],Assign) ,
%~                              Assign=_124582 ,
%~                              u_assign([*,S,_124582],Assign2) ,
%~                              Assign2=_124612 ,
%~                              [lookahead,_124664] ,
%~                              _124664=_124672 ,
%~                              u_assign([*,C,_124672],Assign3) ,
%~                              Assign3=_124702 ,
%~                              u_assign([+,_124702,1],Assign4) ,
%~                              Assign4=_124726 ,
%~                              u_assign([-,_124726,C],Assign5) ,
%~                              Assign5=_124750 ,
%~                              u_assign([/,_124612,_124750],Assign_C))]
%~ [convert(_4092),head_preconds_into_body(('inc-count-strength'(S,C,_4050):-(((((([lookahead,_4194],_4194=_4190),u_assign([*,C,_4190],_4162)),_4162=_4158),u_assign([*,S,_4158],_4130)),_4130=_4126),(((((([lookahead,_4334],_4334=_4330),u_assign([*,C,_4330],_4302)),_4302=_4298),u_assign([+,_4298,1],_4276)),_4276=_4272),u_assign([-,_4272,C],_4250)),_4250=_4246),u_assign([/,_4126,_4246],_4050)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['inc-count-strength',S,C],[/,[*,S,[*,C,[lookahead]]],[-,[+,[*,C,[lookahead]],1],C]])
</span><span class="ansi38-255165000">  (= 
    (inc-count-strength $S $C) 
    (/ 
      (* $S 
        (* $C 
          (lookahead))) 
      (- 
        (+ 
          (* $C 
            (lookahead)) 1) $C)))
</span><span class="ansi38-000082136">  :- dynamic('inc-count-strength',3).

  'inc-count-strength'(S, C, A) :-
    ( ( ( [lookahead, B],
          B=C
        ),
        u_assign([*, C, C], D),
        D=E
      ),
      u_assign([*, S, E], F),
      F=G
    ),
    ( ( ( [lookahead, H],
          H=I,
          u_assign([*, C, I], J)
        ),
        J=K,
        u_assign([+, K, 1], L)
      ),
      L=M,
      u_assign([-, M, C], N)
    ),
    N=O,
    u_assign([/, G, O], A).

</span>

;; Return the first order probability mode of the second order
;; distribution associated to a truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,mode,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">  (: mode 
    (-> TruthValue Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mode(_238568,1.0) :-
%~                              is_True(True) ,
%~                              u_assign(['Bl',True],Assign) ,
%~                              Assign=_234546)]
%~ [convert(_186676),head_preconds_into_body((mode(_185772,1.0):-(is_True(_185814),u_assign(['Bl',_185814],_185782)),_185782=_185772))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mode,['Bl','True']],1.0)
</span><span class="ansi38-255165000">  (= 
    (mode 
      (Bl True)) 1.0)
</span><span class="ansi38-000082136">  :- dynamic(mode,2).

  mode(A, 1.0) :-
    is_True(B),
    u_assign(['Bl', B], C),
    C=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mode(_314140,0.0) :-
%~                              u_assign(['Bl','False'],Assign) ,
%~                              Assign=_310196)]
%~ [convert(_270948),head_preconds_into_body((mode(_270038,0.0):-u_assign(['Bl','False'],_270048),_270048=_270038))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mode,['Bl','False']],0.0)
</span><span class="ansi38-255165000">  (= 
    (mode 
      (Bl False)) 0.0)
</span><span class="ansi38-000082136">  :- dynamic(mode,2).

  mode(A, 0.0) :-
    u_assign(['Bl', 'False'], B),
    B=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mode(Pr,Pr) :-
%~                              u_assign(['Pr',Pr],Assign) ,
%~                              Assign=Pr)]
%~ [convert(_348060),head_preconds_into_body((mode(_347106,Pr):-u_assign(['Pr',Pr],_347116),_347116=_347106))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mode,['Pr',Pr]],Pr)
</span><span class="ansi38-255165000">  (= 
    (mode 
      (Pr $Pr)) $Pr)
</span><span class="ansi38-000082136">  :- dynamic(mode,2).

  mode(A, Pr) :-
    u_assign(['Pr', Pr], B),
    B=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mode(Pr,Pr) :-
%~                              u_assign(['PrCnt',Pr,_],Assign) ,
%~                              Assign=Pr)]
%~ [convert(_418824),head_preconds_into_body((mode(_417800,Pr):-u_assign(['PrCnt',Pr,_],_417810),_417810=_417800))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mode,['PrCnt',Pr,_]],Pr)
</span><span class="ansi38-255165000">  (= 
    (mode 
      (PrCnt $Pr $_)) $Pr)
</span><span class="ansi38-000082136">  :- dynamic(mode,2).

  mode(A, Pr) :-
    u_assign(['PrCnt', Pr, _], B),
    B=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mode(Pr,Pr) :-
%~                              u_assign(['STV',Pr,_],Assign) ,
%~                              Assign=Pr)]
%~ [convert(_4012),head_preconds_into_body((mode(_3956,Pr):-u_assign(['STV',Pr,_],_3960),_3960=_3956))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mode,['STV',Pr,_]],Pr)
</span><span class="ansi38-255165000">  (= 
    (mode 
      (STV $Pr $_)) $Pr)
</span><span class="ansi38-000082136">  :- dynamic(mode,2).

  mode(A, Pr) :-
    u_assign(['STV', Pr, _], B),
    B=A.

</span>

;; Return the total count of a truth value.  For truth values not
;; capturing a notion of confidence, such as Bl or Pr then the count
;; is assumed to be a very large number (cause +inf does not seem to
;; be supported at the moment).  For truth values capturing a notion
;; of confidence, such as PrCnt, the total count is the count
;; component of the truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,count,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">  (: count 
    (-> TruthValue Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( count(Count,Count1) :-
%~                              u_assign(['Bl',_],Assign) ,
%~                              Assign=Count ,
%~                              ['max-count',Count1])]
%~ [convert(_64488),head_preconds_into_body((count(_63534,_63254):-(u_assign(['Bl',_],_63544),_63544=_63534),['max-count',_63254]))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[count,['Bl',_]],['max-count'])
</span><span class="ansi38-255165000">  (= 
    (count 
      (Bl $_)) 
    (max-count))
</span><span class="ansi38-000082136">  :- dynamic(count,2).

  count(A, B) :-
    u_assign(['Bl', _], C),
    C=A,
    ['max-count', B].

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( count(Count,Count1) :-
%~                              u_assign(['Pr',_],Assign) ,
%~                              Assign=Count ,
%~                              ['max-count',Count1])]
%~ [convert(_143642),head_preconds_into_body((count(_142688,_142408):-(u_assign(['Pr',_],_142698),_142698=_142688),['max-count',_142408]))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[count,['Pr',_]],['max-count'])
</span><span class="ansi38-255165000">  (= 
    (count 
      (Pr $_)) 
    (max-count))
</span><span class="ansi38-000082136">  :- dynamic(count,2).

  count(A, B) :-
    u_assign(['Pr', _], C),
    C=A,
    ['max-count', B].

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( count(Cnt,Cnt) :-
%~                              u_assign(['PrCnt',_,Cnt],Assign) ,
%~                              Assign=Cnt)]
%~ [convert(_223282),head_preconds_into_body((count(_222258,Cnt):-u_assign(['PrCnt',_,Cnt],_222268),_222268=_222258))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[count,['PrCnt',_,Cnt]],Cnt)
</span><span class="ansi38-255165000">  (= 
    (count 
      (PrCnt $_ $Cnt)) $Cnt)
</span><span class="ansi38-000082136">  :- dynamic(count,2).

  count(A, Cnt) :-
    u_assign(['PrCnt', _, Cnt], B),
    B=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( count(Count,Assign_Count1) :-
%~                              u_assign(['STV',_,Conf],Assign) ,
%~                              Assign=Count ,
%~                              u_assign(['confidence->count',Conf],Assign_Count1))]
%~ [convert(_296670),head_preconds_into_body((count(_295646,_295366):-(u_assign(['STV',_,Conf],_295656),_295656=_295646),u_assign(['confidence->count',Conf],_295366)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[count,['STV',_,Conf]],['confidence->count',Conf])
</span><span class="ansi38-255165000">  (= 
    (count 
      (STV $_ $Conf)) 
    (confidence->count $Conf))
</span><span class="ansi38-000082136">  :- dynamic(count,2).

  count(A, B) :-
    u_assign(['STV', _, Conf], C),
    C=A,
    u_assign(['confidence->count', Conf], B).

</span>

;; Return the confidence of a truth value.  For truth values not
;; capturing a notion of confidence, such as Bl or Pr then the
;; confidence is assumed to be 1.0.  For truth values capturing a
;; notion of confidence, such as PrCnt, the formula to convert a count
;; into confidence is as follows
;;
;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,confidence,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">  (: confidence 
    (-> TruthValue Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( confidence(_429216,1.0) :-
%~                              u_assign(['Bl',_],Assign) ,
%~                              Assign=_425272)]
%~ [convert(_384342),head_preconds_into_body((confidence(_383388,1.0):-u_assign(['Bl',_],_383398),_383398=_383388))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[confidence,['Bl',_]],1.0)
</span><span class="ansi38-255165000">  (= 
    (confidence 
      (Bl $_)) 1.0)
</span><span class="ansi38-000082136">  :- dynamic(confidence,2).

  confidence(A, 1.0) :-
    u_assign(['Bl', _], B),
    B=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( confidence(_500698,1.0) :-
%~                              u_assign(['Pr',_],Assign) ,
%~                              Assign=_496754)]
%~ [convert(_455824),head_preconds_into_body((confidence(_454870,1.0):-u_assign(['Pr',_],_454880),_454880=_454870))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[confidence,['Pr',_]],1.0)
</span><span class="ansi38-255165000">  (= 
    (confidence 
      (Pr $_)) 1.0)
</span><span class="ansi38-000082136">  :- dynamic(confidence,2).

  confidence(A, 1.0) :-
    u_assign(['Pr', _], B),
    B=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( confidence(Confidence,Assign_Confidence1) :-
%~                              u_assign(['PrCnt',_,Cnt],Assign) ,
%~                              Assign=Confidence ,
%~                              u_assign(['count->confidence',Cnt],Assign_Confidence1))]
%~ [convert(_8986),head_preconds_into_body((confidence(_7962,_7682):-(u_assign(['PrCnt',_,Cnt],_7972),_7972=_7962),u_assign(['count->confidence',Cnt],_7682)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[confidence,['PrCnt',_,Cnt]],['count->confidence',Cnt])
</span><span class="ansi38-255165000">  (= 
    (confidence 
      (PrCnt $_ $Cnt)) 
    (count->confidence $Cnt))
</span><span class="ansi38-000082136">  :- dynamic(confidence,2).

  confidence(A, B) :-
    u_assign(['PrCnt', _, Cnt], C),
    C=A,
    u_assign(['count->confidence', Cnt], B).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( confidence(Conf,Conf) :-
%~                              u_assign(['STV',_,Conf],Assign) ,
%~                              Assign=Conf)]
%~ [convert(_84534),head_preconds_into_body((confidence(_83510,Conf):-u_assign(['STV',_,Conf],_83520),_83520=_83510))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[confidence,['STV',_,Conf]],Conf)
</span><span class="ansi38-255165000">  (= 
    (confidence 
      (STV $_ $Conf)) $Conf)
</span><span class="ansi38-000082136">  :- dynamic(confidence,2).

  confidence(A, Conf) :-
    u_assign(['STV', _, Conf], B),
    B=A.

</span>

;; Return the positive count of a truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,pos_count,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">  (: pos_count 
    (-> TruthValue Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( pos_count(Tv,Assign_Count_Tv) :-
%~                              u_assign([mode,Tv],Assign) ,
%~                              Assign=_243466 ,
%~                              u_assign([count,Tv],Assign3) ,
%~                              Assign3=_243484 ,
%~                              u_assign([*,_243466,_243484],Assign_Count_Tv))]
%~ [convert(_166402),head_preconds_into_body((pos_count(Tv,_165236):-((u_assign([mode,Tv],_166708),_166708=_166698),u_assign([count,Tv],_166842),_166842=_166832),u_assign([*,_166698,_166832],_165236)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[pos_count,Tv],[*,[mode,Tv],[count,Tv]])
</span><span class="ansi38-255165000">  (= 
    (pos_count $Tv) 
    (* 
      (mode $Tv) 
      (count $Tv)))
</span><span class="ansi38-000082136">  :- dynamic(pos_count,2).

  pos_count(Tv, A) :-
    ( u_assign([mode, Tv], B),
      B=C
    ),
    u_assign([count, Tv], D),
    D=E,
    u_assign([*, C, E], A).

</span>

;; Return the negative count of a truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,neg_count,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">  (: neg_count 
    (-> TruthValue Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( neg_count(Tv,Assign_Count_Tv) :-
%~                              u_assign([mode,Tv],Assign) ,
%~                              [-,1,Assign,_385724] ,
%~                              _385724=_385732 ,
%~                              u_assign([count,Tv],Assign3) ,
%~                              Assign3=_385750 ,
%~                              u_assign([*,_385732,_385750],Assign_Count_Tv))]
%~ [convert(_290864),head_preconds_into_body((neg_count(Tv,_289698):-(((u_assign([mode,Tv],_291230),[-,1,_291230,_291170]),_291170=_291160),u_assign([count,Tv],_291376),_291376=_291366),u_assign([*,_291160,_291366],_289698)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[neg_count,Tv],[*,[-,1,[mode,Tv]],[count,Tv]])
</span><span class="ansi38-255165000">  (= 
    (neg_count $Tv) 
    (* 
      (- 1 
        (mode $Tv)) 
      (count $Tv)))
</span><span class="ansi38-000082136">  :- dynamic(neg_count,2).

  neg_count(Tv, A) :-
    ( u_assign([mode, Tv], B),
      [-, 1, B, C],
      C=D
    ),
    u_assign([count, Tv], E),
    E=F,
    u_assign([*, D, F], A).

</span>

;; Return the posterior alpha of a truth value
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,post_alpha,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">  (: post_alpha 
    (-> TruthValue Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( post_alpha(Tv,Assign_Alpha_Tv) :-
%~                              [prior_alpha,_512590] ,
%~                              _512590=_512598 ,
%~                              u_assign([pos_count,Tv],Assign) ,
%~                              Assign=_512616 ,
%~                              u_assign([+,_512598,_512616],Assign_Alpha_Tv))]
%~ [convert(_430242),head_preconds_into_body((post_alpha(Tv,_429076):-(([prior_alpha,_431016],_431016=_431006),u_assign([pos_count,Tv],_431564),_431564=_431554),u_assign([+,_431006,_431554],_429076)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[post_alpha,Tv],[+,[prior_alpha],[pos_count,Tv]])
</span><span class="ansi38-255165000">  (= 
    (post_alpha $Tv) 
    (+ 
      (prior_alpha) 
      (pos_count $Tv)))
</span><span class="ansi38-000082136">  :- dynamic(post_alpha,2).

  post_alpha(Tv, A) :-
    ( [prior_alpha, B],
      B=C
    ),
    u_assign([pos_count, Tv], D),
    D=E,
    u_assign([+, C, E], A).

</span>

;; Return the posterior beta of a truth value
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,post_beta,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">  (: post_beta 
    (-> TruthValue Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( post_beta(Tv,Assign_Beta_Tv) :-
%~                              [prior_beta,_121260] ,
%~                              _121260=_121268 ,
%~                              u_assign([neg_count,Tv],Assign) ,
%~                              Assign=_121286 ,
%~                              u_assign([+,_121268,_121286],Assign_Beta_Tv))]
%~ [convert(_39584),head_preconds_into_body((post_beta(Tv,_38418):-(([prior_beta,_40358],_40358=_40348),u_assign([neg_count,Tv],_40906),_40906=_40896),u_assign([+,_40348,_40896],_38418)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[post_beta,Tv],[+,[prior_beta],[neg_count,Tv]])
</span><span class="ansi38-255165000">  (= 
    (post_beta $Tv) 
    (+ 
      (prior_beta) 
      (neg_count $Tv)))
</span><span class="ansi38-000082136">  :- dynamic(post_beta,2).

  post_beta(Tv, A) :-
    ( [prior_beta, B],
      B=C
    ),
    u_assign([neg_count, Tv], D),
    D=E,
    u_assign([+, C, E], A).

</span>

;; Return the first order probability mean of the second order
;; distribution associated to a truth value.  For truth values not
;; capturing a notion of confidence, such as Bl or Pr then the
;; confidence is assumed to be 1.0.  For truth values capturing a
;; notion of confidence, such as PrCnt, a beta distribution is
;; assumed.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,mean,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">  (: mean 
    (-> TruthValue Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mean(_206252,1.0) :-
%~                              is_True(True) ,
%~                              u_assign(['Bl',True],Assign) ,
%~                              Assign=_202230)]
%~ [convert(_154972),head_preconds_into_body((mean(_154068,1.0):-(is_True(_154110),u_assign(['Bl',_154110],_154078)),_154078=_154068))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mean,['Bl','True']],1.0)
</span><span class="ansi38-255165000">  (= 
    (mean 
      (Bl True)) 1.0)
</span><span class="ansi38-000082136">  :- dynamic(mean,2).

  mean(A, 1.0) :-
    is_True(B),
    u_assign(['Bl', B], C),
    C=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mean(_268996,0.0) :-
%~                              u_assign(['Bl','False'],Assign) ,
%~                              Assign=_265052)]
%~ [convert(_225804),head_preconds_into_body((mean(_224894,0.0):-u_assign(['Bl','False'],_224904),_224904=_224894))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mean,['Bl','False']],0.0)
</span><span class="ansi38-255165000">  (= 
    (mean 
      (Bl False)) 0.0)
</span><span class="ansi38-000082136">  :- dynamic(mean,2).

  mean(A, 0.0) :-
    u_assign(['Bl', 'False'], B),
    B=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mean(Pr,Pr) :-
%~                              u_assign(['Pr',Pr],Assign) ,
%~                              Assign=Pr)]
%~ [convert(_290088),head_preconds_into_body((mean(_289134,Pr):-u_assign(['Pr',Pr],_289144),_289144=_289134))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mean,['Pr',Pr]],Pr)
</span><span class="ansi38-255165000">  (= 
    (mean 
      (Pr $Pr)) $Pr)
</span><span class="ansi38-000082136">  :- dynamic(mean,2).

  mean(A, Pr) :-
    u_assign(['Pr', Pr], B),
    B=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mean(Mean,Assign_Mean1) :-
%~                              u_assign(['PrCnt',Pr,Cnt],Assign) ,
%~                              Assign=Mean ,
%~                              [ post_alpha,
%~                                ['PrCnt',Pr,Cnt]] =
%~                                A ,
%~                              [ post_beta,
%~                                ['PrCnt',Pr,Cnt]] =
%~                                B ,
%~                              u_assign([+,A,B],Assign3) ,
%~                              Assign3=_449026 ,
%~                              u_assign([/,A,_449026],Assign_Mean1))]
%~ [convert(_361014),head_preconds_into_body((mean(_359990,_359710):-(u_assign(['PrCnt',Pr,Cnt],_360000),_360000=_359990),([post_alpha,['PrCnt',Pr,Cnt]]=A,[post_beta,['PrCnt',Pr,Cnt]]=B),(u_assign([+,A,B],_363636),_363636=_363626),u_assign([/,A,_363626],_359710)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mean,['PrCnt',Pr,Cnt]],['let*',[[A,[post_alpha,['PrCnt',Pr,Cnt]]],[B,[post_beta,['PrCnt',Pr,Cnt]]]],[/,A,[+,A,B]]])
</span><span class="ansi38-255165000">  (= 
    (mean 
      (PrCnt $Pr $Cnt)) 
    (let* 
      ( ($A 
          (post_alpha 
            (PrCnt $Pr $Cnt))) 
        ($B 
          (post_beta 
            (PrCnt $Pr $Cnt)))) 
      (/ $A 
        (+ $A $B))))
</span><span class="ansi38-000082136">  :- dynamic(mean,2).

  mean(A, B) :-
    u_assign(['PrCnt', Pr, Cnt], C),
    C=A,
    [post_alpha, ['PrCnt', Pr, Cnt]]=A,
    [post_beta, ['PrCnt', Pr, Cnt]]=B,
    u_assign([+, A, B], D),
    D=E,
    u_assign([/, A, E], B).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mean(Mean,Assign_Mean1) :-
%~                              u_assign(['STV',Pr,Conf],Assign) ,
%~                              Assign=Mean ,
%~                              [ post_alpha,
%~                                ['STV',Pr,Conf]] =
%~                                A ,
%~                              [ post_beta,
%~                                ['STV',Pr,Conf]] =
%~                                B ,
%~                              u_assign([+,A,B],Assign3) ,
%~                              Assign3=_74378 ,
%~                              u_assign([/,A,_74378],Assign_Mean1))]
%~ [convert(_4210),head_preconds_into_body((mean(_4154,_4130):-(u_assign(['STV',Pr,Conf],_4158),_4158=_4154),([post_alpha,['STV',Pr,Conf]]=A,[post_beta,['STV',Pr,Conf]]=B),(u_assign([+,A,B],_4284),_4284=_4280),u_assign([/,A,_4280],_4130)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mean,['STV',Pr,Conf]],['let*',[[A,[post_alpha,['STV',Pr,Conf]]],[B,[post_beta,['STV',Pr,Conf]]]],[/,A,[+,A,B]]])
</span><span class="ansi38-255165000">  (= 
    (mean 
      (STV $Pr $Conf)) 
    (let* 
      ( ($A 
          (post_alpha 
            (STV $Pr $Conf))) 
        ($B 
          (post_beta 
            (STV $Pr $Conf)))) 
      (/ $A 
        (+ $A $B))))
</span><span class="ansi38-000082136">  :- dynamic(mean,2).

  mean(A, B) :-
    u_assign(['STV', Pr, Conf], C),
    C=A,
    [post_alpha, ['STV', Pr, Conf]]=A,
    [post_beta, ['STV', Pr, Conf]]=B,
    u_assign([+, A, B], D),
    D=E,
    u_assign([/, A, E], B).

</span>

; Evaluation took 4.03 seconds.
<span class="ansi33"> &self

</span><span class="ansi38-000068000">!(import! &self "../Num.metta")

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&self', '../Num.metta'], A).

</span>;; Collection of functions operating on numbers
;; Define max
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,max,[->,A,A,A]])
</span><span class="ansi38-255165000">  (: max 
    (-> $A $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( max(X,Y,Assign_Max_Y) :-
%~                              u_assign([>,X,Y],Assign) ,
%~                              Assign=_243930 ,
%~                              u_assign([if,_243930,X,Y],Assign_Max_Y))]
%~ [convert(_186200),head_preconds_into_body((max(X,Y,_184964):-(u_assign([>,X,Y],_186506),_186506=_186496),u_assign([if,_186496,X,Y],_184964)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[max,X,Y],[if,[>,X,Y],X,Y])
</span><span class="ansi38-255165000">  (= 
    (max $X $Y) 
    (if 
      (> $X $Y) $X $Y))
</span><span class="ansi38-000082136">  :- dynamic(max,3).

  max(X, Y, A) :-
    u_assign([>, X, Y], B),
    B=C,
    u_assign([if, C, X, Y], A).

</span>

;; Define min
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,min,[->,A,A,A]])
</span><span class="ansi38-255165000">  (: min 
    (-> $A $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( min(X,Y,Assign_Min_Y) :-
%~                              u_assign([<,X,Y],Assign) ,
%~                              Assign=_365626 ,
%~                              u_assign([if,_365626,X,Y],Assign_Min_Y))]
%~ [convert(_307896),head_preconds_into_body((min(X,Y,_306660):-(u_assign([<,X,Y],_308202),_308202=_308192),u_assign([if,_308192,X,Y],_306660)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[min,X,Y],[if,[<,X,Y],X,Y])
</span><span class="ansi38-255165000">  (= 
    (min $X $Y) 
    (if 
      (< $X $Y) $X $Y))
</span><span class="ansi38-000082136">  :- dynamic(min,3).

  min(X, Y, A) :-
    u_assign([<, X, Y], B),
    B=C,
    u_assign([if, C, X, Y], A).

</span>

;; Clamp a number to be within a certain range
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,clamp,[->,A,A,A,A]])
</span><span class="ansi38-255165000">  (: clamp 
    (-> $A $A $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( clamp(X,L,U,Assign_Clamp_U) :-
%~                              u_assign([min,U,X],Assign) ,
%~                              Assign=_488648 ,
%~                              u_assign([max,L,_488648],Assign_Clamp_U))]
%~ [convert(_428920),head_preconds_into_body((clamp(X,L,U,_427614):-(u_assign([min,U,X],_429282),_429282=_429272),u_assign([max,L,_429272],_427614)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[clamp,X,L,U],[max,L,[min,U,X]])
</span><span class="ansi38-255165000">  (= 
    (clamp $X $L $U) 
    (max $L 
      (min $U $X)))
</span><span class="ansi38-000082136">  :- dynamic(clamp,4).

  clamp(X, L, U, A) :-
    u_assign([min, U, X], B),
    B=C,
    u_assign([max, L, C], A).

</span>

;; Define abs
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,abs,[->,A,A]])
</span><span class="ansi38-255165000">  (: abs 
    (-> $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( abs(X,Assign_Abs_X) :-
%~                              u_assign([<,X,0],Assign) ,
%~                              Assign=_115252 ,
%~                              u_assign([*,-1,X],Assign3) ,
%~                              Assign3=_115270 ,
%~                              u_assign([if,_115252,_115270,X],Assign_Abs_X))]
%~ [convert(_29560),head_preconds_into_body((abs(X,_28394):-((u_assign([<,X,0],_29866),_29866=_29856),u_assign([*,-1,X],_30026),_30026=_30016),u_assign([if,_29856,_30016,X],_28394)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[abs,X],[if,[<,X,0],[*,-1,X],X])
</span><span class="ansi38-255165000">  (= 
    (abs $X) 
    (if 
      (< $X 0) 
      (* -1 $X) $X))
</span><span class="ansi38-000082136">
  abs(X, A) :-
    ( u_assign([<, X, 0], B),
      B=C
    ),
    u_assign([*, -1, X], D),
    D=E,
    u_assign([if, C, E, X], A).

</span>

;; Define <=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,<=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: <= 
    (-> $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( <=(X,Y,Assign_Y) :-
%~                              u_assign([<,X,Y],Assign) ,
%~                              Assign=_251182 ,
%~                              u_assign([==,X,Y],Assign2) ,
%~                              Assign2=_251200 ,
%~                              u_assign([or,_251182,_251200],Assign_Y))]
%~ [convert(_176146),head_preconds_into_body((<=(X,Y,_174910):-((u_assign([<,X,Y],_176452),_176452=_176442),u_assign([==,X,Y],_176656),_176656=_176646),u_assign([or,_176442,_176646],_174910)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[<=,X,Y],[or,[<,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">  (= 
    (<= $X $Y) 
    (or 
      (< $X $Y) 
      (== $X $Y)))
</span><span class="ansi38-000082136">  :- dynamic(<=,3).

  <=(X, Y, A) :-
    ( u_assign([<, X, Y], B),
      B=C
    ),
    u_assign([==, X, Y], D),
    D=E,
    u_assign([or, C, E], A).

</span>

;; Define >=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,>=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: >= 
    (-> $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( >=(X,Y,Assign_Y) :-
%~                              u_assign([>,X,Y],Assign) ,
%~                              Assign=_386356 ,
%~                              u_assign([==,X,Y],Assign2) ,
%~                              Assign2=_386374 ,
%~                              u_assign([or,_386356,_386374],Assign_Y))]
%~ [convert(_311320),head_preconds_into_body((>=(X,Y,_310084):-((u_assign([>,X,Y],_311626),_311626=_311616),u_assign([==,X,Y],_311830),_311830=_311820),u_assign([or,_311616,_311820],_310084)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[>=,X,Y],[or,[>,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">  (= 
    (>= $X $Y) 
    (or 
      (> $X $Y) 
      (== $X $Y)))
</span><span class="ansi38-000082136">  :- dynamic(>=,3).

  >=(X, Y, A) :-
    ( u_assign([>, X, Y], B),
      B=C
    ),
    u_assign([==, X, Y], D),
    D=E,
    u_assign([or, C, E], A).

</span>

;; Define approximately equal
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,approxEq,[->,A,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: approxEq 
    (-> $A $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( approxEq(X,Y,Epsilon,Assign_ApproxEq_Epsilon) :-
%~                              u_assign([-,X,Y],Assign) ,
%~                              Assign=_16964 ,
%~                              u_assign([abs,_16964],Assign3) ,
%~                              Assign3=_16988 ,
%~                              u_assign([<=,_16988,Epsilon],Assign_ApproxEq_Epsilon))]
%~ [convert(_4030),head_preconds_into_body((approxEq(X,Y,Epsilon,_3982):-(((u_assign([-,X,Y],_4094),_4094=_4090),u_assign([abs,_4090],_4068)),_4068=_4064),u_assign([<=,_4064,Epsilon],_3982)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[approxEq,X,Y,Epsilon],[<=,[abs,[-,X,Y]],Epsilon])
</span><span class="ansi38-255165000">  (= 
    (approxEq $X $Y $Epsilon) 
    (<= 
      (abs 
        (- $X $Y)) $Epsilon))
</span><span class="ansi38-000082136">  :- dynamic(approxEq,4).

  approxEq(X, Y, Epsilon, A) :-
    ( u_assign([-, X, Y], B),
      B=C,
      u_assign([abs, C], D)
    ),
    D=E,
    u_assign([<=, E, Epsilon], A).

</span>

;; Define Nat
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Nat','Type'])
</span><span class="ansi38-255165000">  (: Nat Type)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Z','Nat'])
</span><span class="ansi38-255165000">  (: Z Nat)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'S',[->,'Nat','Nat']])
</span><span class="ansi38-255165000">  (: S 
    (-> Nat Nat))
</span>

;; Define cast functions between Nat and Number
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNumber,[->,'Number','Nat']])
</span><span class="ansi38-255165000">  (: fromNumber 
    (-> Number Nat))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( fromNumber(N,N) :-
%~                              u_assign([<=,N,0],Assign) ,
%~                              Assign=_240770 ,
%~                              u_assign([-,N,1],Assign2) ,
%~                              Assign2=_240812 ,
%~                              u_assign([fromNumber,_240812],Assign3) ,
%~                              Assign3=_240836 ,
%~                              u_assign(['S',_240836],Assign4) ,
%~                              Assign4=_240860 ,
%~                              u_assign([if,_240770,'Z',_240860],N))]
%~ [convert(_118614),head_preconds_into_body((fromNumber(N,_117448):-((u_assign([<=,N,0],_118920),_118920=_118910),((((u_assign([-,N,1],_119176),_119176=_119166),u_assign([fromNumber,_119166],_119134)),_119134=_119124),u_assign(['S',_119124],_119092)),_119092=_119082),u_assign([if,_118910,'Z',_119082],_117448)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNumber,N],[if,[<=,N,0],'Z',['S',[fromNumber,[-,N,1]]]])
</span><span class="ansi38-255165000">  (= 
    (fromNumber $N) 
    (if 
      (<= $N 0) Z 
      (S 
        (fromNumber 
          (- $N 1)))))
</span><span class="ansi38-000082136">  :- dynamic(fromNumber,2).

  fromNumber(N, A) :-
    ( u_assign([<=, N, 0], B),
      B=C
    ),
    ( ( u_assign([-, N, 1], D),
        D=E,
        u_assign([fromNumber, E], F)
      ),
      F=G,
      u_assign(['S', G], H)
    ),
    H=I,
    u_assign([if, C, 'Z', I], A).

</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNat,[->,'Nat','Number']])
</span><span class="ansi38-255165000">  (: fromNat 
    (-> Nat Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((fromNat('Z',0):-true))]
%~ [convert(_287848),head_preconds_into_body((fromNat('Z',0):-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,'Z'],0)
</span><span class="ansi38-255165000">  (= 
    (fromNat Z) 0)
</span><span class="ansi38-000082136">  :- dynamic(fromNat,2).

  fromNat('Z', 0).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( fromNat(FromNat,FromNat1) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=FromNat ,
%~                              u_assign([fromNat,K],Assign3) ,
%~                              [+,1,Assign3,FromNat1])]
%~ [convert(_333004),head_preconds_into_body((fromNat(_332050,_331770):-(u_assign(['S',K],_332060),_332060=_332050),u_assign([fromNat,K],_333328),[+,1,_333328,_331770]))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,['S',K]],[+,1,[fromNat,K]])
</span><span class="ansi38-255165000">  (= 
    (fromNat 
      (S $K)) 
    (+ 1 
      (fromNat $K)))
</span><span class="ansi38-000082136">  :- dynamic(fromNat,2).

  fromNat(A, B) :-
    u_assign(['S', K], C),
    C=A,
    u_assign([fromNat, K], D),
    [+, 1, D, B].

</span>

;; Define a generic less than operator, â©», for Nat.  < cannot be used
;; because it is a built-in, its type is hardwired and cannot be
;; overloaded.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Nat','Nat','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Nat Nat Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('â©»'(_,'Z',_431746):-_431746='False'))]
%~ [convert(_432938),head_preconds_into_body(('â©»'(_,'Z',_431746):-_431746='False'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',_,'Z'],'False')
</span><span class="ansi38-255165000">  (= 
    (â©» $_ Z) False)
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(_, 'Z', A) :-
    A='False'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'('Z',Z,True) :-
%~                              u_assign(['S',_],Assign) ,
%~                              Assign=Z ,
%~                              True='True')]
%~ [convert(_4024),head_preconds_into_body(('â©»'('Z',_3974,_3944):-(u_assign(['S',_],_3978),_3978=_3974),_3944='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»','Z',['S',_]],'True')
</span><span class="ansi38-255165000">  (= 
    (â©» Z 
      (S $_)) True)
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'('Z', A, B) :-
    u_assign(['S', _], C),
    C=A,
    B='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'(Â1,Â,Assign_Â2) :-
%~                              u_assign(['S',X],Assign) ,
%~                              Assign=Â1 ,
%~                              u_assign(['S',Y],Assign4) ,
%~                              Assign4=Â ,
%~                              u_assign(['â©»',X,Y],Assign_Â2))]
%~ [convert(_32564),head_preconds_into_body(('â©»'(_31448,_31582,_31168):-((u_assign(['S',X],_31458),_31458=_31448),u_assign(['S',Y],_31592),_31592=_31582),u_assign(['â©»',X,Y],_31168)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',['S',X],['S',Y]],['â©»',X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» 
      (S $X) 
      (S $Y)) 
    (â©» $X $Y))
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(A, B, C) :-
    ( u_assign(['S', X], D),
      D=A
    ),
    u_assign(['S', Y], E),
    E=B,
    u_assign(['â©»', X, Y], C).

</span>

;; Overload â©» for Number.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Number','Number','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Number Number Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'(X,Y,Assign_Â_Y) :-
%~                              u_assign([<,X,Y],Assign_Â_Y))]
%~ [convert(_130264),head_preconds_into_body(('â©»'(X,Y,_129028):-u_assign([<,X,Y],_129028)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',X,Y],[<,X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» $X $Y) 
    (< $X $Y))
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(X, Y, A) :-
    u_assign([<, X, Y], A).

</span>

;; Return the ceiling of a non negative number.  If the number is
;; negative it returns 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,ceil,[->,'Number','Number']])
</span><span class="ansi38-255165000">  (: ceil 
    (-> Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ceil(N,Assign_Ceil_N) :-
%~                              u_assign([fromNumber,N],Assign) ,
%~                              Assign=_261722 ,
%~                              u_assign([fromNat,_261722],Assign_Ceil_N))]
%~ [convert(_206020),head_preconds_into_body((ceil(N,_204854):-(u_assign([fromNumber,N],_206326),_206326=_206316),u_assign([fromNat,_206316],_204854)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[ceil,N],[fromNat,[fromNumber,N]])
</span><span class="ansi38-255165000">  (= 
    (ceil $N) 
    (fromNat 
      (fromNumber $N)))
</span><span class="ansi38-000082136">  :- dynamic(ceil,2).

  ceil(N, A) :-
    u_assign([fromNumber, N], B),
    B=C,
    u_assign([fromNat, C], A).

</span>

;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'number->bool',[->,'Number','Bool']])
</span><span class="ansi38-255165000">  (: number->bool 
    (-> Number Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'number->bool'(X,Number_c62_bool_X) :-
%~                              u_assign([<,0,X],Number_c62_bool_X))]
%~ [convert(_303018),head_preconds_into_body(('number->bool'(X,_301852):-u_assign([<,0,X],_301852)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['number->bool',X],[<,0,X])
</span><span class="ansi38-255165000">  (= 
    (number->bool $X) 
    (< 0 $X))
</span><span class="ansi38-000082136">  :- dynamic('number->bool',2).

  'number->bool'(X, A) :-
    u_assign([<, 0, X], A).

</span>

;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'bool->number',[->,'Bool','Number']])
</span><span class="ansi38-255165000">  (: bool->number 
    (-> Bool Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('bool->number'('False',0):-true))]
%~ [convert(_373506),head_preconds_into_body(('bool->number'('False',0):-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','False'],0)
</span><span class="ansi38-255165000">  (= 
    (bool->number False) 0)
</span><span class="ansi38-000082136">  :- dynamic('bool->number',2).

  'bool->number'('False', 0).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('bool->number'(_410078,1):-is_True(_410078)))]
%~ [convert(_410914),head_preconds_into_body(('bool->number'(_410078,1):-is_True(_410078)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','True'],1)
</span><span class="ansi38-255165000">  (= 
    (bool->number True) 1)
</span><span class="ansi38-000082136">  :- dynamic('bool->number',2).

  'bool->number'(A, 1) :-
    is_True(A).

</span>

;; Define a less than type.  Note that it is purposefully different
;; than â©» as it is a type, not an operator.  Inhabitants of (â x y)
;; are proofs that x â©» y == True.  For now â is only axiomatized for
;; Nat.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â\x8D\\x83\',[->,True,True,'Type']])
</span><span class="ansi38-255165000">  (: â 
    (-> $True $True Type))
</span>

;; Zero is always less than the successor of something
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['zero-lt-succ-axiom'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ['zero-lt-succ-axiom',Assign2] :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=_59730 ,
%~                              u_assign(['â\x8D\\x83\','Z',_59730],Assign1) ,
%~                              Assign1=_59760 ,
%~                              u_assign([:,'ZeroLTSucc',_59760],Assign2))]
%~ [convert(_4014),head_preconds_into_body((['zero-lt-succ-axiom',_3990]:-(((u_assign(['S',K],_4090),_4090=_4086),u_assign(['â\x8D\\x83\','Z',_4086],_4058)),_4058=_4054),u_assign([:,'ZeroLTSucc',_4054],_3990)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['zero-lt-succ-axiom'],[:,'ZeroLTSucc',['â\x8D\\x83\','Z',['S',K]]])
</span><span class="ansi38-255165000">  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (â Z 
        (S $K))))
</span><span class="ansi38-000082136">
  ['zero-lt-succ-axiom', A] :-
    ( u_assign(['S', K], B),
      B=C,
      u_assign(['â\u008D\u0083', 'Z', C], D)
    ),
    D=E,
    u_assign([:, 'ZeroLTSucc', E], A).

</span>

;; If x â y then (S x) â (S y)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['succ-monotonicity-rule'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ['succ-monotonicity-rule',Assign5] :-
%~                              u_assign(['â\x8D\\x83\',X,Y],Assign) ,
%~                              Assign=_260066 ,
%~                              u_assign(['S',X],Assign1) ,
%~                              Assign1=_260102 ,
%~                              u_assign(['S',Y],Assign2) ,
%~                              Assign2=_260120 ,
%~                              u_assign(['â\x8D\\x83\',_260102,_260120],Assign3) ,
%~                              Assign3=_260150 ,
%~                              u_assign([->,_260066,_260150],Assign4) ,
%~                              Assign4=_260180 ,
%~                              u_assign([:,'SuccMonotonicity',_260180],Assign5))]
%~ [convert(_99370),head_preconds_into_body((['succ-monotonicity-rule',_97530]:-((((u_assign(['â\x8D\\x83\',X,Y],_99730),_99730=_99720),(((u_assign(['S',X],_99976),_99976=_99966),u_assign(['S',Y],_100110),_100110=_100100),u_assign(['â\x8D\\x83\',_99966,_100100],_99934)),_99934=_99924),u_assign([->,_99720,_99924],_99688)),_99688=_99678),u_assign([:,'SuccMonotonicity',_99678],_97530)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['succ-monotonicity-rule'],[:,'SuccMonotonicity',[->,['â\x8D\\x83\',X,Y],['â\x8D\\x83\',['S',X],['S',Y]]]])
</span><span class="ansi38-255165000">  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (â $X $Y) 
        (â 
          (S $X) 
          (S $Y)))))
</span><span class="ansi38-000082136">
  ['succ-monotonicity-rule', A] :-
    ( ( u_assign(['â\u008D\u0083', X, Y], B),
        B=C
      ),
      ( ( u_assign(['S', X], D),
          D=E
        ),
        u_assign(['S', Y], F),
        F=G,
        u_assign(['â\u008D\u0083', E, G], H)
      ),
      H=I,
      u_assign([->, C, I], J)
    ),
    J=K,
    u_assign([:, 'SuccMonotonicity', K], A).

</span>

; Evaluation took 1457.79 ms.
<span class="ansi33"> &self

</span>%~ [ convert(Convert),
%~   head_preconds_into_body( 'modus-ponens-formula'(Modus_ponens_formula1,Modus_ponens_formula,Modus_ponens_formula2) :-
%~                              u_assign(['STV',As,Ac],Assign) ,
%~                              Assign=Modus_ponens_formula1 ,
%~                              u_assign(['STV',ABs,ABc],Assign4) ,
%~                              Assign4=Modus_ponens_formula ,
%~                              0.2=NotABs ,
%~                              1=NotABc ,
%~                              u_assign([*,ABs,As],Assign5) ,
%~                              Assign5=_8588 ,
%~                              u_assign([-,1,As],Assign6) ,
%~                              Assign6=_8618 ,
%~                              u_assign([*,NotABs,_8618],Assign7) ,
%~                              Assign7=_8648 ,
%~                              u_assign([+,_8588,_8648],Assign8) ,
%~                              Assign8=_8678 ,
%~                              u_assign([min,ABc,NotABc],Assign9) ,
%~                              Assign9=_8708 ,
%~                              u_assign([min,_8708,Ac],Assign10) ,
%~                              Assign10=_8732 ,
%~                              u_assign(['STV',_8678,_8732],Modus_ponens_formula2))]
%~ [convert(_3856),head_preconds_into_body(('modus-ponens-formula'(_3744,_3794,_3720):-((u_assign(['STV',As,Ac],_3748),_3748=_3744),u_assign(['STV',ABs,ABc],_3798),_3798=_3794),(0.2=NotABs,1=NotABc),(((((u_assign([*,ABs,As],_3950),_3950=_3946),((u_assign([-,1,As],_4032),_4032=_4028),u_assign([*,NotABs,_4028],_4000)),_4000=_3996),u_assign([+,_3946,_3996],_3924)),_3924=_3920),((u_assign([min,ABc,NotABc],_4138),_4138=_4134),u_assign([min,_4134,Ac],_4112)),_4112=_4108),u_assign(['STV',_3920,_4108],_3720)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['modus-ponens-formula',['STV',As,Ac],['STV',ABs,ABc]],['let*',[[NotABs,0.2],[NotABc,1]],['STV',[+,[*,ABs,As],[*,NotABs,[-,1,As]]],[min,[min,ABc,NotABc],Ac]]])
</span><span class="ansi38-255165000">  (= 
    (modus-ponens-formula 
      (STV $As $Ac) 
      (STV $ABs $ABc)) 
    (let* 
      ( ($NotABs 0.2) 
        ($NotABc 1)) 
      (STV 
        (+ 
          (* $ABs $As) 
          (* $NotABs 
            (- 1 $As))) 
        (min 
          (min $ABc $NotABc) $Ac))))
</span><span class="ansi38-000082136">  :- dynamic('modus-ponens-formula',3).

  'modus-ponens-formula'(A, B, C) :-
    ( u_assign(['STV', As, Ac], D),
      D=A
    ),
    u_assign(['STV', ABs, ABc], E),
    E=B,
    0.2=NotABs,
    1=NotABc,
    ( ( u_assign([*, ABs, As], F),
        F=G,
        ( u_assign([-, 1, As], H),
          H=I
        ),
        u_assign([*, NotABs, I], J),
        J=K
      ),
      u_assign([+, G, K], L),
      L=M
    ),
    ( u_assign([min, ABc, NotABc], N),
      N=O,
      u_assign([min, O, Ac], P)
    ),
    P=Q,
    u_assign(['STV', M, Q], C).

</span>

; Evaluation took 5.81 seconds.
<span class="ansi33"> &self

</span>; temporary hack
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'modus-ponens-rule',[->,'Atom']])
</span><span class="ansi38-255165000">  (: modus-ponens-rule 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ['modus-ponens-rule',Assign6] :-
%~                              u_assign(['â\x89\\x9E\',A,Atv],Assign) ,
%~                              Assign=_264142 ,
%~                              u_assign(['â\x86\\x92\',A,B],Assign1) ,
%~                              Assign1=_264178 ,
%~                              u_assign(['â\x89\\x9E\',_264178,Abtv],Assign2) ,
%~                              Assign2=_264202 ,
%~                              u_assign(['modus-ponens-formula',Atv,Abtv],Assign3) ,
%~                              Assign3=_264232 ,
%~                              u_assign(['â\x89\\x9E\',B,_264232],Assign4) ,
%~                              Assign4=_264262 ,
%~                              u_assign([->,_264142,_264202,_264262],Assign5) ,
%~                              Assign5=_264298 ,
%~                              u_assign([:,'ModusPonens',_264298],Assign6))]
%~ [convert(_60026),head_preconds_into_body((['modus-ponens-rule',_58186]:-((((u_assign(['â\x89\\x9E\',A,Atv],_60386),_60386=_60376),(((u_assign(['â\x86\\x92\',A,B],_60632),_60632=_60622),u_assign(['â\x89\\x9E\',_60622,Abtv],_60590)),_60590=_60580),((u_assign(['modus-ponens-formula',Atv,Abtv],_61054),_61054=_61044),u_assign(['â\x89\\x9E\',B,_61044],_60956)),_60956=_60946),u_assign([->,_60376,_60580,_60946],_60344)),_60344=_60334),u_assign([:,'ModusPonens',_60334],_58186)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['modus-ponens-rule'],[:,'ModusPonens',[->,['â\x89\\x9E\',A,Atv],['â\x89\\x9E\',['â\x86\\x92\',A,B],Abtv],['â\x89\\x9E\',B,['modus-ponens-formula',Atv,Abtv]]]])
</span><span class="ansi38-255165000">  (= 
    (modus-ponens-rule) 
    (: ModusPonens 
      (-> 
        (â $A $Atv) 
        (â 
          (â $A $B) $Abtv) 
        (â $B 
          (modus-ponens-formula $Atv $Abtv)))))
</span><span class="ansi38-000082136">
  ['modus-ponens-rule', A] :-
    ( ( u_assign(['â\u0089\u009E', A, Atv], B),
        B=C
      ),
      ( ( u_assign(['â\u0086\u0092', A, B], D),
          D=E
        ),
        u_assign(['â\u0089\u009E', E, Abtv], F),
        F=G
      ),
      ( u_assign(['modus-ponens-formula', Atv, Abtv], H),
        H=I,
        u_assign(['â\u0089\u009E', B, I], J)
      ),
      J=K,
      u_assign([->, C, G, K], L)
    ),
    L=M,
    u_assign([:, 'ModusPonens', M], A).

</span>

; Evaluation took 6.07 seconds.
<span class="ansi33"> &self

</span><span class="ansi38-000068000">!(import! &self "../synthesis/Synthesize.metta")

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&self', '../synthesis/Synthesize.metta'], A).

</span>;; Puzzle:
;; The cow is big.
;; The cow needs the dog.
;; The dog sees the rabbit.
;; The rabbit chases the cow.
;; The rabbit chases the dog.
;; The rabbit is big.
;; The rabbit sees the dog.
;; If the cow chases the dog then the cow sees the rabbit.
;; If something is big then it chases the dog.
;; Question:
;; The cow sees the rabbit?
;; Knowledge base
;; Import modules
<span class="ansi38-000068000">!(import! &self "../common/Num.metta")

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&self', '../common/Num.metta'], A).

</span>;; !(import! &self Unify.metta)
;; Enumerate all programs up to a given depth that are consistent with
;; the query, using the given axiom non-deterministic functions and rules.
;;
;; The arguments are:
;;
;; $query: an Atom under the form (: TERM TYPE).  The atom may contain
;;         free variables within TERM and TYPE to form various sort of
;;         queries, such as:
;;         1. Backward chaining: (: $term (Inheritance $x Mammal))
;;         2. Forward chaining: (: ($rule $premise AXIOM) $type)
;;         3. Mixed chaining: (: ($rule $premise AXIOM) (Inheritance $x Mammal))
;;         4. Type checking: (: TERM TYPE)
;;         5. Type inference: (: TERM $type)
;;
;; $axiom: a nullary function to axiom, to non-deterministically pick
;;         up an axiom.  An axiom is an Atom of the form
;;         (: TERM TYPE).
;;
;; $rule: a nullary function to rule, to non-deterministically pick up
;;        a rule.  A rule is a function mapping premises to
;;        conclusion, where premises and conclusion have the form
;;        (: TERM TYPE).
;;
;; $depth: a Nat representing the maximum depth of the generated
;;         programs.
;;
;; TODO: recurse over curried rules instead of duplicating code over
;; tuples.
;; Collection of functions operating on numbers
;; Define max
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,max,[->,A,A,A]])
</span><span class="ansi38-255165000">  (: max 
    (-> $A $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( max(X,Y,Assign_Max_Y) :-
%~                              u_assign([>,X,Y],Assign) ,
%~                              Assign=_7096 ,
%~                              u_assign([if,_7096,X,Y],Assign_Max_Y))]
%~ [convert(_3604),head_preconds_into_body((max(X,Y,_3562):-(u_assign([>,X,Y],_3642),_3642=_3638),u_assign([if,_3638,X,Y],_3562)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[max,X,Y],[if,[>,X,Y],X,Y])
</span><span class="ansi38-255165000">  (= 
    (max $X $Y) 
    (if 
      (> $X $Y) $X $Y))
</span><span class="ansi38-000082136">  :- dynamic(max,3).

  max(X, Y, A) :-
    u_assign([>, X, Y], B),
    B=C,
    u_assign([if, C, X, Y], A).

</span>

;; Define min
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,min,[->,A,A,A]])
</span><span class="ansi38-255165000">  (: min 
    (-> $A $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( min(X,Y,Assign_Min_Y) :-
%~                              u_assign([<,X,Y],Assign) ,
%~                              Assign=_127888 ,
%~                              u_assign([if,_127888,X,Y],Assign_Min_Y))]
%~ [convert(_69546),head_preconds_into_body((min(X,Y,_68310):-(u_assign([<,X,Y],_69852),_69852=_69842),u_assign([if,_69842,X,Y],_68310)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[min,X,Y],[if,[<,X,Y],X,Y])
</span><span class="ansi38-255165000">  (= 
    (min $X $Y) 
    (if 
      (< $X $Y) $X $Y))
</span><span class="ansi38-000082136">  :- dynamic(min,3).

  min(X, Y, A) :-
    u_assign([<, X, Y], B),
    B=C,
    u_assign([if, C, X, Y], A).

</span>

;; Clamp a number to be within a certain range
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,clamp,[->,A,A,A,A]])
</span><span class="ansi38-255165000">  (: clamp 
    (-> $A $A $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( clamp(X,L,U,Assign_Clamp_U) :-
%~                              u_assign([min,U,X],Assign) ,
%~                              Assign=_250908 ,
%~                              u_assign([max,L,_250908],Assign_Clamp_U))]
%~ [convert(_191180),head_preconds_into_body((clamp(X,L,U,_189874):-(u_assign([min,U,X],_191542),_191542=_191532),u_assign([max,L,_191532],_189874)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[clamp,X,L,U],[max,L,[min,U,X]])
</span><span class="ansi38-255165000">  (= 
    (clamp $X $L $U) 
    (max $L 
      (min $U $X)))
</span><span class="ansi38-000082136">  :- dynamic(clamp,4).

  clamp(X, L, U, A) :-
    u_assign([min, U, X], B),
    B=C,
    u_assign([max, L, C], A).

</span>

;; Define abs
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,abs,[->,A,A]])
</span><span class="ansi38-255165000">  (: abs 
    (-> $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( abs(X,Assign_Abs_X) :-
%~                              u_assign([<,X,0],Assign) ,
%~                              Assign=_396958 ,
%~                              u_assign([*,-1,X],Assign3) ,
%~                              Assign3=_396976 ,
%~                              u_assign([if,_396958,_396976,X],Assign_Abs_X))]
%~ [convert(_310654),head_preconds_into_body((abs(X,_309488):-((u_assign([<,X,0],_310960),_310960=_310950),u_assign([*,-1,X],_311120),_311120=_311110),u_assign([if,_310950,_311110,X],_309488)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[abs,X],[if,[<,X,0],[*,-1,X],X])
</span><span class="ansi38-255165000">  (= 
    (abs $X) 
    (if 
      (< $X 0) 
      (* -1 $X) $X))
</span><span class="ansi38-000082136">
  abs(X, A) :-
    ( u_assign([<, X, 0], B),
      B=C
    ),
    u_assign([*, -1, X], D),
    D=E,
    u_assign([if, C, E, X], A).

</span>

;; Define <=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,<=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: <= 
    (-> $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( <=(X,Y,Assign_Y) :-
%~                              u_assign([<,X,Y],Assign) ,
%~                              Assign=_16568 ,
%~                              u_assign([==,X,Y],Assign2) ,
%~                              Assign2=_16586 ,
%~                              u_assign([or,_16568,_16586],Assign_Y))]
%~ [convert(_3592),head_preconds_into_body((<=(X,Y,_3550):-((u_assign([<,X,Y],_3630),_3630=_3626),u_assign([==,X,Y],_3680),_3680=_3676),u_assign([or,_3626,_3676],_3550)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[<=,X,Y],[or,[<,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">  (= 
    (<= $X $Y) 
    (or 
      (< $X $Y) 
      (== $X $Y)))
</span><span class="ansi38-000082136">  :- dynamic(<=,3).

  <=(X, Y, A) :-
    ( u_assign([<, X, Y], B),
      B=C
    ),
    u_assign([==, X, Y], D),
    D=E,
    u_assign([or, C, E], A).

</span>

;; Define >=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,>=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: >= 
    (-> $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( >=(X,Y,Assign_Y) :-
%~                              u_assign([>,X,Y],Assign) ,
%~                              Assign=_151734 ,
%~                              u_assign([==,X,Y],Assign2) ,
%~                              Assign2=_151752 ,
%~                              u_assign([or,_151734,_151752],Assign_Y))]
%~ [convert(_76698),head_preconds_into_body((>=(X,Y,_75462):-((u_assign([>,X,Y],_77004),_77004=_76994),u_assign([==,X,Y],_77208),_77208=_77198),u_assign([or,_76994,_77198],_75462)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[>=,X,Y],[or,[>,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">  (= 
    (>= $X $Y) 
    (or 
      (> $X $Y) 
      (== $X $Y)))
</span><span class="ansi38-000082136">  :- dynamic(>=,3).

  >=(X, Y, A) :-
    ( u_assign([>, X, Y], B),
      B=C
    ),
    u_assign([==, X, Y], D),
    D=E,
    u_assign([or, C, E], A).

</span>

;; Define approximately equal
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,approxEq,[->,A,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: approxEq 
    (-> $A $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( approxEq(X,Y,Epsilon,Assign_ApproxEq_Epsilon) :-
%~                              u_assign([-,X,Y],Assign) ,
%~                              Assign=_298710 ,
%~                              u_assign([abs,_298710],Assign3) ,
%~                              Assign3=_298734 ,
%~                              u_assign([<=,_298734,Epsilon],Assign_ApproxEq_Epsilon))]
%~ [convert(_211858),head_preconds_into_body((approxEq(X,Y,Epsilon,_210552):-(((u_assign([-,X,Y],_212206),_212206=_212196),u_assign([abs,_212196],_212164)),_212164=_212154),u_assign([<=,_212154,Epsilon],_210552)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[approxEq,X,Y,Epsilon],[<=,[abs,[-,X,Y]],Epsilon])
</span><span class="ansi38-255165000">  (= 
    (approxEq $X $Y $Epsilon) 
    (<= 
      (abs 
        (- $X $Y)) $Epsilon))
</span><span class="ansi38-000082136">  :- dynamic(approxEq,4).

  approxEq(X, Y, Epsilon, A) :-
    ( u_assign([-, X, Y], B),
      B=C,
      u_assign([abs, C], D)
    ),
    D=E,
    u_assign([<=, E, Epsilon], A).

</span>

;; Define Nat
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Nat','Type'])
</span><span class="ansi38-255165000">  (: Nat Type)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Z','Nat'])
</span><span class="ansi38-255165000">  (: Z Nat)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'S',[->,'Nat','Nat']])
</span><span class="ansi38-255165000">  (: S 
    (-> Nat Nat))
</span>

;; Define cast functions between Nat and Number
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNumber,[->,'Number','Nat']])
</span><span class="ansi38-255165000">  (: fromNumber 
    (-> Number Nat))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( fromNumber(N,N) :-
%~                              u_assign([<=,N,0],Assign) ,
%~                              Assign=_7464 ,
%~                              u_assign([-,N,1],Assign2) ,
%~                              Assign2=_7506 ,
%~                              u_assign([fromNumber,_7506],Assign3) ,
%~                              Assign3=_7530 ,
%~                              u_assign(['S',_7530],Assign4) ,
%~                              Assign4=_7554 ,
%~                              u_assign([if,_7464,'Z',_7554],N))]
%~ [convert(_3598),head_preconds_into_body((fromNumber(N,_3562):-((u_assign([<=,N,0],_3636),_3636=_3632),((((u_assign([-,N,1],_3744),_3744=_3740),u_assign([fromNumber,_3740],_3718)),_3718=_3714),u_assign(['S',_3714],_3692)),_3692=_3688),u_assign([if,_3632,'Z',_3688],_3562)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNumber,N],[if,[<=,N,0],'Z',['S',[fromNumber,[-,N,1]]]])
</span><span class="ansi38-255165000">  (= 
    (fromNumber $N) 
    (if 
      (<= $N 0) Z 
      (S 
        (fromNumber 
          (- $N 1)))))
</span><span class="ansi38-000082136">  :- dynamic(fromNumber,2).

  fromNumber(N, A) :-
    ( u_assign([<=, N, 0], B),
      B=C
    ),
    ( ( u_assign([-, N, 1], D),
        D=E,
        u_assign([fromNumber, E], F)
      ),
      F=G,
      u_assign(['S', G], H)
    ),
    H=I,
    u_assign([if, C, 'Z', I], A).

</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNat,[->,'Nat','Number']])
</span><span class="ansi38-255165000">  (: fromNat 
    (-> Nat Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((fromNat('Z',0):-true))]
%~ [convert(_53360),head_preconds_into_body((fromNat('Z',0):-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,'Z'],0)
</span><span class="ansi38-255165000">  (= 
    (fromNat Z) 0)
</span><span class="ansi38-000082136">  :- dynamic(fromNat,2).

  fromNat('Z', 0).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( fromNat(FromNat,FromNat1) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=FromNat ,
%~                              u_assign([fromNat,K],Assign3) ,
%~                              [+,1,Assign3,FromNat1])]
%~ [convert(_98516),head_preconds_into_body((fromNat(_97562,_97282):-(u_assign(['S',K],_97572),_97572=_97562),u_assign([fromNat,K],_98840),[+,1,_98840,_97282]))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,['S',K]],[+,1,[fromNat,K]])
</span><span class="ansi38-255165000">  (= 
    (fromNat 
      (S $K)) 
    (+ 1 
      (fromNat $K)))
</span><span class="ansi38-000082136">  :- dynamic(fromNat,2).

  fromNat(A, B) :-
    u_assign(['S', K], C),
    C=A,
    u_assign([fromNat, K], D),
    [+, 1, D, B].

</span>

;; Define a generic less than operator, â©», for Nat.  < cannot be used
;; because it is a built-in, its type is hardwired and cannot be
;; overloaded.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Nat','Nat','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Nat Nat Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('â©»'(_,'Z',_197256):-_197256='False'))]
%~ [convert(_198448),head_preconds_into_body(('â©»'(_,'Z',_197256):-_197256='False'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',_,'Z'],'False')
</span><span class="ansi38-255165000">  (= 
    (â©» $_ Z) False)
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(_, 'Z', A) :-
    A='False'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'('Z',Z,True) :-
%~                              u_assign(['S',_],Assign) ,
%~                              Assign=Z ,
%~                              True='True')]
%~ [convert(_244826),head_preconds_into_body(('â©»'('Z',_243858,_243566):-(u_assign(['S',_],_243868),_243868=_243858),_243566='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»','Z',['S',_]],'True')
</span><span class="ansi38-255165000">  (= 
    (â©» Z 
      (S $_)) True)
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'('Z', A, B) :-
    u_assign(['S', _], C),
    C=A,
    B='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'(Â1,Â,Assign_Â2) :-
%~                              u_assign(['S',X],Assign) ,
%~                              Assign=Â1 ,
%~                              u_assign(['S',Y],Assign4) ,
%~                              Assign4=Â ,
%~                              u_assign(['â©»',X,Y],Assign_Â2))]
%~ [convert(_315868),head_preconds_into_body(('â©»'(_314752,_314886,_314472):-((u_assign(['S',X],_314762),_314762=_314752),u_assign(['S',Y],_314896),_314896=_314886),u_assign(['â©»',X,Y],_314472)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',['S',X],['S',Y]],['â©»',X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» 
      (S $X) 
      (S $Y)) 
    (â©» $X $Y))
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(A, B, C) :-
    ( u_assign(['S', X], D),
      D=A
    ),
    u_assign(['S', Y], E),
    E=B,
    u_assign(['â©»', X, Y], C).

</span>

;; Overload â©» for Number.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Number','Number','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Number Number Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'(X,Y,Assign_Â_Y) :-
%~                              u_assign([<,X,Y],Assign_Â_Y))]
%~ [convert(_413570),head_preconds_into_body(('â©»'(X,Y,_412334):-u_assign([<,X,Y],_412334)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',X,Y],[<,X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» $X $Y) 
    (< $X $Y))
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(X, Y, A) :-
    u_assign([<, X, Y], A).

</span>

;; Return the ceiling of a non negative number.  If the number is
;; negative it returns 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,ceil,[->,'Number','Number']])
</span><span class="ansi38-255165000">  (: ceil 
    (-> Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ceil(N,Assign_Ceil_N) :-
%~                              u_assign([fromNumber,N],Assign) ,
%~                              Assign=_29216 ,
%~                              u_assign([fromNat,_29216],Assign_Ceil_N))]
%~ [convert(_3564),head_preconds_into_body((ceil(N,_3528):-(u_assign([fromNumber,N],_3602),_3602=_3598),u_assign([fromNat,_3598],_3528)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[ceil,N],[fromNat,[fromNumber,N]])
</span><span class="ansi38-255165000">  (= 
    (ceil $N) 
    (fromNat 
      (fromNumber $N)))
</span><span class="ansi38-000082136">  :- dynamic(ceil,2).

  ceil(N, A) :-
    u_assign([fromNumber, N], B),
    B=C,
    u_assign([fromNat, C], A).

</span>

;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'number->bool',[->,'Number','Bool']])
</span><span class="ansi38-255165000">  (: number->bool 
    (-> Number Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'number->bool'(X,Number_c62_bool_X) :-
%~                              u_assign([<,0,X],Number_c62_bool_X))]
%~ [convert(_70510),head_preconds_into_body(('number->bool'(X,_69344):-u_assign([<,0,X],_69344)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['number->bool',X],[<,0,X])
</span><span class="ansi38-255165000">  (= 
    (number->bool $X) 
    (< 0 $X))
</span><span class="ansi38-000082136">  :- dynamic('number->bool',2).

  'number->bool'(X, A) :-
    u_assign([<, 0, X], A).

</span>

;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'bool->number',[->,'Bool','Number']])
</span><span class="ansi38-255165000">  (: bool->number 
    (-> Bool Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('bool->number'('False',0):-true))]
%~ [convert(_140998),head_preconds_into_body(('bool->number'('False',0):-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','False'],0)
</span><span class="ansi38-255165000">  (= 
    (bool->number False) 0)
</span><span class="ansi38-000082136">  :- dynamic('bool->number',2).

  'bool->number'('False', 0).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('bool->number'(_177570,1):-is_True(_177570)))]
%~ [convert(_178406),head_preconds_into_body(('bool->number'(_177570,1):-is_True(_177570)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','True'],1)
</span><span class="ansi38-255165000">  (= 
    (bool->number True) 1)
</span><span class="ansi38-000082136">  :- dynamic('bool->number',2).

  'bool->number'(A, 1) :-
    is_True(A).

</span>

;; Define a less than type.  Note that it is purposefully different
;; than â©» as it is a type, not an operator.  Inhabitants of (â x y)
;; are proofs that x â©» y == True.  For now â is only axiomatized for
;; Nat.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â\x8D\\x83\',[->,True,True,'Type']])
</span><span class="ansi38-255165000">  (: â 
    (-> $True $True Type))
</span>

;; Zero is always less than the successor of something
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['zero-lt-succ-axiom'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ['zero-lt-succ-axiom',Assign2] :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=_342024 ,
%~                              u_assign(['â\x8D\\x83\','Z',_342024],Assign1) ,
%~                              Assign1=_342054 ,
%~                              u_assign([:,'ZeroLTSucc',_342054],Assign2))]
%~ [convert(_243038),head_preconds_into_body((['zero-lt-succ-axiom',_241198]:-(((u_assign(['S',K],_243410),_243410=_243400),u_assign(['â\x8D\\x83\','Z',_243400],_243356)),_243356=_243346),u_assign([:,'ZeroLTSucc',_243346],_241198)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['zero-lt-succ-axiom'],[:,'ZeroLTSucc',['â\x8D\\x83\','Z',['S',K]]])
</span><span class="ansi38-255165000">  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (â Z 
        (S $K))))
</span><span class="ansi38-000082136">
  ['zero-lt-succ-axiom', A] :-
    ( u_assign(['S', K], B),
      B=C,
      u_assign(['â\u008D\u0083', 'Z', C], D)
    ),
    D=E,
    u_assign([:, 'ZeroLTSucc', E], A).

</span>

;; If x â y then (S x) â (S y)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['succ-monotonicity-rule'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ['succ-monotonicity-rule',Assign5] :-
%~                              u_assign(['â\x8D\\x83\',X,Y],Assign) ,
%~                              Assign=_27232 ,
%~                              u_assign(['S',X],Assign1) ,
%~                              Assign1=_27268 ,
%~                              u_assign(['S',Y],Assign2) ,
%~                              Assign2=_27286 ,
%~                              u_assign(['â\x8D\\x83\',_27268,_27286],Assign3) ,
%~                              Assign3=_27316 ,
%~                              u_assign([->,_27232,_27316],Assign4) ,
%~                              Assign4=_27346 ,
%~                              u_assign([:,'SuccMonotonicity',_27346],Assign5))]
%~ [convert(_3608),head_preconds_into_body((['succ-monotonicity-rule',_3584]:-((((u_assign(['â\x8D\\x83\',X,Y],_3678),_3678=_3674),(((u_assign(['S',X],_3754),_3754=_3750),u_assign(['S',Y],_3798),_3798=_3794),u_assign(['â\x8D\\x83\',_3750,_3794],_3728)),_3728=_3724),u_assign([->,_3674,_3724],_3652)),_3652=_3648),u_assign([:,'SuccMonotonicity',_3648],_3584)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['succ-monotonicity-rule'],[:,'SuccMonotonicity',[->,['â\x8D\\x83\',X,Y],['â\x8D\\x83\',['S',X],['S',Y]]]])
</span><span class="ansi38-255165000">  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (â $X $Y) 
        (â 
          (S $X) 
          (S $Y)))))
</span><span class="ansi38-000082136">
  ['succ-monotonicity-rule', A] :-
    ( ( u_assign(['â\u008D\u0083', X, Y], B),
        B=C
      ),
      ( ( u_assign(['S', X], D),
          D=E
        ),
        u_assign(['S', Y], F),
        F=G,
        u_assign(['â\u008D\u0083', E, G], H)
      ),
      H=I,
      u_assign([->, C, I], J)
    ),
    J=K,
    u_assign([:, 'SuccMonotonicity', K], A).

</span>

; Evaluation took 1429.44 ms.
<span class="ansi33"> &self

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,synthesize,[->,'Atom',[->,'Atom'],[->,'Atom'],'Nat','Atom']])
</span><span class="ansi38-255165000">  (: synthesize 
    (-> Atom 
      (-> Atom) 
      (-> Atom) Nat Atom))
</span>

;; Nullary rule (axiom)
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Depth,Query) :-
%~                              u_assign([Axiom],VAR_Query) ,
%~                              Query=VAR_Query)]
%~ [convert(_102592),head_preconds_into_body((synthesize(Query,Axiom,Rule,Depth,Query):-u_assign([Axiom],_102896),Query=_102896))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,Depth],[let,Query,[Axiom],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule $Depth) 
    (let $Query 
      ($Axiom) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, Depth, Query) :-
    u_assign([Axiom], A),
    Query=A.

</span>

;; Unary rule
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Rule,Query) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=Rule ,
%~                              u_assign([->,Premise,Conclusion],Assign5) ,
%~                              Assign5=_348770 ,
%~                              u_assign([:,Ructor,_348770],Assign_List) ,
%~                              [Rule]=Assign_List ,
%~                              u_assign([Ructor,Proof],Assign7) ,
%~                              Assign7=_348836 ,
%~                              u_assign([:,_348836,Conclusion],VAR_Query) ,
%~                              Query=VAR_Query ,
%~                              u_assign([:,Proof,Premise],Assign_List3) ,
%~                              [ synthesize,
%~                                [:,Proof,Premise], Axiom,Rule,K] =
%~                                Assign_List3)]
%~ [convert(_201482),head_preconds_into_body((synthesize(Query,Axiom,Rule,_200486,Query):-(u_assign(['S',K],_200496),_200496=_200486),(((u_assign([->,Premise,Conclusion],_202682),_202682=_202672),u_assign([:,Ructor,_202672],_202066)),[Rule]=_202066),(((u_assign([Ructor,Proof],_203738),_203738=_203728),u_assign([:,_203728,Conclusion],_203178)),Query=_203178),u_assign([:,Proof,Premise],_204288),[synthesize,[:,Proof,Premise],Axiom,Rule,K]=_204288))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,['S',K]],['let*',[[[:,Ructor,[->,Premise,Conclusion]],[Rule]],[[:,[Ructor,Proof],Conclusion],Query],[[:,Proof,Premise],[synthesize,[:,Proof,Premise],Axiom,Rule,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise $Conclusion)) 
          ($Rule)) 
        ( (: 
            ($Ructor $Proof) $Conclusion) $Query) 
        ( (: $Proof $Premise) 
          (synthesize 
            (: $Proof $Premise) $Axiom $Rule $K))) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, A, Query) :-
    u_assign(['S', K], B),
    B=A,
    ( u_assign([->, Premise, Conclusion], C),
      C=D,
      u_assign([:, Ructor, D], E)
    ),
    [Rule]=E,
    ( u_assign([Ructor, Proof], F),
      F=G,
      u_assign([:, G, Conclusion], H)
    ),
    Query=H,
    u_assign([:, Proof, Premise], I),
    [synthesize, [:, Proof, Premise], Axiom, Rule, K]=I.

</span>

;; Binary rule
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Rule,Query) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=Rule ,
%~                              u_assign( [->,Premise1,Premise2,Conclusion],
%~                                Assign6) ,
%~                              Assign6=_98202 ,
%~                              u_assign([:,Ructor,_98202],Assign_List) ,
%~                              [Rule]=Assign_List ,
%~                              u_assign([Ructor,Proof1,Proof2],Assign8) ,
%~                              Assign8=_98268 ,
%~                              u_assign([:,_98268,Conclusion],VAR_Query) ,
%~                              Query=VAR_Query ,
%~                              u_assign([:,Proof1,Premise1],Assign_List3) ,
%~                              [ synthesize,
%~                                [:,Proof1,Premise1], Axiom,Rule,K] =
%~                                Assign_List3 ,
%~                              u_assign([:,Proof2,Premise2],Assign_List4) ,
%~                              [ synthesize,
%~                                [:,Proof2,Premise2], Axiom,Rule,K] =
%~                                Assign_List4)]
%~ [convert(_3558),head_preconds_into_body((synthesize(Query,Axiom,Rule,_3508,Query):-(u_assign(['S',K],_3512),_3512=_3508),(((u_assign([->,Premise1,Premise2,Conclusion],_3614),_3614=_3610),u_assign([:,Ructor,_3610],_3582)),[Rule]=_3582),(((u_assign([Ructor,Proof1,Proof2],_3700),_3700=_3696),u_assign([:,_3696,Conclusion],_3674)),Query=_3674),(u_assign([:,Proof1,Premise1],_3766),[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]=_3766),u_assign([:,Proof2,Premise2],_3808),[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]=_3808))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,['S',K]],['let*',[[[:,Ructor,[->,Premise1,Premise2,Conclusion]],[Rule]],[[:,[Ructor,Proof1,Proof2],Conclusion],Query],[[:,Proof1,Premise1],[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]],[[:,Proof2,Premise2],[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise1 $Premise2 $Conclusion)) 
          ($Rule)) 
        ( (: 
            ($Ructor $Proof1 $Proof2) $Conclusion) $Query) 
        ( (: $Proof1 $Premise1) 
          (synthesize 
            (: $Proof1 $Premise1) $Axiom $Rule $K)) 
        ( (: $Proof2 $Premise2) 
          (synthesize 
            (: $Proof2 $Premise2) $Axiom $Rule $K))) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, A, Query) :-
    u_assign(['S', K], B),
    B=A,
    ( u_assign([->, Premise1, Premise2, Conclusion], C),
      C=D,
      u_assign([:, Ructor, D], E)
    ),
    [Rule]=E,
    ( u_assign([Ructor, Proof1, Proof2], F),
      F=G,
      u_assign([:, G, Conclusion], H)
    ),
    Query=H,
    u_assign([:, Proof1, Premise1], I),
    [synthesize, [:, Proof1, Premise1], Axiom, Rule, K]=I,
    u_assign([:, Proof2, Premise2], J),
    [synthesize, [:, Proof2, Premise2], Axiom, Rule, K]=J.

</span>

;; Trinary rule
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Rule,Query) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=Rule ,
%~                              u_assign(
%~                                 [ ->, Premise1,Premise2,
%~                                   Premise3,Conclusion],
%~                                 Assign7) ,
%~                              Assign7=_424224 ,
%~                              u_assign([:,Ructor,_424224],Assign_List) ,
%~                              [Rule]=Assign_List ,
%~                              u_assign( [Ructor,Proof1,Proof2,Proof3],
%~                                Assign9) ,
%~                              Assign9=_424290 ,
%~                              u_assign([:,_424290,Conclusion],VAR_Query) ,
%~                              Query=VAR_Query ,
%~                              u_assign([:,Proof1,Premise1],Assign_List3) ,
%~                              [ synthesize,
%~                                [:,Proof1,Premise1], Axiom,Rule,K] =
%~                                Assign_List3 ,
%~                              u_assign([:,Proof2,Premise2],Assign_List4) ,
%~                              [ synthesize,
%~                                [:,Proof2,Premise2], Axiom,Rule,K] =
%~                                Assign_List4 ,
%~                              u_assign([:,Proof3,Premise3],Assign_List5) ,
%~                              [ synthesize,
%~                                [:,Proof3,Premise3], Axiom,Rule,K] =
%~                                Assign_List5)]
%~ [convert(_211120),head_preconds_into_body((synthesize(Query,Axiom,Rule,_210124,Query):-(u_assign(['S',K],_210134),_210134=_210124),(((u_assign([->,Premise1,Premise2,Premise3,Conclusion],_212320),_212320=_212310),u_assign([:,Ructor,_212310],_211704)),[Rule]=_211704),(((u_assign([Ructor,Proof1,Proof2,Proof3],_213516),_213516=_213506),u_assign([:,_213506,Conclusion],_212956)),Query=_212956),(u_assign([:,Proof1,Premise1],_214206),[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]=_214206),(u_assign([:,Proof2,Premise2],_215180),[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]=_215180),u_assign([:,Proof3,Premise3],_216154),[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]=_216154))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,['S',K]],['let*',[[[:,Ructor,[->,Premise1,Premise2,Premise3,Conclusion]],[Rule]],[[:,[Ructor,Proof1,Proof2,Proof3],Conclusion],Query],[[:,Proof1,Premise1],[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]],[[:,Proof2,Premise2],[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]],[[:,Proof3,Premise3],[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise1 $Premise2 $Premise3 $Conclusion)) 
          ($Rule)) 
        ( (: 
            ($Ructor $Proof1 $Proof2 $Proof3) $Conclusion) $Query) 
        ( (: $Proof1 $Premise1) 
          (synthesize 
            (: $Proof1 $Premise1) $Axiom $Rule $K)) 
        ( (: $Proof2 $Premise2) 
          (synthesize 
            (: $Proof2 $Premise2) $Axiom $Rule $K)) 
        ( (: $Proof3 $Premise3) 
          (synthesize 
            (: $Proof3 $Premise3) $Axiom $Rule $K))) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, A, Query) :-
    u_assign(['S', K], B),
    B=A,
    ( u_assign([ ->,
                 Premise1,
                 Premise2,
                 Premise3,
                 Conclusion
               ],
               C),
      C=D,
      u_assign([:, Ructor, D], E)
    ),
    [Rule]=E,
    ( u_assign([Ructor, Proof1, Proof2, Proof3], F),
      F=G,
      u_assign([:, G, Conclusion], H)
    ),
    Query=H,
    u_assign([:, Proof1, Premise1], I),
    [synthesize, [:, Proof1, Premise1], Axiom, Rule, K]=I,
    u_assign([:, Proof2, Premise2], J),
    [synthesize, [:, Proof2, Premise2], Axiom, Rule, K]=J,
    u_assign([:, Proof3, Premise3], K),
    [synthesize, [:, Proof3, Premise3], Axiom, Rule, K]=K.

</span>

;; Quaternary rule
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Rule,Query) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=Rule ,
%~                              u_assign(
%~                                 [ ->, Premise1,Premise2,
%~                                   Premise3,Premise4,
%~                                   Conclusion],
%~                                 Assign8) ,
%~                              Assign8=_297658 ,
%~                              u_assign([:,Ructor,_297658],Assign_List) ,
%~                              [Rule]=Assign_List ,
%~                              u_assign(
%~                                 [ Ructor, Proof1,Proof2,Proof3,
%~                                   Proof4],
%~                                 Assign10) ,
%~                              Assign10=_297724 ,
%~                              u_assign([:,_297724,Conclusion],VAR_Query) ,
%~                              Query=VAR_Query ,
%~                              u_assign([:,Proof1,Premise1],Assign_List3) ,
%~                              [ synthesize,
%~                                [:,Proof1,Premise1], Axiom,Rule,K] =
%~                                Assign_List3 ,
%~                              u_assign([:,Proof2,Premise2],Assign_List4) ,
%~                              [ synthesize,
%~                                [:,Proof2,Premise2], Axiom,Rule,K] =
%~                                Assign_List4 ,
%~                              u_assign([:,Proof3,Premise3],Assign_List5) ,
%~                              [ synthesize,
%~                                [:,Proof3,Premise3], Axiom,Rule,K] =
%~                                Assign_List5 ,
%~                              u_assign([:,Proof4,Premise4],Assign_List6) ,
%~                              [ synthesize,
%~                                [:,Proof4,Premise4], Axiom,Rule,K] =
%~                                Assign_List6)]
%~ [convert(_56498),head_preconds_into_body((synthesize(Query,Axiom,Rule,_55502,Query):-(u_assign(['S',K],_55512),_55512=_55502),(((u_assign([->,Premise1,Premise2,Premise3,Premise4,Conclusion],_57698),_57698=_57688),u_assign([:,Ructor,_57688],_57082)),[Rule]=_57082),(((u_assign([Ructor,Proof1,Proof2,Proof3,Proof4],_58964),_58964=_58954),u_assign([:,_58954,Conclusion],_58404)),Query=_58404),(u_assign([:,Proof1,Premise1],_59724),[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]=_59724),(u_assign([:,Proof2,Premise2],_60698),[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]=_60698),(u_assign([:,Proof3,Premise3],_61672),[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]=_61672),u_assign([:,Proof4,Premise4],_62646),[synthesize,[:,Proof4,Premise4],Axiom,Rule,K]=_62646))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,['S',K]],['let*',[[[:,Ructor,[->,Premise1,Premise2,Premise3,Premise4,Conclusion]],[Rule]],[[:,[Ructor,Proof1,Proof2,Proof3,Proof4],Conclusion],Query],[[:,Proof1,Premise1],[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]],[[:,Proof2,Premise2],[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]],[[:,Proof3,Premise3],[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]],[[:,Proof4,Premise4],[synthesize,[:,Proof4,Premise4],Axiom,Rule,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise1 $Premise2 $Premise3 $Premise4 $Conclusion)) 
          ($Rule)) 
        ( (: 
            ($Ructor $Proof1 $Proof2 $Proof3 $Proof4) $Conclusion) $Query) 
        ( (: $Proof1 $Premise1) 
          (synthesize 
            (: $Proof1 $Premise1) $Axiom $Rule $K)) 
        ( (: $Proof2 $Premise2) 
          (synthesize 
            (: $Proof2 $Premise2) $Axiom $Rule $K)) 
        ( (: $Proof3 $Premise3) 
          (synthesize 
            (: $Proof3 $Premise3) $Axiom $Rule $K)) 
        ( (: $Proof4 $Premise4) 
          (synthesize 
            (: $Proof4 $Premise4) $Axiom $Rule $K))) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, A, Query) :-
    u_assign(['S', K], B),
    B=A,
    ( u_assign([ ->,
                 Premise1,
                 Premise2,
                 Premise3,
                 Premise4,
                 Conclusion
               ],
               C),
      C=D,
      u_assign([:, Ructor, D], E)
    ),
    [Rule]=E,
    ( u_assign([ Ructor,
                 Proof1,
                 Proof2,
                 Proof3,
                 Proof4
               ],
               F),
      F=G,
      u_assign([:, G, Conclusion], H)
    ),
    Query=H,
    u_assign([:, Proof1, Premise1], I),
    [synthesize, [:, Proof1, Premise1], Axiom, Rule, K]=I,
    u_assign([:, Proof2, Premise2], J),
    [synthesize, [:, Proof2, Premise2], Axiom, Rule, K]=J,
    u_assign([:, Proof3, Premise3], K),
    [synthesize, [:, Proof3, Premise3], Axiom, Rule, K]=K,
    u_assign([:, Proof4, Premise4], L),
    [synthesize, [:, Proof4, Premise4], Axiom, Rule, K]=L.

</span>

;; Quintenary rule
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Rule,Query) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=Rule ,
%~                              u_assign(
%~                                 [ ->, Premise1,Premise2,
%~                                   Premise3,Premise4,
%~                                   Premise5,Conclusion],
%~                                 Assign9) ,
%~                              Assign9=_219464 ,
%~                              u_assign([:,Ructor,_219464],Assign_List) ,
%~                              [Rule]=Assign_List ,
%~                              u_assign(
%~                                 [ Ructor, Proof1,Proof2,Proof3,
%~                                   Proof4,Proof5],
%~                                 Assign11) ,
%~                              Assign11=_219530 ,
%~                              u_assign([:,_219530,Conclusion],VAR_Query) ,
%~                              Query=VAR_Query ,
%~                              u_assign([:,Proof1,Premise1],Assign_List3) ,
%~                              [ synthesize,
%~                                [:,Proof1,Premise1], Axiom,Rule,K] =
%~                                Assign_List3 ,
%~                              u_assign([:,Proof2,Premise2],Assign_List4) ,
%~                              [ synthesize,
%~                                [:,Proof2,Premise2], Axiom,Rule,K] =
%~                                Assign_List4 ,
%~                              u_assign([:,Proof3,Premise3],Assign_List5) ,
%~                              [ synthesize,
%~                                [:,Proof3,Premise3], Axiom,Rule,K] =
%~                                Assign_List5 ,
%~                              u_assign([:,Proof4,Premise4],Assign_List6) ,
%~                              [ synthesize,
%~                                [:,Proof4,Premise4], Axiom,Rule,K] =
%~                                Assign_List6 ,
%~                              u_assign([:,Proof5,Premise5],Assign_List7) ,
%~                              [ synthesize,
%~                                [:,Proof5,Premise5], Axiom,Rule,K] =
%~                                Assign_List7)]
%~ [convert(_3934),head_preconds_into_body((synthesize(Query,Axiom,Rule,_3884,Query):-(u_assign(['S',K],_3888),_3888=_3884),(((u_assign([->,Premise1,Premise2,Premise3,Premise4,Premise5,Conclusion],_3990),_3990=_3986),u_assign([:,Ructor,_3986],_3958)),[Rule]=_3958),(((u_assign([Ructor,Proof1,Proof2,Proof3,Proof4,Proof5],_4094),_4094=_4090),u_assign([:,_4090,Conclusion],_4068)),Query=_4068),(u_assign([:,Proof1,Premise1],_4178),[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]=_4178),(u_assign([:,Proof2,Premise2],_4220),[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]=_4220),(u_assign([:,Proof3,Premise3],_4262),[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]=_4262),(u_assign([:,Proof4,Premise4],_4304),[synthesize,[:,Proof4,Premise4],Axiom,Rule,K]=_4304),u_assign([:,Proof5,Premise5],_4346),[synthesize,[:,Proof5,Premise5],Axiom,Rule,K]=_4346))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,['S',K]],['let*',[[[:,Ructor,[->,Premise1,Premise2,Premise3,Premise4,Premise5,Conclusion]],[Rule]],[[:,[Ructor,Proof1,Proof2,Proof3,Proof4,Proof5],Conclusion],Query],[[:,Proof1,Premise1],[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]],[[:,Proof2,Premise2],[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]],[[:,Proof3,Premise3],[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]],[[:,Proof4,Premise4],[synthesize,[:,Proof4,Premise4],Axiom,Rule,K]],[[:,Proof5,Premise5],[synthesize,[:,Proof5,Premise5],Axiom,Rule,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise1 $Premise2 $Premise3 $Premise4 $Premise5 $Conclusion)) 
          ($Rule)) 
        ( (: 
            ($Ructor $Proof1 $Proof2 $Proof3 $Proof4 $Proof5) $Conclusion) $Query) 
        ( (: $Proof1 $Premise1) 
          (synthesize 
            (: $Proof1 $Premise1) $Axiom $Rule $K)) 
        ( (: $Proof2 $Premise2) 
          (synthesize 
            (: $Proof2 $Premise2) $Axiom $Rule $K)) 
        ( (: $Proof3 $Premise3) 
          (synthesize 
            (: $Proof3 $Premise3) $Axiom $Rule $K)) 
        ( (: $Proof4 $Premise4) 
          (synthesize 
            (: $Proof4 $Premise4) $Axiom $Rule $K)) 
        ( (: $Proof5 $Premise5) 
          (synthesize 
            (: $Proof5 $Premise5) $Axiom $Rule $K))) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, A, Query) :-
    u_assign(['S', K], B),
    B=A,
    ( u_assign([ ->,
                 Premise1,
                 Premise2,
                 Premise3,
                 Premise4,
                 Premise5,
                 Conclusion
               ],
               C),
      C=D,
      u_assign([:, Ructor, D], E)
    ),
    [Rule]=E,
    ( u_assign([ Ructor,
                 Proof1,
                 Proof2,
                 Proof3,
                 Proof4,
                 Proof5
               ],
               F),
      F=G,
      u_assign([:, G, Conclusion], H)
    ),
    Query=H,
    u_assign([:, Proof1, Premise1], I),
    [synthesize, [:, Proof1, Premise1], Axiom, Rule, K]=I,
    u_assign([:, Proof2, Premise2], J),
    [synthesize, [:, Proof2, Premise2], Axiom, Rule, K]=J,
    u_assign([:, Proof3, Premise3], K),
    [synthesize, [:, Proof3, Premise3], Axiom, Rule, K]=K,
    u_assign([:, Proof4, Premise4], L),
    [synthesize, [:, Proof4, Premise4], Axiom, Rule, K]=L,
    u_assign([:, Proof5, Premise5], M),
    [synthesize, [:, Proof5, Premise5], Axiom, Rule, K]=M.

</span>

; Evaluation took 2.76 seconds.
<span class="ansi33"> &self

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Predicate','Type'])
</span><span class="ansi38-255165000">  (: Predicate Type)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â\x86\\x92\',[->,'Predicate','Predicate','Type']])
</span><span class="ansi38-255165000">  (: â 
    (-> Predicate Predicate Type))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,big,[->,'Atom','Predicate']])
</span><span class="ansi38-255165000">  (: big 
    (-> Atom Predicate))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,need,[->,'Atom','Atom','Predicate']])
</span><span class="ansi38-255165000">  (: need 
    (-> Atom Atom Predicate))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,see,[->,'Atom','Atom','Predicate']])
</span><span class="ansi38-255165000">  (: see 
    (-> Atom Atom Predicate))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,chase,[->,'Atom','Atom','Predicate']])
</span><span class="ansi38-255165000">  (: chase 
    (-> Atom Atom Predicate))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,cow,'Atom'])
</span><span class="ansi38-255165000">  (: cow Atom)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,dog,'Atom'])
</span><span class="ansi38-255165000">  (: dog Atom)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,rabbit,'Atom'])
</span><span class="ansi38-255165000">  (: rabbit Atom)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,kb,[->,'Atom']])
</span><span class="ansi38-255165000">  (: kb 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( [kb,_31522] :-
%~                              ( ( u_assign([big,cow],Assign)  ,
%~                                  Assign=VAR_Assign ,
%~                                  u_assign(['STV',0.99,0.99],Assign1) ,
%~                                  Assign1=VAR_Assign1 ,
%~                                  u_assign(['â\x89\\x9E\',VAR_Assign,VAR_Assign1],Assign2) ,
%~                                  Assign2=VAR_Assign2 ,
%~                                  u_assign([:,cow_is_big,VAR_Assign2],Assign3) ,
%~                                  Assign3=VAR_Assign3)  ;
%~                                ( u_assign([need,cow,dog],Assign4)  ,
%~                                  Assign4=VAR_Assign4 ,
%~                                  u_assign(['STV',0.99,0.99],Assign5) ,
%~                                  Assign5=VAR_Assign5 ,
%~                                  u_assign(['â\x89\\x9E\',VAR_Assign4,VAR_Assign5],Assign6) ,
%~                                  Assign6=VAR_Assign6 ,
%~                                  u_assign([:,cow_needs_dog,VAR_Assign6],Assign7) ,
%~                                  Assign7=VAR_Assign3) ;
%~                                ( u_assign([see,dog,rabbit],Assign8)  ,
%~                                  Assign8=VAR_Assign8 ,
%~                                  u_assign(['STV',0.99,0.99],Assign9) ,
%~                                  Assign9=VAR_Assign9 ,
%~                                  u_assign(['â\x89\\x9E\',VAR_Assign8,VAR_Assign9],Assign10) ,
%~                                  Assign10=VAR_Assign10 ,
%~                                  u_assign([:,dog_sees_rabbit,VAR_Assign10],Assign11) ,
%~                                  Assign11=VAR_Assign3) ;
%~                                ( u_assign([chase,rabbit,cow],Assign12)  ,
%~                                  Assign12=VAR_Assign12 ,
%~                                  u_assign(['STV',0.99,0.99],Assign13) ,
%~                                  Assign13=VAR_Assign13 ,
%~                                  u_assign(['â\x89\\x9E\',VAR_Assign12,VAR_Assign13],Assign14) ,
%~                                  Assign14=VAR_Assign14 ,
%~                                  u_assign([:,rabbit_chases_cow,VAR_Assign14],Assign15) ,
%~                                  Assign15=VAR_Assign3) ;
%~                                ( u_assign([chase,rabbit,dog],Assign16)  ,
%~                                  Assign16=VAR_Assign16 ,
%~                                  u_assign(['STV',0.99,0.99],Assign17) ,
%~                                  Assign17=VAR_Assign17 ,
%~                                  u_assign(['â\x89\\x9E\',VAR_Assign16,VAR_Assign17],Assign18) ,
%~                                  Assign18=VAR_Assign18 ,
%~                                  u_assign([:,rabbit_chases_dog,VAR_Assign18],Assign19) ,
%~                                  Assign19=VAR_Assign3) ;
%~                                ( u_assign([big,rabbit],Assign20)  ,
%~                                  Assign20=VAR_Assign20 ,
%~                                  u_assign(['STV',0.99,0.99],Assign21) ,
%~                                  Assign21=VAR_Assign21 ,
%~                                  u_assign(['â\x89\\x9E\',VAR_Assign20,VAR_Assign21],Assign22) ,
%~                                  Assign22=VAR_Assign22 ,
%~                                  u_assign([:,rabbit_is_big,VAR_Assign22],Assign23) ,
%~                                  Assign23=VAR_Assign3) ;
%~                                ( u_assign([see,rabbit,dog],Assign24)  ,
%~                                  Assign24=VAR_Assign24 ,
%~                                  u_assign(['STV',0.99,0.99],Assign25) ,
%~                                  Assign25=VAR_Assign25 ,
%~                                  u_assign(['â\x89\\x9E\',VAR_Assign24,VAR_Assign25],Assign26) ,
%~                                  Assign26=VAR_Assign26 ,
%~                                  u_assign([:,rabbit_sees_dog,VAR_Assign26],Assign27) ,
%~                                  Assign27=VAR_Assign3) ;
%~                                ( u_assign([chase,cow,dog],Assign28)  ,
%~                                  Assign28=VAR_Assign28 ,
%~                                  u_assign([see,cow,rabbit],Assign29) ,
%~                                  Assign29=VAR_Assign29 ,
%~                                  u_assign(['â\x86\\x92\',VAR_Assign28,VAR_Assign29],Assign30) ,
%~                                  Assign30=VAR_Assign30 ,
%~                                  u_assign(['STV',0.99,0.99],Assign31) ,
%~                                  Assign31=VAR_Assign31 ,
%~                                  u_assign(['â\x89\\x9E\',VAR_Assign30,VAR_Assign31],Assign32) ,
%~                                  Assign32=VAR_Assign32 ,
%~                                  u_assign([:,cow_chases_dog_sees_rabbit,VAR_Assign32],Assign33) ,
%~                                  Assign33=VAR_Assign3) ;
%~                                ( u_assign([big,X],Assign34)  ,
%~                                  Assign34=VAR_Assign34 ,
%~                                  u_assign([chase,X,dog],Assign35) ,
%~                                  Assign35=VAR_Assign35 ,
%~                                  u_assign(['â\x86\\x92\',VAR_Assign34,VAR_Assign35],Assign36) ,
%~                                  Assign36=VAR_Assign36 ,
%~                                  u_assign(['STV',0.99,0.99],Assign37) ,
%~                                  Assign37=VAR_Assign37 ,
%~                                  u_assign(['â\x89\\x9E\',VAR_Assign36,VAR_Assign37],Assign38) ,
%~                                  Assign38=VAR_Assign38 ,
%~                                  u_assign([:,x_is_big_chases_dog,VAR_Assign38],Assign39) ,
%~                                  Assign39=VAR_Assign3)))]
%~ [convert(_3436),head_preconds_into_body(([kb,_3412]:-(((((u_assign([big,cow],_3508),_3508=_3504),u_assign(['STV',0.99,0.99],_3552),_3552=_3548),u_assign(['â\x89\\x9E\',_3504,_3548],_3482)),_3482=_3478),u_assign([:,cow_is_big,_3478],_3450)),_3450=_3412;(((((u_assign([need,cow,dog],_3684),_3684=_3680),u_assign(['STV',0.99,0.99],_3734),_3734=_3730),u_assign(['â\x89\\x9E\',_3680,_3730],_3658)),_3658=_3654),u_assign([:,cow_needs_dog,_3654],_3626)),_3626=_3412;(((((u_assign([see,dog,rabbit],_3866),_3866=_3862),u_assign(['STV',0.99,0.99],_3916),_3916=_3912),u_assign(['â\x89\\x9E\',_3862,_3912],_3840)),_3840=_3836),u_assign([:,dog_sees_rabbit,_3836],_3808)),_3808=_3412;(((((u_assign([chase,rabbit,cow],_4048),_4048=_4044),u_assign(['STV',0.99,0.99],_4098),_4098=_4094),u_assign(['â\x89\\x9E\',_4044,_4094],_4022)),_4022=_4018),u_assign([:,rabbit_chases_cow,_4018],_3990)),_3990=_3412;(((((u_assign([chase,rabbit,dog],_4230),_4230=_4226),u_assign(['STV',0.99,0.99],_4280),_4280=_4276),u_assign(['â\x89\\x9E\',_4226,_4276],_4204)),_4204=_4200),u_assign([:,rabbit_chases_dog,_4200],_4172)),_4172=_3412;(((((u_assign([big,rabbit],_4412),_4412=_4408),u_assign(['STV',0.99,0.99],_4456),_4456=_4452),u_assign(['â\x89\\x9E\',_4408,_4452],_4386)),_4386=_4382),u_assign([:,rabbit_is_big,_4382],_4354)),_4354=_3412;(((((u_assign([see,rabbit,dog],_4588),_4588=_4584),u_assign(['STV',0.99,0.99],_4638),_4638=_4634),u_assign(['â\x89\\x9E\',_4584,_4634],_4562)),_4562=_4558),u_assign([:,rabbit_sees_dog,_4558],_4530)),_4530=_3412;((((((((u_assign([chase,cow,dog],_4796),_4796=_4792),u_assign([see,cow,rabbit],_4846),_4846=_4842),u_assign(['â\x86\\x92\',_4792,_4842],_4770)),_4770=_4766),u_assign(['STV',0.99,0.99],_4914),_4914=_4910),u_assign(['â\x89\\x9E\',_4766,_4910],_4744)),_4744=_4740),u_assign([:,cow_chases_dog_sees_rabbit,_4740],_4712)),_4712=_3412;((((((((u_assign([big,X],_5072),_5072=_5068),u_assign([chase,X,dog],_5116),_5116=_5112),u_assign(['â\x86\\x92\',_5068,_5112],_5046)),_5046=_5042),u_assign(['STV',0.99,0.99],_5184),_5184=_5180),u_assign(['â\x89\\x9E\',_5042,_5180],_5020)),_5020=_5016),u_assign([:,x_is_big_chases_dog,_5016],_4988)),_4988=_3412))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[kb],[superpose,[[:,cow_is_big,['â\x89\\x9E\',[big,cow],['STV',0.99,0.99]]],[:,cow_needs_dog,['â\x89\\x9E\',[need,cow,dog],['STV',0.99,0.99]]],[:,dog_sees_rabbit,['â\x89\\x9E\',[see,dog,rabbit],['STV',0.99,0.99]]],[:,rabbit_chases_cow,['â\x89\\x9E\',[chase,rabbit,cow],['STV',0.99,0.99]]],[:,rabbit_chases_dog,['â\x89\\x9E\',[chase,rabbit,dog],['STV',0.99,0.99]]],[:,rabbit_is_big,['â\x89\\x9E\',[big,rabbit],['STV',0.99,0.99]]],[:,rabbit_sees_dog,['â\x89\\x9E\',[see,rabbit,dog],['STV',0.99,0.99]]],[:,cow_chases_dog_sees_rabbit,['â\x89\\x9E\',['â\x86\\x92\',[chase,cow,dog],[see,cow,rabbit]],['STV',0.99,0.99]]],[:,x_is_big_chases_dog,['â\x89\\x9E\',['â\x86\\x92\',[big,X],[chase,X,dog]],['STV',0.99,0.99]]]]])
</span><span class="ansi38-255165000">  (= 
    (kb) 
    (superpose 
      ( (: cow_is_big 
          (â 
            (big cow) 
            (STV 0.99 0.99))) 
        (: cow_needs_dog 
          (â 
            (need cow dog) 
            (STV 0.99 0.99))) 
        (: dog_sees_rabbit 
          (â 
            (see dog rabbit) 
            (STV 0.99 0.99))) 
        (: rabbit_chases_cow 
          (â 
            (chase rabbit cow) 
            (STV 0.99 0.99))) 
        (: rabbit_chases_dog 
          (â 
            (chase rabbit dog) 
            (STV 0.99 0.99))) 
        (: rabbit_is_big 
          (â 
            (big rabbit) 
            (STV 0.99 0.99))) 
        (: rabbit_sees_dog 
          (â 
            (see rabbit dog) 
            (STV 0.99 0.99))) 
        (: cow_chases_dog_sees_rabbit 
          (â 
            (â 
              (chase cow dog) 
              (see cow rabbit)) 
            (STV 0.99 0.99))) 
        (: x_is_big_chases_dog 
          (â 
            (â 
              (big $X) 
              (chase $X dog)) 
            (STV 0.99 0.99))))))
</span><span class="ansi38-000082136">
  [kb, A] :-
    (   ( ( u_assign([big, cow], B),
            B=C,
            u_assign(['STV', 0.99, 0.99], D),
            D=E
          ),
          u_assign(['â\u0089\u009E', C, E], F),
          F=G
        ),
        u_assign([:, cow_is_big, G], H),
        H=A
    ;   ( ( u_assign([need, cow, dog], I),
            I=J,
            u_assign(['STV', 0.99, 0.99], K),
            K=L
          ),
          u_assign(['â\u0089\u009E', J, L], M),
          M=N
        ),
        u_assign([:, cow_needs_dog, N], O),
        O=A
    ;   ( ( u_assign([see, dog, rabbit], P),
            P=Q,
            u_assign(['STV', 0.99, 0.99], R),
            R=S
          ),
          u_assign(['â\u0089\u009E', Q, S], T),
          T=U
        ),
        u_assign([:, dog_sees_rabbit, U], V),
        V=A
    ;   ( ( u_assign([chase, rabbit, cow], W),
            W=X,
            u_assign(['STV', 0.99, 0.99], Y),
            Y=Z
          ),
          u_assign(['â\u0089\u009E', X, Z], A1),
          A1=B1
        ),
        u_assign([:, rabbit_chases_cow, B1], C1),
        C1=A
    ;   ( ( u_assign([chase, rabbit, dog], D1),
            D1=E1,
            u_assign(['STV', 0.99, 0.99], F1),
            F1=G1
          ),
          u_assign(['â\u0089\u009E', E1, G1], H1),
          H1=I1
        ),
        u_assign([:, rabbit_chases_dog, I1], J1),
        J1=A
    ;   ( ( u_assign([big, rabbit], K1),
            K1=L1,
            u_assign(['STV', 0.99, 0.99], M1),
            M1=N1
          ),
          u_assign(['â\u0089\u009E', L1, N1], O1),
          O1=P1
        ),
        u_assign([:, rabbit_is_big, P1], Q1),
        Q1=A
    ;   ( ( u_assign([see, rabbit, dog], R1),
            R1=S1,
            u_assign(['STV', 0.99, 0.99], T1),
            T1=U1
          ),
          u_assign(['â\u0089\u009E', S1, U1], V1),
          V1=W1
        ),
        u_assign([:, rabbit_sees_dog, W1], X1),
        X1=A
    ;   ( ( ( ( u_assign([chase, cow, dog], Y1),
                Y1=Z1
              ),
              u_assign([see, cow, rabbit], A2),
              A2=B2,
              u_assign(['â\u0086\u0092', Z1, B2], C2)
            ),
            C2=D2,
            u_assign(['STV', 0.99, 0.99], E2),
            E2=F2
          ),
          u_assign(['â\u0089\u009E', D2, F2], G2),
          G2=H2
        ),
        u_assign([:, cow_chases_dog_sees_rabbit, H2], I2),
        I2=A
    ;   ( ( ( ( u_assign([big, X], J2),
                J2=K2
              ),
              u_assign([chase, X, dog], L2),
              L2=M2,
              u_assign(['â\u0086\u0092', K2, M2], N2)
            ),
            N2=O2,
            u_assign(['STV', 0.99, 0.99], P2),
            P2=Q2
          ),
          u_assign(['â\u0089\u009E', O2, Q2], R2),
          R2=S2
        ),
        u_assign([:, x_is_big_chases_dog, S2], T2),
        T2=A
    ).

</span>

;; Rule base
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,rb,[->,'Atom']])
</span><span class="ansi38-255165000">  (: rb 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(([rb,_437190]:-['modus-ponens-rule',_437190]))]
%~ [convert(_439030),head_preconds_into_body(([rb,_437190]:-['modus-ponens-rule',_437190]))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[rb],['modus-ponens-rule'])
</span><span class="ansi38-255165000">  (= 
    (rb) 
    (modus-ponens-rule))
</span><span class="ansi38-000082136">
  [rb, A] :-
    ['modus-ponens-rule', A].

</span>

<span class="ansi38-000068000">!"===== Test synthesizer ===="

</span><span class="ansi38-017068017">exec(A) :-
    A="===== Test synthesizer ====".

</span>; Evaluation took 0.011 ms. (11.20 microseconds) 
<span class="ansi33"> "===== Test synthesizer ===="

</span><span class="ansi38-000068000">!(synthesize (: $Proof (â (big cow) (STV $S $C))) kb rb (fromNumber 0))

</span><span class="ansi38-017068017">exec(A) :-
    ( ( ( ( true,
            u_assign([big, cow], B)
          ),
          B=C,
          true,
          u_assign(['STV', S, C], D),
          D=E
        ),
        u_assign(['â\u0089\u009E', C, E], F),
        F=G
      ),
      u_assign([:, Proof, G], H),
      H=I
    ),
    ( true,
      u_assign([fromNumber, 0], J)
    ),
    J=K,
    u_assign([synthesize, I, kb, rb, K], A).

</span>; Evaluation took 2.18 ms.
<span class="ansi33">  (: cow_is_big 
    (â 
      (big cow) 
      (STV 0.99 0.99)))
</span><span class="ansi32">['C'=0.99,'S'=0.99,'Proof'=cow_is_big]
</span>

;; (: cow_is_big (â (big cow) (STV 0.99 0.99)))
<span class="ansi38-000068000">!(synthesize (: $Proof (â (chase cow dog) (STV $S $C))) kb rb (fromNumber 1))

</span><span class="ansi38-017068017">exec(A) :-
    ( ( ( ( true,
            u_assign([chase, cow, dog], B)
          ),
          B=C,
          true,
          u_assign(['STV', S, C], D),
          D=E
        ),
        u_assign(['â\u0089\u009E', C, E], F),
        F=G
      ),
      u_assign([:, Proof, G], H),
      H=I
    ),
    ( true,
      u_assign([fromNumber, 1], J)
    ),
    J=K,
    u_assign([synthesize, I, kb, rb, K], A).

</span>;; (: (ModusPonens cow_is_big x_is_big_chases_dog) (â (chase cow dog) (STV 0.9821 0.99)))
<span class="ansi38-000068000">!(synthesize (: $Proof (â (see cow rabbit) (STV $S $C))) kb rb (fromNumber 2))

</span><span class="ansi38-017068017">exec(A) :-
    ( ( ( ( true,
            u_assign([see, cow, rabbit], B)
          ),
          B=C,
          true,
          u_assign(['STV', S, C], D),
          D=E
        ),
        u_assign(['â\u0089\u009E', C, E], F),
        F=G
      ),
      u_assign([:, Proof, G], H),
      H=I
    ),
    ( true,
      u_assign([fromNumber, 2], J)
    ),
    J=K,
    u_assign([synthesize, I, kb, rb, K], A).

</span><span class="ansi32">% 70,214,250 inferences, 11.370 CPU in 11.370 seconds (100% CPU, 6175366 Lips)
</span> (@ = "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/dependent-types/ModusPonensDTLTest.metta" 0)
<br/><a href="https://github.com/logicmoo/vspace-metta/blob/main/MeTTaLog.md">Return to Summaries</a><br/>
doing(ansi2html -u < "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/TEE.ansi" > "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/dependent-types/ModusPonensDTLTest.html" )

</pre>
</body>

</html>
