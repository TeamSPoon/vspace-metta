<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>
<style type="text/css">
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content">
 (@ track_load_into_file "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/synthesis/SynthesizeTest.metta")
;; Setting up a simple knowledge base and rule base for demoing reasoning in MeTTa.
;; Import modules
<span class="ansi38-000068000">!(import! &self Synthesize.metta)

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&self', 'Synthesize.metta'], A).

</span>;; Import modules
<span class="ansi38-000068000">!(import! &self "../common/Num.metta")

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&self', '../common/Num.metta'], A).

</span>;; !(import! &self Unify.metta)
;; Enumerate all programs up to a given depth that are consistent with
;; the query, using the given axiom non-deterministic functions and rules.
;;
;; The arguments are:
;;
;; $query: an Atom under the form (: TERM TYPE).  The atom may contain
;;         free variables within TERM and TYPE to form various sort of
;;         queries, such as:
;;         1. Backward chaining: (: $term (Inheritance $x Mammal))
;;         2. Forward chaining: (: ($rule $premise AXIOM) $type)
;;         3. Mixed chaining: (: ($rule $premise AXIOM) (Inheritance $x Mammal))
;;         4. Type checking: (: TERM TYPE)
;;         5. Type inference: (: TERM $type)
;;
;; $axiom: a nullary function to axiom, to non-deterministically pick
;;         up an axiom.  An axiom is an Atom of the form
;;         (: TERM TYPE).
;;
;; $rule: a nullary function to rule, to non-deterministically pick up
;;        a rule.  A rule is a function mapping premises to
;;        conclusion, where premises and conclusion have the form
;;        (: TERM TYPE).
;;
;; $depth: a Nat representing the maximum depth of the generated
;;         programs.
;;
;; TODO: recurse over curried rules instead of duplicating code over
;; tuples.
;; Collection of functions operating on numbers
;; Define max
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,max,[->,A,A,A]])
</span><span class="ansi38-255165000">  (: max 
    (-> $A $A $A))
</span>

%~ /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/metta_vspace/pyswip/metta_interp.pl:1054 
%~ [ convert(Convert),
%~   head_preconds_into_body( max(X,Y,Assign_Max_Y) :-
%~                              u_assign([>,X,Y],Assign) ,
%~                              Assign=_455654 ,
%~                              u_assign([if,_455654,X,Y],Assign_Max_Y))]
%~ [convert(_392204),head_preconds_into_body((max(X,Y,_390968):-(u_assign([>,X,Y],_392510),_392510=_392500),u_assign([if,_392500,X,Y],_390968)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[max,X,Y],[if,[>,X,Y],X,Y])
</span><span class="ansi38-255165000">  (= 
    (max $X $Y) 
    (if 
      (> $X $Y) $X $Y))
</span><span class="ansi38-000082136">  :- dynamic(max,3).

  max(X, Y, A) :-
    u_assign([>, X, Y], B),
    B=C,
    u_assign([if, C, X, Y], A).

</span>

;; Define min
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,min,[->,A,A,A]])
</span><span class="ansi38-255165000">  (: min 
    (-> $A $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( min(X,Y,Assign_Min_Y) :-
%~                              u_assign([<,X,Y],Assign) ,
%~                              Assign=_60012 ,
%~                              u_assign([if,_60012,X,Y],Assign_Min_Y))]
%~ [convert(_3174),head_preconds_into_body((min(X,Y,_3168):-(u_assign([<,X,Y],_3204),_3204=_3200),u_assign([if,_3200,X,Y],_3168)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[min,X,Y],[if,[<,X,Y],X,Y])
</span><span class="ansi38-255165000">  (= 
    (min $X $Y) 
    (if 
      (< $X $Y) $X $Y))
</span><span class="ansi38-000082136">  :- dynamic(min,3).

  min(X, Y, A) :-
    u_assign([<, X, Y], B),
    B=C,
    u_assign([if, C, X, Y], A).

</span>

;; Clamp a number to be within a certain range
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,clamp,[->,A,A,A,A]])
</span><span class="ansi38-255165000">  (: clamp 
    (-> $A $A $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( clamp(X,L,U,Assign_Clamp_U) :-
%~                              u_assign([min,U,X],Assign) ,
%~                              Assign=_183642 ,
%~                              u_assign([max,L,_183642],Assign_Clamp_U))]
%~ [convert(_123302),head_preconds_into_body((clamp(X,L,U,_121996):-(u_assign([min,U,X],_123664),_123664=_123654),u_assign([max,L,_123654],_121996)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[clamp,X,L,U],[max,L,[min,U,X]])
</span><span class="ansi38-255165000">  (= 
    (clamp $X $L $U) 
    (max $L 
      (min $U $X)))
</span><span class="ansi38-000082136">  :- dynamic(clamp,4).

  clamp(X, L, U, A) :-
    u_assign([min, U, X], B),
    B=C,
    u_assign([max, L, C], A).

</span>

;; Define abs
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,abs,[->,A,A]])
</span><span class="ansi38-255165000">  (: abs 
    (-> $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( abs(X,Assign_Abs_X) :-
%~                              u_assign([<,X,0],Assign) ,
%~                              Assign=_329050 ,
%~                              u_assign([*,-1,X],Assign3) ,
%~                              Assign3=_329068 ,
%~                              u_assign([if,_329050,_329068,X],Assign_Abs_X))]
%~ [convert(_243388),head_preconds_into_body((abs(X,_242222):-((u_assign([<,X,0],_243694),_243694=_243684),u_assign([*,-1,X],_243854),_243854=_243844),u_assign([if,_243684,_243844,X],_242222)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[abs,X],[if,[<,X,0],[*,-1,X],X])
</span><span class="ansi38-255165000">  (= 
    (abs $X) 
    (if 
      (< $X 0) 
      (* -1 $X) $X))
</span><span class="ansi38-000082136">
  abs(X, A) :-
    ( u_assign([<, X, 0], B),
      B=C
    ),
    u_assign([*, -1, X], D),
    D=E,
    u_assign([if, C, E, X], A).

</span>

;; Define <=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,<=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: <= 
    (-> $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( <=(X,Y,Assign_Y) :-
%~                              u_assign([<,X,Y],Assign) ,
%~                              Assign=_509166 ,
%~                              u_assign([==,X,Y],Assign2) ,
%~                              Assign2=_509184 ,
%~                              u_assign([or,_509166,_509184],Assign_Y))]
%~ [convert(_434130),head_preconds_into_body((<=(X,Y,_432894):-((u_assign([<,X,Y],_434436),_434436=_434426),u_assign([==,X,Y],_434640),_434640=_434630),u_assign([or,_434426,_434630],_432894)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[<=,X,Y],[or,[<,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">  (= 
    (<= $X $Y) 
    (or 
      (< $X $Y) 
      (== $X $Y)))
</span><span class="ansi38-000082136">  :- dynamic(<=,3).

  <=(X, Y, A) :-
    ( u_assign([<, X, Y], B),
      B=C
    ),
    u_assign([==, X, Y], D),
    D=E,
    u_assign([or, C, E], A).

</span>

;; Define >=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,>=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: >= 
    (-> $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( >=(X,Y,Assign_Y) :-
%~                              u_assign([>,X,Y],Assign) ,
%~                              Assign=_125990 ,
%~                              u_assign([==,X,Y],Assign2) ,
%~                              Assign2=_126008 ,
%~                              u_assign([or,_125990,_126008],Assign_Y))]
%~ [convert(_50342),head_preconds_into_body((>=(X,Y,_49106):-((u_assign([>,X,Y],_50648),_50648=_50638),u_assign([==,X,Y],_50852),_50852=_50842),u_assign([or,_50638,_50842],_49106)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[>=,X,Y],[or,[>,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">  (= 
    (>= $X $Y) 
    (or 
      (> $X $Y) 
      (== $X $Y)))
</span><span class="ansi38-000082136">  :- dynamic(>=,3).

  >=(X, Y, A) :-
    ( u_assign([>, X, Y], B),
      B=C
    ),
    u_assign([==, X, Y], D),
    D=E,
    u_assign([or, C, E], A).

</span>

;; Define approximately equal
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,approxEq,[->,A,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: approxEq 
    (-> $A $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( approxEq(X,Y,Epsilon,Assign_ApproxEq_Epsilon) :-
%~                              u_assign([-,X,Y],Assign) ,
%~                              Assign=_272354 ,
%~                              u_assign([abs,_272354],Assign3) ,
%~                              Assign3=_272378 ,
%~                              u_assign([<=,_272378,Epsilon],Assign_ApproxEq_Epsilon))]
%~ [convert(_186114),head_preconds_into_body((approxEq(X,Y,Epsilon,_184808):-(((u_assign([-,X,Y],_186462),_186462=_186452),u_assign([abs,_186452],_186420)),_186420=_186410),u_assign([<=,_186410,Epsilon],_184808)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[approxEq,X,Y,Epsilon],[<=,[abs,[-,X,Y]],Epsilon])
</span><span class="ansi38-255165000">  (= 
    (approxEq $X $Y $Epsilon) 
    (<= 
      (abs 
        (- $X $Y)) $Epsilon))
</span><span class="ansi38-000082136">  :- dynamic(approxEq,4).

  approxEq(X, Y, Epsilon, A) :-
    ( u_assign([-, X, Y], B),
      B=C,
      u_assign([abs, C], D)
    ),
    D=E,
    u_assign([<=, E, Epsilon], A).

</span>

;; Define Nat
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Nat','Type'])
</span><span class="ansi38-255165000">  (: Nat Type)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Z','Nat'])
</span><span class="ansi38-255165000">  (: Z Nat)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'S',[->,'Nat','Nat']])
</span><span class="ansi38-255165000">  (: S 
    (-> Nat Nat))
</span>

;; Define cast functions between Nat and Number
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNumber,[->,'Number','Nat']])
</span><span class="ansi38-255165000">  (: fromNumber 
    (-> Number Nat))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( fromNumber(N,N) :-
%~                              u_assign([<=,N,0],Assign) ,
%~                              Assign=_496168 ,
%~                              u_assign([-,N,1],Assign2) ,
%~                              Assign2=_496210 ,
%~                              u_assign([fromNumber,_496210],Assign3) ,
%~                              Assign3=_496234 ,
%~                              u_assign(['S',_496234],Assign4) ,
%~                              Assign4=_496258 ,
%~                              u_assign([if,_496168,'Z',_496258],N))]
%~ [convert(_374012),head_preconds_into_body((fromNumber(N,_372846):-((u_assign([<=,N,0],_374318),_374318=_374308),((((u_assign([-,N,1],_374574),_374574=_374564),u_assign([fromNumber,_374564],_374532)),_374532=_374522),u_assign(['S',_374522],_374490)),_374490=_374480),u_assign([if,_374308,'Z',_374480],_372846)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNumber,N],[if,[<=,N,0],'Z',['S',[fromNumber,[-,N,1]]]])
</span><span class="ansi38-255165000">  (= 
    (fromNumber $N) 
    (if 
      (<= $N 0) Z 
      (S 
        (fromNumber 
          (- $N 1)))))
</span><span class="ansi38-000082136">  :- dynamic(fromNumber,2).

  fromNumber(N, A) :-
    ( u_assign([<=, N, 0], B),
      B=C
    ),
    ( ( u_assign([-, N, 1], D),
        D=E,
        u_assign([fromNumber, E], F)
      ),
      F=G,
      u_assign(['S', G], H)
    ),
    H=I,
    u_assign([if, C, 'Z', I], A).

</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNat,[->,'Nat','Number']])
</span><span class="ansi38-255165000">  (: fromNat 
    (-> Nat Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((fromNat('Z',0):-true))]
%~ [convert(_22800),head_preconds_into_body((fromNat('Z',0):-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,'Z'],0)
</span><span class="ansi38-255165000">  (= 
    (fromNat Z) 0)
</span><span class="ansi38-000082136">  :- dynamic(fromNat,2).

  fromNat('Z', 0).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( fromNat(FromNat,FromNat1) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=FromNat ,
%~                              u_assign([fromNat,K],Assign3) ,
%~                              [+,1,Assign3,FromNat1])]
%~ [convert(_67956),head_preconds_into_body((fromNat(_67002,_66722):-(u_assign(['S',K],_67012),_67012=_67002),u_assign([fromNat,K],_68280),[+,1,_68280,_66722]))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,['S',K]],[+,1,[fromNat,K]])
</span><span class="ansi38-255165000">  (= 
    (fromNat 
      (S $K)) 
    (+ 1 
      (fromNat $K)))
</span><span class="ansi38-000082136">  :- dynamic(fromNat,2).

  fromNat(A, B) :-
    u_assign(['S', K], C),
    C=A,
    u_assign([fromNat, K], D),
    [+, 1, D, B].

</span>

;; Define a generic less than operator, â©», for Nat.  < cannot be used
;; because it is a built-in, its type is hardwired and cannot be
;; overloaded.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Nat','Nat','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Nat Nat Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('â©»'(_,'Z',_167308):-_167308='False'))]
%~ [convert(_168500),head_preconds_into_body(('â©»'(_,'Z',_167308):-_167308='False'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',_,'Z'],'False')
</span><span class="ansi38-255165000">  (= 
    (â©» $_ Z) False)
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(_, 'Z', A) :-
    A='False'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'('Z',Z,True) :-
%~                              u_assign(['S',_],Assign) ,
%~                              Assign=Z ,
%~                              True='True')]
%~ [convert(_215490),head_preconds_into_body(('â©»'('Z',_214522,_214230):-(u_assign(['S',_],_214532),_214532=_214522),_214230='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»','Z',['S',_]],'True')
</span><span class="ansi38-255165000">  (= 
    (â©» Z 
      (S $_)) True)
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'('Z', A, B) :-
    u_assign(['S', _], C),
    C=A,
    B='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'(Â1,Â,Assign_Â2) :-
%~                              u_assign(['S',X],Assign) ,
%~                              Assign=Â1 ,
%~                              u_assign(['S',Y],Assign4) ,
%~                              Assign4=Â ,
%~                              u_assign(['â©»',X,Y],Assign_Â2))]
%~ [convert(_286532),head_preconds_into_body(('â©»'(_285416,_285550,_285136):-((u_assign(['S',X],_285426),_285426=_285416),u_assign(['S',Y],_285560),_285560=_285550),u_assign(['â©»',X,Y],_285136)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',['S',X],['S',Y]],['â©»',X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» 
      (S $X) 
      (S $Y)) 
    (â©» $X $Y))
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(A, B, C) :-
    ( u_assign(['S', X], D),
      D=A
    ),
    u_assign(['S', Y], E),
    E=B,
    u_assign(['â©»', X, Y], C).

</span>

;; Overload â©» for Number.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Number','Number','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Number Number Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'(X,Y,Assign_Â_Y) :-
%~                              u_assign([<,X,Y],Assign_Â_Y))]
%~ [convert(_384234),head_preconds_into_body(('â©»'(X,Y,_382998):-u_assign([<,X,Y],_382998)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',X,Y],[<,X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» $X $Y) 
    (< $X $Y))
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(X, Y, A) :-
    u_assign([<, X, Y], A).

</span>

;; Return the ceiling of a non negative number.  If the number is
;; negative it returns 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,ceil,[->,'Number','Number']])
</span><span class="ansi38-255165000">  (: ceil 
    (-> Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ceil(N,Assign_Ceil_N) :-
%~                              u_assign([fromNumber,N],Assign) ,
%~                              Assign=_515692 ,
%~                              u_assign([fromNat,_515692],Assign_Ceil_N))]
%~ [convert(_3550),head_preconds_into_body((ceil(N,_3514):-(u_assign([fromNumber,N],_3588),_3588=_3584),u_assign([fromNat,_3584],_3514)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[ceil,N],[fromNat,[fromNumber,N]])
</span><span class="ansi38-255165000">  (= 
    (ceil $N) 
    (fromNat 
      (fromNumber $N)))
</span><span class="ansi38-000082136">  :- dynamic(ceil,2).

  ceil(N, A) :-
    u_assign([fromNumber, N], B),
    B=C,
    u_assign([fromNat, C], A).

</span>

;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'number->bool',[->,'Number','Bool']])
</span><span class="ansi38-255165000">  (: number->bool 
    (-> Number Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'number->bool'(X,Number_c62_bool_X) :-
%~                              u_assign([<,0,X],Number_c62_bool_X))]
%~ [convert(_39100),head_preconds_into_body(('number->bool'(X,_37934):-u_assign([<,0,X],_37934)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['number->bool',X],[<,0,X])
</span><span class="ansi38-255165000">  (= 
    (number->bool $X) 
    (< 0 $X))
</span><span class="ansi38-000082136">  :- dynamic('number->bool',2).

  'number->bool'(X, A) :-
    u_assign([<, 0, X], A).

</span>

;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'bool->number',[->,'Bool','Number']])
</span><span class="ansi38-255165000">  (: bool->number 
    (-> Bool Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('bool->number'('False',0):-true))]
%~ [convert(_109588),head_preconds_into_body(('bool->number'('False',0):-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','False'],0)
</span><span class="ansi38-255165000">  (= 
    (bool->number False) 0)
</span><span class="ansi38-000082136">  :- dynamic('bool->number',2).

  'bool->number'('False', 0).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('bool->number'(_146160,1):-is_True(_146160)))]
%~ [convert(_146996),head_preconds_into_body(('bool->number'(_146160,1):-is_True(_146160)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','True'],1)
</span><span class="ansi38-255165000">  (= 
    (bool->number True) 1)
</span><span class="ansi38-000082136">  :- dynamic('bool->number',2).

  'bool->number'(A, 1) :-
    is_True(A).

</span>

;; Define a less than type.  Note that it is purposefully different
;; than â©» as it is a type, not an operator.  Inhabitants of (â x y)
;; are proofs that x â©» y == True.  For now â is only axiomatized for
;; Nat.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â\x8D\\x83\',[->,True,True,'Type']])
</span><span class="ansi38-255165000">  (: â 
    (-> $True $True Type))
</span>

;; Zero is always less than the successor of something
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['zero-lt-succ-axiom'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ['zero-lt-succ-axiom',Assign2] :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=_310614 ,
%~                              u_assign(['â\x8D\\x83\','Z',_310614],Assign1) ,
%~                              Assign1=_310644 ,
%~                              u_assign([:,'ZeroLTSucc',_310644],Assign2))]
%~ [convert(_211628),head_preconds_into_body((['zero-lt-succ-axiom',_209788]:-(((u_assign(['S',K],_212000),_212000=_211990),u_assign(['â\x8D\\x83\','Z',_211990],_211946)),_211946=_211936),u_assign([:,'ZeroLTSucc',_211936],_209788)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['zero-lt-succ-axiom'],[:,'ZeroLTSucc',['â\x8D\\x83\','Z',['S',K]]])
</span><span class="ansi38-255165000">  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (â Z 
        (S $K))))
</span><span class="ansi38-000082136">
  ['zero-lt-succ-axiom', A] :-
    ( u_assign(['S', K], B),
      B=C,
      u_assign(['â\u008D\u0083', 'Z', C], D)
    ),
    D=E,
    u_assign([:, 'ZeroLTSucc', E], A).

</span>

;; If x â y then (S x) â (S y)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['succ-monotonicity-rule'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ['succ-monotonicity-rule',Assign5] :-
%~                              u_assign(['â\x8D\\x83\',X,Y],Assign) ,
%~                              Assign=_510958 ,
%~                              u_assign(['S',X],Assign1) ,
%~                              Assign1=_510994 ,
%~                              u_assign(['S',Y],Assign2) ,
%~                              Assign2=_511012 ,
%~                              u_assign(['â\x8D\\x83\',_510994,_511012],Assign3) ,
%~                              Assign3=_511042 ,
%~                              u_assign([->,_510958,_511042],Assign4) ,
%~                              Assign4=_511072 ,
%~                              u_assign([:,'SuccMonotonicity',_511072],Assign5))]
%~ [convert(_350262),head_preconds_into_body((['succ-monotonicity-rule',_348422]:-((((u_assign(['â\x8D\\x83\',X,Y],_350622),_350622=_350612),(((u_assign(['S',X],_350868),_350868=_350858),u_assign(['S',Y],_351002),_351002=_350992),u_assign(['â\x8D\\x83\',_350858,_350992],_350826)),_350826=_350816),u_assign([->,_350612,_350816],_350580)),_350580=_350570),u_assign([:,'SuccMonotonicity',_350570],_348422)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['succ-monotonicity-rule'],[:,'SuccMonotonicity',[->,['â\x8D\\x83\',X,Y],['â\x8D\\x83\',['S',X],['S',Y]]]])
</span><span class="ansi38-255165000">  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (â $X $Y) 
        (â 
          (S $X) 
          (S $Y)))))
</span><span class="ansi38-000082136">
  ['succ-monotonicity-rule', A] :-
    ( ( u_assign(['â\u008D\u0083', X, Y], B),
        B=C
      ),
      ( ( u_assign(['S', X], D),
          D=E
        ),
        u_assign(['S', Y], F),
        F=G,
        u_assign(['â\u008D\u0083', E, G], H)
      ),
      H=I,
      u_assign([->, C, I], J)
    ),
    J=K,
    u_assign([:, 'SuccMonotonicity', K], A).

</span>

; Evaluation took 1420.24 ms.
<span class="ansi33"> &self

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,synthesize,[->,'Atom',[->,'Atom'],[->,'Atom'],'Nat','Atom']])
</span><span class="ansi38-255165000">  (: synthesize 
    (-> Atom 
      (-> Atom) 
      (-> Atom) Nat Atom))
</span>

;; Nullary rule (axiom)
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Depth,Query) :-
%~                              u_assign([Axiom],VAR_Query) ,
%~                              Query=VAR_Query)]
%~ [convert(_66562),head_preconds_into_body((synthesize(Query,Axiom,Rule,Depth,Query):-u_assign([Axiom],_66866),Query=_66866))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,Depth],[let,Query,[Axiom],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule $Depth) 
    (let $Query 
      ($Axiom) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, Depth, Query) :-
    u_assign([Axiom], A),
    Query=A.

</span>

;; Unary rule
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Rule,Query) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=Rule ,
%~                              u_assign([->,Premise,Conclusion],Assign5) ,
%~                              Assign5=_312738 ,
%~                              u_assign([:,Ructor,_312738],Assign_List) ,
%~                              [Rule]=Assign_List ,
%~                              u_assign([Ructor,Proof],Assign7) ,
%~                              Assign7=_312804 ,
%~                              u_assign([:,_312804,Conclusion],VAR_Query) ,
%~                              Query=VAR_Query ,
%~                              u_assign([:,Proof,Premise],Assign_List3) ,
%~                              [ synthesize,
%~                                [:,Proof,Premise], Axiom,Rule,K] =
%~                                Assign_List3)]
%~ [convert(_165450),head_preconds_into_body((synthesize(Query,Axiom,Rule,_164454,Query):-(u_assign(['S',K],_164464),_164464=_164454),(((u_assign([->,Premise,Conclusion],_166650),_166650=_166640),u_assign([:,Ructor,_166640],_166034)),[Rule]=_166034),(((u_assign([Ructor,Proof],_167706),_167706=_167696),u_assign([:,_167696,Conclusion],_167146)),Query=_167146),u_assign([:,Proof,Premise],_168256),[synthesize,[:,Proof,Premise],Axiom,Rule,K]=_168256))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,['S',K]],['let*',[[[:,Ructor,[->,Premise,Conclusion]],[Rule]],[[:,[Ructor,Proof],Conclusion],Query],[[:,Proof,Premise],[synthesize,[:,Proof,Premise],Axiom,Rule,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise $Conclusion)) 
          ($Rule)) 
        ( (: 
            ($Ructor $Proof) $Conclusion) $Query) 
        ( (: $Proof $Premise) 
          (synthesize 
            (: $Proof $Premise) $Axiom $Rule $K))) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, A, Query) :-
    u_assign(['S', K], B),
    B=A,
    ( u_assign([->, Premise, Conclusion], C),
      C=D,
      u_assign([:, Ructor, D], E)
    ),
    [Rule]=E,
    ( u_assign([Ructor, Proof], F),
      F=G,
      u_assign([:, G, Conclusion], H)
    ),
    Query=H,
    u_assign([:, Proof, Premise], I),
    [synthesize, [:, Proof, Premise], Axiom, Rule, K]=I.

</span>

;; Binary rule
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Rule,Query) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=Rule ,
%~                              u_assign( [->,Premise1,Premise2,Conclusion],
%~                                Assign6) ,
%~                              Assign6=_63778 ,
%~                              u_assign([:,Ructor,_63778],Assign_List) ,
%~                              [Rule]=Assign_List ,
%~                              u_assign([Ructor,Proof1,Proof2],Assign8) ,
%~                              Assign8=_63844 ,
%~                              u_assign([:,_63844,Conclusion],VAR_Query) ,
%~                              Query=VAR_Query ,
%~                              u_assign([:,Proof1,Premise1],Assign_List3) ,
%~                              [ synthesize,
%~                                [:,Proof1,Premise1], Axiom,Rule,K] =
%~                                Assign_List3 ,
%~                              u_assign([:,Proof2,Premise2],Assign_List4) ,
%~                              [ synthesize,
%~                                [:,Proof2,Premise2], Axiom,Rule,K] =
%~                                Assign_List4)]
%~ [convert(_3556),head_preconds_into_body((synthesize(Query,Axiom,Rule,_3506,Query):-(u_assign(['S',K],_3510),_3510=_3506),(((u_assign([->,Premise1,Premise2,Conclusion],_3612),_3612=_3608),u_assign([:,Ructor,_3608],_3580)),[Rule]=_3580),(((u_assign([Ructor,Proof1,Proof2],_3698),_3698=_3694),u_assign([:,_3694,Conclusion],_3672)),Query=_3672),(u_assign([:,Proof1,Premise1],_3764),[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]=_3764),u_assign([:,Proof2,Premise2],_3806),[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]=_3806))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,['S',K]],['let*',[[[:,Ructor,[->,Premise1,Premise2,Conclusion]],[Rule]],[[:,[Ructor,Proof1,Proof2],Conclusion],Query],[[:,Proof1,Premise1],[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]],[[:,Proof2,Premise2],[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise1 $Premise2 $Conclusion)) 
          ($Rule)) 
        ( (: 
            ($Ructor $Proof1 $Proof2) $Conclusion) $Query) 
        ( (: $Proof1 $Premise1) 
          (synthesize 
            (: $Proof1 $Premise1) $Axiom $Rule $K)) 
        ( (: $Proof2 $Premise2) 
          (synthesize 
            (: $Proof2 $Premise2) $Axiom $Rule $K))) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, A, Query) :-
    u_assign(['S', K], B),
    B=A,
    ( u_assign([->, Premise1, Premise2, Conclusion], C),
      C=D,
      u_assign([:, Ructor, D], E)
    ),
    [Rule]=E,
    ( u_assign([Ructor, Proof1, Proof2], F),
      F=G,
      u_assign([:, G, Conclusion], H)
    ),
    Query=H,
    u_assign([:, Proof1, Premise1], I),
    [synthesize, [:, Proof1, Premise1], Axiom, Rule, K]=I,
    u_assign([:, Proof2, Premise2], J),
    [synthesize, [:, Proof2, Premise2], Axiom, Rule, K]=J.

</span>

;; Trinary rule
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Rule,Query) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=Rule ,
%~                              u_assign(
%~                                 [ ->, Premise1,Premise2,
%~                                   Premise3,Conclusion],
%~                                 Assign7) ,
%~                              Assign7=_389800 ,
%~                              u_assign([:,Ructor,_389800],Assign_List) ,
%~                              [Rule]=Assign_List ,
%~                              u_assign( [Ructor,Proof1,Proof2,Proof3],
%~                                Assign9) ,
%~                              Assign9=_389866 ,
%~                              u_assign([:,_389866,Conclusion],VAR_Query) ,
%~                              Query=VAR_Query ,
%~                              u_assign([:,Proof1,Premise1],Assign_List3) ,
%~                              [ synthesize,
%~                                [:,Proof1,Premise1], Axiom,Rule,K] =
%~                                Assign_List3 ,
%~                              u_assign([:,Proof2,Premise2],Assign_List4) ,
%~                              [ synthesize,
%~                                [:,Proof2,Premise2], Axiom,Rule,K] =
%~                                Assign_List4 ,
%~                              u_assign([:,Proof3,Premise3],Assign_List5) ,
%~                              [ synthesize,
%~                                [:,Proof3,Premise3], Axiom,Rule,K] =
%~                                Assign_List5)]
%~ [convert(_176696),head_preconds_into_body((synthesize(Query,Axiom,Rule,_175700,Query):-(u_assign(['S',K],_175710),_175710=_175700),(((u_assign([->,Premise1,Premise2,Premise3,Conclusion],_177896),_177896=_177886),u_assign([:,Ructor,_177886],_177280)),[Rule]=_177280),(((u_assign([Ructor,Proof1,Proof2,Proof3],_179092),_179092=_179082),u_assign([:,_179082,Conclusion],_178532)),Query=_178532),(u_assign([:,Proof1,Premise1],_179782),[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]=_179782),(u_assign([:,Proof2,Premise2],_180756),[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]=_180756),u_assign([:,Proof3,Premise3],_181730),[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]=_181730))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,['S',K]],['let*',[[[:,Ructor,[->,Premise1,Premise2,Premise3,Conclusion]],[Rule]],[[:,[Ructor,Proof1,Proof2,Proof3],Conclusion],Query],[[:,Proof1,Premise1],[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]],[[:,Proof2,Premise2],[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]],[[:,Proof3,Premise3],[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise1 $Premise2 $Premise3 $Conclusion)) 
          ($Rule)) 
        ( (: 
            ($Ructor $Proof1 $Proof2 $Proof3) $Conclusion) $Query) 
        ( (: $Proof1 $Premise1) 
          (synthesize 
            (: $Proof1 $Premise1) $Axiom $Rule $K)) 
        ( (: $Proof2 $Premise2) 
          (synthesize 
            (: $Proof2 $Premise2) $Axiom $Rule $K)) 
        ( (: $Proof3 $Premise3) 
          (synthesize 
            (: $Proof3 $Premise3) $Axiom $Rule $K))) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, A, Query) :-
    u_assign(['S', K], B),
    B=A,
    ( u_assign([ ->,
                 Premise1,
                 Premise2,
                 Premise3,
                 Conclusion
               ],
               C),
      C=D,
      u_assign([:, Ructor, D], E)
    ),
    [Rule]=E,
    ( u_assign([Ructor, Proof1, Proof2, Proof3], F),
      F=G,
      u_assign([:, G, Conclusion], H)
    ),
    Query=H,
    u_assign([:, Proof1, Premise1], I),
    [synthesize, [:, Proof1, Premise1], Axiom, Rule, K]=I,
    u_assign([:, Proof2, Premise2], J),
    [synthesize, [:, Proof2, Premise2], Axiom, Rule, K]=J,
    u_assign([:, Proof3, Premise3], K),
    [synthesize, [:, Proof3, Premise3], Axiom, Rule, K]=K.

</span>

;; Quaternary rule
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Rule,Query) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=Rule ,
%~                              u_assign(
%~                                 [ ->, Premise1,Premise2,
%~                                   Premise3,Premise4,
%~                                   Conclusion],
%~                                 Assign8) ,
%~                              Assign8=_256482 ,
%~                              u_assign([:,Ructor,_256482],Assign_List) ,
%~                              [Rule]=Assign_List ,
%~                              u_assign(
%~                                 [ Ructor, Proof1,Proof2,Proof3,
%~                                   Proof4],
%~                                 Assign10) ,
%~                              Assign10=_256548 ,
%~                              u_assign([:,_256548,Conclusion],VAR_Query) ,
%~                              Query=VAR_Query ,
%~                              u_assign([:,Proof1,Premise1],Assign_List3) ,
%~                              [ synthesize,
%~                                [:,Proof1,Premise1], Axiom,Rule,K] =
%~                                Assign_List3 ,
%~                              u_assign([:,Proof2,Premise2],Assign_List4) ,
%~                              [ synthesize,
%~                                [:,Proof2,Premise2], Axiom,Rule,K] =
%~                                Assign_List4 ,
%~                              u_assign([:,Proof3,Premise3],Assign_List5) ,
%~                              [ synthesize,
%~                                [:,Proof3,Premise3], Axiom,Rule,K] =
%~                                Assign_List5 ,
%~                              u_assign([:,Proof4,Premise4],Assign_List6) ,
%~                              [ synthesize,
%~                                [:,Proof4,Premise4], Axiom,Rule,K] =
%~                                Assign_List6)]
%~ [convert(_15322),head_preconds_into_body((synthesize(Query,Axiom,Rule,_14326,Query):-(u_assign(['S',K],_14336),_14336=_14326),(((u_assign([->,Premise1,Premise2,Premise3,Premise4,Conclusion],_16522),_16522=_16512),u_assign([:,Ructor,_16512],_15906)),[Rule]=_15906),(((u_assign([Ructor,Proof1,Proof2,Proof3,Proof4],_17788),_17788=_17778),u_assign([:,_17778,Conclusion],_17228)),Query=_17228),(u_assign([:,Proof1,Premise1],_18548),[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]=_18548),(u_assign([:,Proof2,Premise2],_19522),[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]=_19522),(u_assign([:,Proof3,Premise3],_20496),[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]=_20496),u_assign([:,Proof4,Premise4],_21470),[synthesize,[:,Proof4,Premise4],Axiom,Rule,K]=_21470))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,['S',K]],['let*',[[[:,Ructor,[->,Premise1,Premise2,Premise3,Premise4,Conclusion]],[Rule]],[[:,[Ructor,Proof1,Proof2,Proof3,Proof4],Conclusion],Query],[[:,Proof1,Premise1],[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]],[[:,Proof2,Premise2],[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]],[[:,Proof3,Premise3],[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]],[[:,Proof4,Premise4],[synthesize,[:,Proof4,Premise4],Axiom,Rule,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise1 $Premise2 $Premise3 $Premise4 $Conclusion)) 
          ($Rule)) 
        ( (: 
            ($Ructor $Proof1 $Proof2 $Proof3 $Proof4) $Conclusion) $Query) 
        ( (: $Proof1 $Premise1) 
          (synthesize 
            (: $Proof1 $Premise1) $Axiom $Rule $K)) 
        ( (: $Proof2 $Premise2) 
          (synthesize 
            (: $Proof2 $Premise2) $Axiom $Rule $K)) 
        ( (: $Proof3 $Premise3) 
          (synthesize 
            (: $Proof3 $Premise3) $Axiom $Rule $K)) 
        ( (: $Proof4 $Premise4) 
          (synthesize 
            (: $Proof4 $Premise4) $Axiom $Rule $K))) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, A, Query) :-
    u_assign(['S', K], B),
    B=A,
    ( u_assign([ ->,
                 Premise1,
                 Premise2,
                 Premise3,
                 Premise4,
                 Conclusion
               ],
               C),
      C=D,
      u_assign([:, Ructor, D], E)
    ),
    [Rule]=E,
    ( u_assign([ Ructor,
                 Proof1,
                 Proof2,
                 Proof3,
                 Proof4
               ],
               F),
      F=G,
      u_assign([:, G, Conclusion], H)
    ),
    Query=H,
    u_assign([:, Proof1, Premise1], I),
    [synthesize, [:, Proof1, Premise1], Axiom, Rule, K]=I,
    u_assign([:, Proof2, Premise2], J),
    [synthesize, [:, Proof2, Premise2], Axiom, Rule, K]=J,
    u_assign([:, Proof3, Premise3], K),
    [synthesize, [:, Proof3, Premise3], Axiom, Rule, K]=K,
    u_assign([:, Proof4, Premise4], L),
    [synthesize, [:, Proof4, Premise4], Axiom, Rule, K]=L.

</span>

;; Quintenary rule
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Rule,Query) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=Rule ,
%~                              u_assign(
%~                                 [ ->, Premise1,Premise2,
%~                                   Premise3,Premise4,
%~                                   Premise5,Conclusion],
%~                                 Assign9) ,
%~                              Assign9=_179220 ,
%~                              u_assign([:,Ructor,_179220],Assign_List) ,
%~                              [Rule]=Assign_List ,
%~                              u_assign(
%~                                 [ Ructor, Proof1,Proof2,Proof3,
%~                                   Proof4,Proof5],
%~                                 Assign11) ,
%~                              Assign11=_179286 ,
%~                              u_assign([:,_179286,Conclusion],VAR_Query) ,
%~                              Query=VAR_Query ,
%~                              u_assign([:,Proof1,Premise1],Assign_List3) ,
%~                              [ synthesize,
%~                                [:,Proof1,Premise1], Axiom,Rule,K] =
%~                                Assign_List3 ,
%~                              u_assign([:,Proof2,Premise2],Assign_List4) ,
%~                              [ synthesize,
%~                                [:,Proof2,Premise2], Axiom,Rule,K] =
%~                                Assign_List4 ,
%~                              u_assign([:,Proof3,Premise3],Assign_List5) ,
%~                              [ synthesize,
%~                                [:,Proof3,Premise3], Axiom,Rule,K] =
%~                                Assign_List5 ,
%~                              u_assign([:,Proof4,Premise4],Assign_List6) ,
%~                              [ synthesize,
%~                                [:,Proof4,Premise4], Axiom,Rule,K] =
%~                                Assign_List6 ,
%~                              u_assign([:,Proof5,Premise5],Assign_List7) ,
%~                              [ synthesize,
%~                                [:,Proof5,Premise5], Axiom,Rule,K] =
%~                                Assign_List7)]
%~ [convert(_3932),head_preconds_into_body((synthesize(Query,Axiom,Rule,_3882,Query):-(u_assign(['S',K],_3886),_3886=_3882),(((u_assign([->,Premise1,Premise2,Premise3,Premise4,Premise5,Conclusion],_3988),_3988=_3984),u_assign([:,Ructor,_3984],_3956)),[Rule]=_3956),(((u_assign([Ructor,Proof1,Proof2,Proof3,Proof4,Proof5],_4092),_4092=_4088),u_assign([:,_4088,Conclusion],_4066)),Query=_4066),(u_assign([:,Proof1,Premise1],_4176),[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]=_4176),(u_assign([:,Proof2,Premise2],_4218),[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]=_4218),(u_assign([:,Proof3,Premise3],_4260),[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]=_4260),(u_assign([:,Proof4,Premise4],_4302),[synthesize,[:,Proof4,Premise4],Axiom,Rule,K]=_4302),u_assign([:,Proof5,Premise5],_4344),[synthesize,[:,Proof5,Premise5],Axiom,Rule,K]=_4344))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,['S',K]],['let*',[[[:,Ructor,[->,Premise1,Premise2,Premise3,Premise4,Premise5,Conclusion]],[Rule]],[[:,[Ructor,Proof1,Proof2,Proof3,Proof4,Proof5],Conclusion],Query],[[:,Proof1,Premise1],[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]],[[:,Proof2,Premise2],[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]],[[:,Proof3,Premise3],[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]],[[:,Proof4,Premise4],[synthesize,[:,Proof4,Premise4],Axiom,Rule,K]],[[:,Proof5,Premise5],[synthesize,[:,Proof5,Premise5],Axiom,Rule,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise1 $Premise2 $Premise3 $Premise4 $Premise5 $Conclusion)) 
          ($Rule)) 
        ( (: 
            ($Ructor $Proof1 $Proof2 $Proof3 $Proof4 $Proof5) $Conclusion) $Query) 
        ( (: $Proof1 $Premise1) 
          (synthesize 
            (: $Proof1 $Premise1) $Axiom $Rule $K)) 
        ( (: $Proof2 $Premise2) 
          (synthesize 
            (: $Proof2 $Premise2) $Axiom $Rule $K)) 
        ( (: $Proof3 $Premise3) 
          (synthesize 
            (: $Proof3 $Premise3) $Axiom $Rule $K)) 
        ( (: $Proof4 $Premise4) 
          (synthesize 
            (: $Proof4 $Premise4) $Axiom $Rule $K)) 
        ( (: $Proof5 $Premise5) 
          (synthesize 
            (: $Proof5 $Premise5) $Axiom $Rule $K))) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, A, Query) :-
    u_assign(['S', K], B),
    B=A,
    ( u_assign([ ->,
                 Premise1,
                 Premise2,
                 Premise3,
                 Premise4,
                 Premise5,
                 Conclusion
               ],
               C),
      C=D,
      u_assign([:, Ructor, D], E)
    ),
    [Rule]=E,
    ( u_assign([ Ructor,
                 Proof1,
                 Proof2,
                 Proof3,
                 Proof4,
                 Proof5
               ],
               F),
      F=G,
      u_assign([:, G, Conclusion], H)
    ),
    Query=H,
    u_assign([:, Proof1, Premise1], I),
    [synthesize, [:, Proof1, Premise1], Axiom, Rule, K]=I,
    u_assign([:, Proof2, Premise2], J),
    [synthesize, [:, Proof2, Premise2], Axiom, Rule, K]=J,
    u_assign([:, Proof3, Premise3], K),
    [synthesize, [:, Proof3, Premise3], Axiom, Rule, K]=K,
    u_assign([:, Proof4, Premise4], L),
    [synthesize, [:, Proof4, Premise4], Axiom, Rule, K]=L,
    u_assign([:, Proof5, Premise5], M),
    [synthesize, [:, Proof5, Premise5], Axiom, Rule, K]=M.

</span>

; Evaluation took 2.73 seconds.
<span class="ansi33"> &self

</span><span class="ansi38-000068000">!(import! &self "../common/Record.metta")

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&self', '../common/Record.metta'], A).

</span>;; Knowledge base
;; Given a function call, produce records of that function call.
;; There can be multiple records with only one call due to the
;; non-determinism of MeTTa.  Each record is represented by (â· f x y)
;; which can be read as
;;
;; "under f, the image of x is y"
;;
;; It was chosen because it is described as IMAGE OF in UTF-8.  It is
;; the MeTTa equivalent of ExecutionLink in Atomese.  The character â·
;; has description: IMAGE OF, hexadecimal code: 0x22B7, unicode-math
;; code: \imageof and latex code: \multimapdotbothB.
%~ [ convert(Convert),
%~   head_preconds_into_body( record(False,False,Assign_Record) :-
%~                              u_assign([Arg],Assign) ,
%~                              Assign=False ,
%~                              u_assign([False,Arg],Assign3) ,
%~                              Assign3=_447850 ,
%~                              u_assign(['â\x8A\·',False,Arg,_447850],Assign_Record))]
%~ [convert(_362186),head_preconds_into_body((record(False,_361244,_360908):-(u_assign([Arg],_361254),_361254=_361244),(u_assign([False,Arg],_362604),_362604=_362594),u_assign(['â\x8A\·',False,Arg,_362594],_360908)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[record,False,[Arg]],['â\x8A\·',False,Arg,[False,Arg]])
</span><span class="ansi38-255165000">  (= 
    (record $False 
      ($Arg)) 
    (â· $False $Arg 
      ($False $Arg)))
</span><span class="ansi38-000082136">  :- dynamic(record,3).

  record(False, A, B) :-
    u_assign([Arg], C),
    C=A,
    u_assign([False, Arg], D),
    D=E,
    u_assign(['â\u008A·', False, Arg, E], B).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( record(False,False,Assign_Record) :-
%~                              u_assign([Arg1,Arg2],Assign) ,
%~                              Assign=False ,
%~                              u_assign([Arg1,Arg2],Assign3) ,
%~                              Assign3=_68226 ,
%~                              u_assign([False,Arg1,Arg2],Assign4) ,
%~                              Assign4=_68244 ,
%~                              u_assign(['â\x8A\·',False,_68226,_68244],Assign_Record))]
%~ [convert(_3210),head_preconds_into_body((record(False,_3160,_3130):-(u_assign([Arg1,Arg2],_3164),_3164=_3160),((u_assign([Arg1,Arg2],_3254),_3254=_3250),u_assign([False,Arg1,Arg2],_3298),_3298=_3294),u_assign(['â\x8A\·',False,_3250,_3294],_3130)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[record,False,[Arg1,Arg2]],['â\x8A\·',False,[Arg1,Arg2],[False,Arg1,Arg2]])
</span><span class="ansi38-255165000">  (= 
    (record $False 
      ($Arg1 $Arg2)) 
    (â· $False 
      ($Arg1 $Arg2) 
      ($False $Arg1 $Arg2)))
</span><span class="ansi38-000082136">  :- dynamic(record,3).

  record(False, A, B) :-
    u_assign([Arg1, Arg2], C),
    C=A,
    ( u_assign([Arg1, Arg2], D),
      D=E
    ),
    u_assign([False, Arg1, Arg2], F),
    F=G,
    u_assign(['â\u008A·', False, E, G], B).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( record(False,False,Assign_Record) :-
%~                              u_assign([Arg1,Arg2,Arg3],Assign) ,
%~                              Assign=False ,
%~                              u_assign([Arg1,Arg2,Arg3],Assign3) ,
%~                              Assign3=_214186 ,
%~                              u_assign( [False,Arg1,Arg2,Arg3],
%~                                Assign4) ,
%~                              Assign4=_214204 ,
%~                              u_assign(['â\x8A\·',False,_214186,_214204],Assign_Record))]
%~ [convert(_104096),head_preconds_into_body((record(False,_103014,_102678):-(u_assign([Arg1,Arg2,Arg3],_103024),_103024=_103014),((u_assign([Arg1,Arg2,Arg3],_104458),_104458=_104448),u_assign([False,Arg1,Arg2,Arg3],_104706),_104706=_104696),u_assign(['â\x8A\·',False,_104448,_104696],_102678)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[record,False,[Arg1,Arg2,Arg3]],['â\x8A\·',False,[Arg1,Arg2,Arg3],[False,Arg1,Arg2,Arg3]])
</span><span class="ansi38-255165000">  (= 
    (record $False 
      ($Arg1 $Arg2 $Arg3)) 
    (â· $False 
      ($Arg1 $Arg2 $Arg3) 
      ($False $Arg1 $Arg2 $Arg3)))
</span><span class="ansi38-000082136">  :- dynamic(record,3).

  record(False, A, B) :-
    u_assign([Arg1, Arg2, Arg3], C),
    C=A,
    ( u_assign([Arg1, Arg2, Arg3], D),
      D=E
    ),
    u_assign([False, Arg1, Arg2, Arg3], F),
    F=G,
    u_assign(['â\u008A·', False, E, G], B).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( record(False,False,Assign_Record) :-
%~                              u_assign([Arg1,Arg2,Arg3,Arg4],Assign) ,
%~                              Assign=False ,
%~                              u_assign( [Arg1,Arg2,Arg3,Arg4],
%~                                Assign3) ,
%~                              Assign3=_383320 ,
%~                              u_assign(
%~                                 [ False, Arg1,Arg2,Arg3,
%~                                   Arg4],
%~                                 Assign4) ,
%~                              Assign4=_383338 ,
%~                              u_assign(['â\x8A\·',False,_383320,_383338],Assign_Record))]
%~ [convert(_261072),head_preconds_into_body((record(False,_259920,_259584):-(u_assign([Arg1,Arg2,Arg3,Arg4],_259930),_259930=_259920),((u_assign([Arg1,Arg2,Arg3,Arg4],_261434),_261434=_261424),u_assign([False,Arg1,Arg2,Arg3,Arg4],_261752),_261752=_261742),u_assign(['â\x8A\·',False,_261424,_261742],_259584)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[record,False,[Arg1,Arg2,Arg3,Arg4]],['â\x8A\·',False,[Arg1,Arg2,Arg3,Arg4],[False,Arg1,Arg2,Arg3,Arg4]])
</span><span class="ansi38-255165000">  (= 
    (record $False 
      ($Arg1 $Arg2 $Arg3 $Arg4)) 
    (â· $False 
      ($Arg1 $Arg2 $Arg3 $Arg4) 
      ($False $Arg1 $Arg2 $Arg3 $Arg4)))
</span><span class="ansi38-000082136">  :- dynamic(record,3).

  record(False, A, B) :-
    u_assign([Arg1, Arg2, Arg3, Arg4], C),
    C=A,
    ( u_assign([Arg1, Arg2, Arg3, Arg4], D),
      D=E
    ),
    u_assign([False, Arg1, Arg2, Arg3, Arg4],
             F),
    F=G,
    u_assign(['â\u008A·', False, E, G], B).

</span>

; Evaluation took 402.60 ms.
<span class="ansi33"> &self

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,kb,[->,'Atom']])
</span><span class="ansi38-255165000">  (: kb 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( [kb,_171188] :-
%~                              ( ( u_assign([->,'Number','String'],Assign)  ,
%~                                  Assign=VAR_Assign ,
%~                                  u_assign([:,f,VAR_Assign],Assign1) ,
%~                                  Assign1=VAR_Assign1)  ;
%~                                ( u_assign([->,'String','Bool'],Assign2)  ,
%~                                  Assign2=VAR_Assign2 ,
%~                                  u_assign([:,g,VAR_Assign2],Assign3) ,
%~                                  Assign3=VAR_Assign1) ;
%~                                ( u_assign([->,'Bool','Number'],Assign4)  ,
%~                                  Assign4=VAR_Assign4 ,
%~                                  u_assign([:,h,VAR_Assign4],Assign5) ,
%~                                  Assign5=VAR_Assign1) ;
%~                                ( u_assign([->,'String','Number','Bool'],Assign6)  ,
%~                                  Assign6=VAR_Assign6 ,
%~                                  u_assign([:,i,VAR_Assign6],Assign7) ,
%~                                  Assign7=VAR_Assign1)))]
%~ [convert(_2778),head_preconds_into_body(([kb,_2754]:-((u_assign([->,'Number','String'],_2824),_2824=_2820),u_assign([:,f,_2820],_2792)),_2792=_2754;((u_assign([->,'String','Bool'],_2912),_2912=_2908),u_assign([:,g,_2908],_2880)),_2880=_2754;((u_assign([->,'Bool','Number'],_3000),_3000=_2996),u_assign([:,h,_2996],_2968)),_2968=_2754;((u_assign([->,'String','Number','Bool'],_3088),_3088=_3084),u_assign([:,i,_3084],_3056)),_3056=_2754))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[kb],[superpose,[[:,f,[->,'Number','String']],[:,g,[->,'String','Bool']],[:,h,[->,'Bool','Number']],[:,i,[->,'String','Number','Bool']]]])
</span><span class="ansi38-255165000">  (= 
    (kb) 
    (superpose 
      ( (: f 
          (-> Number String)) 
        (: g 
          (-> String Bool)) 
        (: h 
          (-> Bool Number)) 
        (: i 
          (-> String Number Bool)))))
</span><span class="ansi38-000082136">
  [kb, A] :-
    (   ( u_assign([->, 'Number', 'String'], B),
          B=C
        ),
        u_assign([:, f, C], D),
        D=A
    ;   ( u_assign([->, 'String', 'Bool'], E),
          E=F
        ),
        u_assign([:, g, F], G),
        G=A
    ;   ( u_assign([->, 'Bool', 'Number'], H),
          H=I
        ),
        u_assign([:, h, I], J),
        J=A
    ;   ( u_assign([->, 'String', 'Number', 'Bool'], K),
          K=L
        ),
        u_assign([:, i, L], M),
        M=A
    ).

</span>

;; Rule base
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,rb,[->,'Atom']])
</span><span class="ansi38-255165000">  (: rb 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( [rb,_54488] :-
%~                                ((
%~                                 (( u_assign([->,B,C],Assign)  ,
%~                                    Assign=VAR_Assign ,
%~                                    u_assign([->,A,B],Assign1) ,
%~                                    Assign1=VAR_Assign1 ,
%~                                    u_assign([->,A,C],Assign2) ,
%~                                    Assign2=VAR_Assign2 ,
%~                                    u_assign(
%~                                       [ :, ->,VAR_Assign,VAR_Assign1,
%~                                         VAR_Assign2],
%~                                       Assign3) ,
%~                                    Assign3=VAR_Assign3));
%~                                 (( u_assign([->,C,D],Assign4)  ,
%~                                    Assign4=VAR_Assign4 ,
%~                                    u_assign([->,A,B,C],Assign5) ,
%~                                    Assign5=VAR_Assign5 ,
%~                                    u_assign([->,A,B,D],Assign6) ,
%~                                    Assign6=VAR_Assign6 ,
%~                                    u_assign( [->,VAR_Assign4,VAR_Assign5,VAR_Assign6],
%~                                      Assign7) ,
%~                                    Assign7=VAR_Assign7 ,
%~                                    u_assign([:,.:,VAR_Assign7],Assign8) ,
%~                                    Assign8=VAR_Assign3))  )))]
%~ [convert(_2840),head_preconds_into_body(([rb,_2816]:-(((u_assign([->,B,C],_2886),_2886=_2882),(u_assign([->,A,B],_2936),_2936=_2932),u_assign([->,A,C],_2986),_2986=_2982),u_assign([:,->,_2882,_2932,_2982],_2854)),_2854=_2816;(((((u_assign([->,C,D],_3112),_3112=_3108),(u_assign([->,A,B,C],_3162),_3162=_3158),u_assign([->,A,B,D],_3218),_3218=_3214),u_assign([->,_3108,_3158,_3214],_3086)),_3086=_3082),u_assign([:,.:,_3082],_3054)),_3054=_2816))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[rb],[superpose,[[:,->,[->,B,C],[->,A,B],[->,A,C]],[:,.:,[->,[->,C,D],[->,A,B,C],[->,A,B,D]]]]])
</span><span class="ansi38-255165000">  (= 
    (rb) 
    (superpose 
      ( (: -> 
          (-> $B $C) 
          (-> $A $B) 
          (-> $A $C)) 
        (: .: 
          (-> 
            (-> $C $D) 
            (-> $A $B $C) 
            (-> $A $B $D))))))
</span><span class="ansi38-000082136">
  [rb, A] :-
    (   ( u_assign([->, B, C], B),
          B=C,
          u_assign([->, A, B], D),
          D=E,
          u_assign([->, A, C], F),
          F=G
        ),
        u_assign([:, ->, C, E, G], H),
        H=A
    ;   ( ( u_assign([->, C, D], I),
            I=J,
            u_assign([->, A, B, C], K),
            K=L,
            u_assign([->, A, B, D], M),
            M=N
          ),
          u_assign([->, J, L, N], O),
          O=P
        ),
        u_assign([:, .:, P], Q),
        Q=A
    ).

</span>

; Function composition
; Blackbird (generalized composition)
;; Test program synthesizer
; Query for any function composition of depth 0.
<span class="ansi38-000068000">!(record synthesize ((: $Term $Type) kb rb Z))

</span><span class="ansi38-017068017">exec(A) :-
    ( ( true,
        u_assign([:, Term, Type], B),
        B=C
      ),
      true,
      u_assign([C, kb, rb, 'Z'], D)
    ),
    D=E,
    u_assign([record, synthesize, E], A).

</span>; Evaluation took 5.62 ms.
<span class="ansi33">  (â· synthesize 
    ( (: $_207940 $_208252) kb rb Z) 
    (synthesize 
      (: $_207940 $_208252) kb rb Z))

</span>; (: f (-> Number String)), (: g (-> String Bool)), (: h (-> Bool Number)), (: i (-> String Number Bool))
; Query for functions from Number to String at depth 0.
<span class="ansi38-000068000">!(record synthesize ((: $Term (-> Number String)) kb rb Z))

</span><span class="ansi38-017068017">exec(A) :-
    ( ( ( true,
          u_assign([->, 'Number', 'String'], B),
          B=C
        ),
        u_assign([:, Term, C], D),
        D=E
      ),
      true,
      u_assign([E, kb, rb, 'Z'], F)
    ),
    F=G,
    u_assign([record, synthesize, G], A).

</span>; Evaluation took 3.29 ms.
<span class="ansi33">  (â· synthesize 
    ( (: f 
        (-> Number String)) kb rb Z) 
    (: f 
      (-> Number String)))
</span><span class="ansi32">['Term'=f]
</span>

; (: f (-> Number String))
; Query for functions of depth 1, from String and Number to Number.
<span class="ansi38-000068000">!(record synthesize ((: $Term (-> String Number Number)) kb rb (S Z)))

</span><span class="ansi38-017068017">exec(A) :-
    ( ( ( true,
          u_assign([->, 'String', 'Number', 'Number'], B),
          B=C
        ),
        u_assign([:, Term, C], D),
        D=E
      ),
      ( true,
        u_assign(['S', 'Z'], F)
      ),
      F=G,
      u_assign([E, kb, rb, G], H)
    ),
    H=I,
    u_assign([record, synthesize, I], A).

</span>; Evaluation took 20.76 ms.
<span class="ansi33">  (â· synthesize 
    ( (: $_373848 
        (-> String Number Number)) kb rb 
      (S Z)) 
    (synthesize 
      (: $_373848 
        (-> String Number Number)) kb rb 
      (S Z)))

</span>; (: (.: h i) (-> String Number Number)))
; Queries for ANY function from Number to Bool of at most depth 1.
<span class="ansi38-000068000">!(record synthesize ((: $Term (-> Number Bool)) kb rb (S Z)))

</span><span class="ansi38-017068017">exec(A) :-
    ( ( ( true,
          u_assign([->, 'Number', 'Bool'], B),
          B=C
        ),
        u_assign([:, Term, C], D),
        D=E
      ),
      ( true,
        u_assign(['S', 'Z'], F)
      ),
      F=G,
      u_assign([E, kb, rb, G], H)
    ),
    H=I,
    u_assign([record, synthesize, I], A).

</span>; Evaluation took 21.02 ms.
<span class="ansi33">  (â· synthesize 
    ( (: $_43688 
        (-> Number Bool)) kb rb 
      (S Z)) 
    (synthesize 
      (: $_43688 
        (-> Number Bool)) kb rb 
      (S Z)))

</span>; (: (. g f) (-> Number Bool))
; Queries for the specific `(.g f)` composition, checking if it goes from Number to Bool af depth 1.
<span class="ansi38-000068000">!(record synthesize ((: (. g f) (-> Number Bool)) kb rb (S Z)))

</span><span class="ansi38-017068017">exec(A) :-
    ( ( ( ( true,
            u_assign(['.', g, f], B)
          ),
          B=C,
          true,
          u_assign([->, 'Number', 'Bool'], D),
          D=E
        ),
        u_assign([:, C, E], F),
        F=G
      ),
      ( true,
        u_assign(['S', 'Z'], H)
      ),
      H=I,
      u_assign([G, kb, rb, I], J)
    ),
    J=K,
    u_assign([record, synthesize, K], A).

</span>; Evaluation took 21.89 ms.
<span class="ansi33">  (â· synthesize 
    ( (: 
        (. g f) 
        (-> Number Bool)) kb rb 
      (S Z)) 
    (synthesize 
      (: 
        (. g f) 
        (-> Number Bool)) kb rb 
      (S Z)))

</span>; (: (. g f) (-> Number Bool))
; Type inference for `(. g f)`
<span class="ansi38-000068000">!(record synthesize ((: (. g f) $Type) kb rb (S Z)))

</span><span class="ansi38-017068017">exec(A) :-
    ( ( ( ( true,
            u_assign(['.', g, f], B)
          ),
          B=C,
          true
        ),
        u_assign([:, C, Type], D),
        D=E
      ),
      ( true,
        u_assign(['S', 'Z'], F)
      ),
      F=G,
      u_assign([E, kb, rb, G], H)
    ),
    H=I,
    u_assign([record, synthesize, I], A).

</span>; Evaluation took 21.75 ms.
<span class="ansi33">  (â· synthesize 
    ( (: 
        (. g f) $_7142) kb rb 
      (S Z)) 
    (synthesize 
      (: 
        (. g f) $_7142) kb rb 
      (S Z)))

</span>; (: (. g f) (-> Number Bool))
; Query for any function composition of at most depth 1.
<span class="ansi38-000068000">!(record synthesize ((: $Term $Type) kb rb (S Z)))

</span><span class="ansi38-017068017">exec(A) :-
    ( ( true,
        u_assign([:, Term, Type], B),
        B=C
      ),
      ( true,
        u_assign(['S', 'Z'], D)
      ),
      D=E,
      u_assign([C, kb, rb, E], F)
    ),
    F=G,
    u_assign([record, synthesize, G], A).

</span>; Evaluation took 20.21 ms.
<span class="ansi33">  (â· synthesize 
    ( (: $_95308 $_95620) kb rb 
      (S Z)) 
    (synthesize 
      (: $_95308 $_95620) kb rb 
      (S Z)))

</span>; (: f (-> Number String)), ..., (: (. f h) (-> Bool String)), ...
; Input type inference for `(. (. g f) h)`, at depth 2
<span class="ansi38-000068000">!(record synthesize ((: (. (. g f) h) (-> $In Bool)) kb rb (fromNumber 2)))

</span><span class="ansi38-017068017">exec(A) :-
    ( ( ( ( ( true,
              u_assign(['.', g, f], B),
              B=C
            ),
            true,
            u_assign(['.', C, h], D)
          ),
          D=E,
          true,
          u_assign([->, In, 'Bool'], F),
          F=G
        ),
        u_assign([:, E, G], H),
        H=I
      ),
      ( true,
        u_assign([fromNumber, 2], J)
      ),
      J=K,
      u_assign([I, kb, rb, K], L)
    ),
    L=M,
    u_assign([record, synthesize, M], A).

</span>; Evaluation took 35.03 ms.
<span class="ansi33">  (â· synthesize 
    ( (: 
        (. 
          (. g f) h) 
        (-> $_5540 Bool)) kb rb 
      (fromNumber 2)) 
    (synthesize 
      (: 
        (. 
          (. g f) h) 
        (-> $_5540 Bool)) kb rb 
      (fromNumber 2)))

</span>; (: (. (. g f) h) (-> Bool Bool))
; Query for any function which can be composed with `h`, with any type signature, at depth 3
<span class="ansi38-000068000">!(record synthesize ((: (. $G h) $Type) kb rb (fromNumber 3)))

</span><span class="ansi38-017068017">exec(A) :-
    ( ( ( ( true,
            u_assign(['.', G, h], B)
          ),
          B=C,
          true
        ),
        u_assign([:, C, Type], D),
        D=E
      ),
      ( true,
        u_assign([fromNumber, 3], F)
      ),
      F=G,
      u_assign([E, kb, rb, G], H)
    ),
    H=I,
    u_assign([record, synthesize, I], A).

</span>; Evaluation took 50.57 ms.
<span class="ansi33">  (â· synthesize 
    ( (: 
        (. $_3946 h) $_3970) kb rb 
      (S 
        (S 
          (S Z)))) 
    (synthesize 
      (: 
        (. $_3946 h) $_3970) kb rb 
      (S 
        (S 
          (S Z)))))

</span>; Long list
; Query for any function which can be composed with `h`, taking a `Number` and returning any type, at depth 3
<span class="ansi38-000068000">!(record synthesize ((: (. $G h) (-> Number $Out)) kb rb (fromNumber 3)))

</span><span class="ansi38-017068017">exec(A) :-
    ( ( ( ( true,
            u_assign(['.', G, h], B)
          ),
          B=C,
          true,
          u_assign([->, 'Number', Out], D),
          D=E
        ),
        u_assign([:, C, E], F),
        F=G
      ),
      ( true,
        u_assign([fromNumber, 3], H)
      ),
      H=I,
      u_assign([G, kb, rb, I], J)
    ),
    J=K,
    u_assign([record, synthesize, K], A).

</span>; Evaluation took 47.65 ms.
<span class="ansi33">  (â· synthesize 
    ( (: 
        (. $_4366 h) 
        (-> Number $_4408)) kb rb 
      (S 
        (S 
          (S Z)))) 
    (synthesize 
      (: 
        (. $_4366 h) 
        (-> Number $_4408)) kb rb 
      (S 
        (S 
          (S Z)))))

</span>; No answer, since `h` doesn't take Number
; Query for any function which can be composed with `g` and take any input type and return String, at depth 3
<span class="ansi38-000068000">!(record synthesize ((: (. g $False) (-> $In String)) kb rb (fromNumber 3)))

</span><span class="ansi38-017068017">exec(A) :-
    ( ( ( ( true,
            u_assign(['.', g, False], B)
          ),
          B=C,
          true,
          u_assign([->, In, 'String'], D),
          D=E
        ),
        u_assign([:, C, E], F),
        F=G
      ),
      ( true,
        u_assign([fromNumber, 3], H)
      ),
      H=I,
      u_assign([G, kb, rb, I], J)
    ),
    J=K,
    u_assign([record, synthesize, K], A).

</span>; Evaluation took 48.79 ms.
<span class="ansi33">  (â· synthesize 
    ( (: 
        (. g $_4958) 
        (-> $_4988 String)) kb rb 
      (S 
        (S 
          (S Z)))) 
    (synthesize 
      (: 
        (. g $_4958) 
        (-> $_4988 String)) kb rb 
      (S 
        (S 
          (S Z)))))

</span>; No answer, since `g` doesn't return string
; Query for any function which can be composed with `g`, taking any input type and return Bool, at depth 3
<span class="ansi38-000068000">!(record synthesize ((: (. g $False) (-> $In Bool)) kb rb (fromNumber 3)))

</span><span class="ansi38-017068017">exec(A) :-
    ( ( ( ( true,
            u_assign(['.', g, False], B)
          ),
          B=C,
          true,
          u_assign([->, In, 'Bool'], D),
          D=E
        ),
        u_assign([:, C, E], F),
        F=G
      ),
      ( true,
        u_assign([fromNumber, 3], H)
      ),
      H=I,
      u_assign([G, kb, rb, I], J)
    ),
    J=K,
    u_assign([record, synthesize, K], A).

</span>; Evaluation took 48.22 ms.
<span class="ansi33">  (â· synthesize 
    ( (: 
        (. g $_5418) 
        (-> $_5448 Bool)) kb rb 
      (S 
        (S 
          (S Z)))) 
    (synthesize 
      (: 
        (. g $_5418) 
        (-> $_5448 Bool)) kb rb 
      (S 
        (S 
          (S Z)))))

</span>; (: (. g f) (-> Number Bool)), (: (. g (. f h)) (-> Bool Bool)), (: (. g (. f (. h g))) (-> String Bool))
; Query for any function composition of at most depth 4
<span class="ansi38-000068000">!(record synthesize ((: $Term $Type) kb rb (fromNumber 4)))

</span><span class="ansi38-017068017">exec(A) :-
    ( ( true,
        u_assign([:, Term, Type], B),
        B=C
      ),
      ( true,
        u_assign([fromNumber, 4], D)
      ),
      D=E,
      u_assign([C, kb, rb, E], F)
    ),
    F=G,
    u_assign([record, synthesize, G], A).

</span>; Evaluation took 66.55 ms.
<span class="ansi33">  (â· synthesize 
    ( (: $_5796 $_5814) kb rb 
      (S 
        (S 
          (S 
            (S Z))))) 
    (synthesize 
      (: $_5796 $_5814) kb rb 
      (S 
        (S 
          (S 
            (S Z))))))

</span><span class="ansi32">% 38,293,046 inferences, 5.551 CPU in 5.552 seconds (100% CPU, 6898312 Lips)
</span> (@ = "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/synthesis/SynthesizeTest.metta" 0)
<br/><a href="https://github.com/logicmoo/vspace-metta/blob/main/MeTTaLog.md">Return to Summaries</a><br/>
doing(ansi2html -u < "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/TEE.ansi" > "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/synthesis/SynthesizeTest.html" )

</pre>
</body>

</html>
