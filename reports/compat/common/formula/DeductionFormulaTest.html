<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>
<style type="text/css">
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi36 { color: #00aaaa; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content">
 (@ track_load_into_file "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/common/formula/DeductionFormulaTest.metta")
<span class="ansi38-000068000">!(import! &self DeductionFormula.metta)

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&self', 'DeductionFormula.metta'], A).

</span>;; Test
;; Formula and other functions used for the deduction rule
;; Import modules
<span class="ansi38-000068000">!(import! &self "../truthvalue/TruthValue.metta")

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&self', '../truthvalue/TruthValue.metta'], A).

</span>;; Truth value type definition
;; Import modules
<span class="ansi38-000068000">!(import! &self "../Num.metta")

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&self', '../Num.metta'], A).

</span>;;;;;;;;;;
;; Type ;;
;;;;;;;;;;
;; Collection of functions operating on numbers
;; Define max
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,max,[->,A,A,A]])
</span><span class="ansi38-255165000">  (: max 
    (-> $A $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( max(X,Y,Assign_Max_Y) :-
%~                              u_assign([>,X,Y],Assign) ,
%~                              Assign=_503668 ,
%~                              u_assign([if,_503668,X,Y],Assign_Max_Y))]
%~ [convert(_440864),head_preconds_into_body((max(X,Y,_439628):-(u_assign([>,X,Y],_441170),_441170=_441160),u_assign([if,_441160,X,Y],_439628)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[max,X,Y],[if,[>,X,Y],X,Y])
</span><span class="ansi38-255165000">  (= 
    (max $X $Y) 
    (if 
      (> $X $Y) $X $Y))
</span><span class="ansi38-000082136">  :- dynamic(max,3).

  max(X, Y, A) :-
    u_assign([>, X, Y], B),
    B=C,
    u_assign([if, C, X, Y], A).

</span>

;; Define min
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,min,[->,A,A,A]])
</span><span class="ansi38-255165000">  (: min 
    (-> $A $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( min(X,Y,Assign_Min_Y) :-
%~                              u_assign([<,X,Y],Assign) ,
%~                              Assign=_111180 ,
%~                              u_assign([if,_111180,X,Y],Assign_Min_Y))]
%~ [convert(_53450),head_preconds_into_body((min(X,Y,_52214):-(u_assign([<,X,Y],_53756),_53756=_53746),u_assign([if,_53746,X,Y],_52214)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[min,X,Y],[if,[<,X,Y],X,Y])
</span><span class="ansi38-255165000">  (= 
    (min $X $Y) 
    (if 
      (< $X $Y) $X $Y))
</span><span class="ansi38-000082136">  :- dynamic(min,3).

  min(X, Y, A) :-
    u_assign([<, X, Y], B),
    B=C,
    u_assign([if, C, X, Y], A).

</span>

;; Clamp a number to be within a certain range
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,clamp,[->,A,A,A,A]])
</span><span class="ansi38-255165000">  (: clamp 
    (-> $A $A $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( clamp(X,L,U,Assign_Clamp_U) :-
%~                              u_assign([min,U,X],Assign) ,
%~                              Assign=_234200 ,
%~                              u_assign([max,L,_234200],Assign_Clamp_U))]
%~ [convert(_174472),head_preconds_into_body((clamp(X,L,U,_173166):-(u_assign([min,U,X],_174834),_174834=_174824),u_assign([max,L,_174824],_173166)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[clamp,X,L,U],[max,L,[min,U,X]])
</span><span class="ansi38-255165000">  (= 
    (clamp $X $L $U) 
    (max $L 
      (min $U $X)))
</span><span class="ansi38-000082136">  :- dynamic(clamp,4).

  clamp(X, L, U, A) :-
    u_assign([min, U, X], B),
    B=C,
    u_assign([max, L, C], A).

</span>

;; Define abs
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,abs,[->,A,A]])
</span><span class="ansi38-255165000">  (: abs 
    (-> $A $A))
</span>

%~ /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/metta_vspace/pyswip/metta_interp.pl:1054 
%~ [ convert(Convert),
%~   head_preconds_into_body( abs(X,Assign_Abs_X) :-
%~                              u_assign([<,X,0],Assign) ,
%~                              Assign=_380254 ,
%~                              u_assign([*,-1,X],Assign3) ,
%~                              Assign3=_380272 ,
%~                              u_assign([if,_380254,_380272,X],Assign_Abs_X))]
%~ [convert(_293946),head_preconds_into_body((abs(X,_292780):-((u_assign([<,X,0],_294252),_294252=_294242),u_assign([*,-1,X],_294412),_294412=_294402),u_assign([if,_294242,_294402,X],_292780)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[abs,X],[if,[<,X,0],[*,-1,X],X])
</span><span class="ansi38-255165000">  (= 
    (abs $X) 
    (if 
      (< $X 0) 
      (* -1 $X) $X))
</span><span class="ansi38-000082136">
  abs(X, A) :-
    ( u_assign([<, X, 0], B),
      B=C
    ),
    u_assign([*, -1, X], D),
    D=E,
    u_assign([if, C, E, X], A).

</span>

;; Define <=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,<=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: <= 
    (-> $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( <=(X,Y,Assign_Y) :-
%~                              u_assign([<,X,Y],Assign) ,
%~                              Assign=_45064 ,
%~                              u_assign([==,X,Y],Assign2) ,
%~                              Assign2=_45082 ,
%~                              u_assign([or,_45064,_45082],Assign_Y))]
%~ [convert(_4034),head_preconds_into_body((<=(X,Y,_3992):-((u_assign([<,X,Y],_4072),_4072=_4068),u_assign([==,X,Y],_4122),_4122=_4118),u_assign([or,_4068,_4118],_3992)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[<=,X,Y],[or,[<,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">  (= 
    (<= $X $Y) 
    (or 
      (< $X $Y) 
      (== $X $Y)))
</span><span class="ansi38-000082136">  :- dynamic(<=,3).

  <=(X, Y, A) :-
    ( u_assign([<, X, Y], B),
      B=C
    ),
    u_assign([==, X, Y], D),
    D=E,
    u_assign([or, C, E], A).

</span>

;; Define >=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,>=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: >= 
    (-> $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( >=(X,Y,Assign_Y) :-
%~                              u_assign([>,X,Y],Assign) ,
%~                              Assign=_180842 ,
%~                              u_assign([==,X,Y],Assign2) ,
%~                              Assign2=_180860 ,
%~                              u_assign([or,_180842,_180860],Assign_Y))]
%~ [convert(_105194),head_preconds_into_body((>=(X,Y,_103958):-((u_assign([>,X,Y],_105500),_105500=_105490),u_assign([==,X,Y],_105704),_105704=_105694),u_assign([or,_105490,_105694],_103958)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[>=,X,Y],[or,[>,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">  (= 
    (>= $X $Y) 
    (or 
      (> $X $Y) 
      (== $X $Y)))
</span><span class="ansi38-000082136">  :- dynamic(>=,3).

  >=(X, Y, A) :-
    ( u_assign([>, X, Y], B),
      B=C
    ),
    u_assign([==, X, Y], D),
    D=E,
    u_assign([or, C, E], A).

</span>

;; Define approximately equal
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,approxEq,[->,A,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: approxEq 
    (-> $A $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( approxEq(X,Y,Epsilon,Assign_ApproxEq_Epsilon) :-
%~                              u_assign([-,X,Y],Assign) ,
%~                              Assign=_327210 ,
%~                              u_assign([abs,_327210],Assign3) ,
%~                              Assign3=_327234 ,
%~                              u_assign([<=,_327234,Epsilon],Assign_ApproxEq_Epsilon))]
%~ [convert(_240970),head_preconds_into_body((approxEq(X,Y,Epsilon,_239664):-(((u_assign([-,X,Y],_241318),_241318=_241308),u_assign([abs,_241308],_241276)),_241276=_241266),u_assign([<=,_241266,Epsilon],_239664)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[approxEq,X,Y,Epsilon],[<=,[abs,[-,X,Y]],Epsilon])
</span><span class="ansi38-255165000">  (= 
    (approxEq $X $Y $Epsilon) 
    (<= 
      (abs 
        (- $X $Y)) $Epsilon))
</span><span class="ansi38-000082136">  :- dynamic(approxEq,4).

  approxEq(X, Y, Epsilon, A) :-
    ( u_assign([-, X, Y], B),
      B=C,
      u_assign([abs, C], D)
    ),
    D=E,
    u_assign([<=, E, Epsilon], A).

</span>

;; Define Nat
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Nat','Type'])
</span><span class="ansi38-255165000">  (: Nat Type)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Z','Nat'])
</span><span class="ansi38-255165000">  (: Z Nat)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'S',[->,'Nat','Nat']])
</span><span class="ansi38-255165000">  (: S 
    (-> Nat Nat))
</span>

;; Define cast functions between Nat and Number
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNumber,[->,'Number','Nat']])
</span><span class="ansi38-255165000">  (: fromNumber 
    (-> Number Nat))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( fromNumber(N,N) :-
%~                              u_assign([<=,N,0],Assign) ,
%~                              Assign=_35968 ,
%~                              u_assign([-,N,1],Assign2) ,
%~                              Assign2=_36010 ,
%~                              u_assign([fromNumber,_36010],Assign3) ,
%~                              Assign3=_36034 ,
%~                              u_assign(['S',_36034],Assign4) ,
%~                              Assign4=_36058 ,
%~                              u_assign([if,_35968,'Z',_36058],N))]
%~ [convert(_4038),head_preconds_into_body((fromNumber(N,_4002):-((u_assign([<=,N,0],_4076),_4076=_4072),((((u_assign([-,N,1],_4184),_4184=_4180),u_assign([fromNumber,_4180],_4158)),_4158=_4154),u_assign(['S',_4154],_4132)),_4132=_4128),u_assign([if,_4072,'Z',_4128],_4002)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNumber,N],[if,[<=,N,0],'Z',['S',[fromNumber,[-,N,1]]]])
</span><span class="ansi38-255165000">  (= 
    (fromNumber $N) 
    (if 
      (<= $N 0) Z 
      (S 
        (fromNumber 
          (- $N 1)))))
</span><span class="ansi38-000082136">  :- dynamic(fromNumber,2).

  fromNumber(N, A) :-
    ( u_assign([<=, N, 0], B),
      B=C
    ),
    ( ( u_assign([-, N, 1], D),
        D=E,
        u_assign([fromNumber, E], F)
      ),
      F=G,
      u_assign(['S', G], H)
    ),
    H=I,
    u_assign([if, C, 'Z', I], A).

</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNat,[->,'Nat','Number']])
</span><span class="ansi38-255165000">  (: fromNat 
    (-> Nat Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((fromNat('Z',0):-true))]
%~ [convert(_83032),head_preconds_into_body((fromNat('Z',0):-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,'Z'],0)
</span><span class="ansi38-255165000">  (= 
    (fromNat Z) 0)
</span><span class="ansi38-000082136">  :- dynamic(fromNat,2).

  fromNat('Z', 0).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( fromNat(FromNat,FromNat1) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=FromNat ,
%~                              u_assign([fromNat,K],Assign3) ,
%~                              [+,1,Assign3,FromNat1])]
%~ [convert(_128188),head_preconds_into_body((fromNat(_127234,_126954):-(u_assign(['S',K],_127244),_127244=_127234),u_assign([fromNat,K],_128512),[+,1,_128512,_126954]))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,['S',K]],[+,1,[fromNat,K]])
</span><span class="ansi38-255165000">  (= 
    (fromNat 
      (S $K)) 
    (+ 1 
      (fromNat $K)))
</span><span class="ansi38-000082136">  :- dynamic(fromNat,2).

  fromNat(A, B) :-
    u_assign(['S', K], C),
    C=A,
    u_assign([fromNat, K], D),
    [+, 1, D, B].

</span>

;; Define a generic less than operator, â©», for Nat.  < cannot be used
;; because it is a built-in, its type is hardwired and cannot be
;; overloaded.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Nat','Nat','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Nat Nat Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('â©»'(_,'Z',_227542):-_227542='False'))]
%~ [convert(_228734),head_preconds_into_body(('â©»'(_,'Z',_227542):-_227542='False'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',_,'Z'],'False')
</span><span class="ansi38-255165000">  (= 
    (â©» $_ Z) False)
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(_, 'Z', A) :-
    A='False'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'('Z',Z,True) :-
%~                              u_assign(['S',_],Assign) ,
%~                              Assign=Z ,
%~                              True='True')]
%~ [convert(_275112),head_preconds_into_body(('â©»'('Z',_274144,_273852):-(u_assign(['S',_],_274154),_274154=_274144),_273852='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»','Z',['S',_]],'True')
</span><span class="ansi38-255165000">  (= 
    (â©» Z 
      (S $_)) True)
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'('Z', A, B) :-
    u_assign(['S', _], C),
    C=A,
    B='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'(Â1,Â,Assign_Â2) :-
%~                              u_assign(['S',X],Assign) ,
%~                              Assign=Â1 ,
%~                              u_assign(['S',Y],Assign4) ,
%~                              Assign4=Â ,
%~                              u_assign(['â©»',X,Y],Assign_Â2))]
%~ [convert(_346154),head_preconds_into_body(('â©»'(_345038,_345172,_344758):-((u_assign(['S',X],_345048),_345048=_345038),u_assign(['S',Y],_345182),_345182=_345172),u_assign(['â©»',X,Y],_344758)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',['S',X],['S',Y]],['â©»',X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» 
      (S $X) 
      (S $Y)) 
    (â©» $X $Y))
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(A, B, C) :-
    ( u_assign(['S', X], D),
      D=A
    ),
    u_assign(['S', Y], E),
    E=B,
    u_assign(['â©»', X, Y], C).

</span>

;; Overload â©» for Number.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Number','Number','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Number Number Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'(X,Y,Assign_Â_Y) :-
%~                              u_assign([<,X,Y],Assign_Â_Y))]
%~ [convert(_444468),head_preconds_into_body(('â©»'(X,Y,_443232):-u_assign([<,X,Y],_443232)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',X,Y],[<,X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» $X $Y) 
    (< $X $Y))
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(X, Y, A) :-
    u_assign([<, X, Y], A).

</span>

;; Return the ceiling of a non negative number.  If the number is
;; negative it returns 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,ceil,[->,'Number','Number']])
</span><span class="ansi38-255165000">  (: ceil 
    (-> Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ceil(N,Assign_Ceil_N) :-
%~                              u_assign([fromNumber,N],Assign) ,
%~                              Assign=_57810 ,
%~                              u_assign([fromNat,_57810],Assign_Ceil_N))]
%~ [convert(_3938),head_preconds_into_body((ceil(N,_3932):-(u_assign([fromNumber,N],_3968),_3968=_3964),u_assign([fromNat,_3964],_3932)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[ceil,N],[fromNat,[fromNumber,N]])
</span><span class="ansi38-255165000">  (= 
    (ceil $N) 
    (fromNat 
      (fromNumber $N)))
</span><span class="ansi38-000082136">  :- dynamic(ceil,2).

  ceil(N, A) :-
    u_assign([fromNumber, N], B),
    B=C,
    u_assign([fromNat, C], A).

</span>

;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'number->bool',[->,'Number','Bool']])
</span><span class="ansi38-255165000">  (: number->bool 
    (-> Number Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'number->bool'(X,Number_c62_bool_X) :-
%~                              u_assign([<,0,X],Number_c62_bool_X))]
%~ [convert(_99104),head_preconds_into_body(('number->bool'(X,_97938):-u_assign([<,0,X],_97938)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['number->bool',X],[<,0,X])
</span><span class="ansi38-255165000">  (= 
    (number->bool $X) 
    (< 0 $X))
</span><span class="ansi38-000082136">  :- dynamic('number->bool',2).

  'number->bool'(X, A) :-
    u_assign([<, 0, X], A).

</span>

;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'bool->number',[->,'Bool','Number']])
</span><span class="ansi38-255165000">  (: bool->number 
    (-> Bool Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('bool->number'('False',0):-true))]
%~ [convert(_169592),head_preconds_into_body(('bool->number'('False',0):-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','False'],0)
</span><span class="ansi38-255165000">  (= 
    (bool->number False) 0)
</span><span class="ansi38-000082136">  :- dynamic('bool->number',2).

  'bool->number'('False', 0).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('bool->number'(_206164,1):-is_True(_206164)))]
%~ [convert(_207000),head_preconds_into_body(('bool->number'(_206164,1):-is_True(_206164)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','True'],1)
</span><span class="ansi38-255165000">  (= 
    (bool->number True) 1)
</span><span class="ansi38-000082136">  :- dynamic('bool->number',2).

  'bool->number'(A, 1) :-
    is_True(A).

</span>

;; Define a less than type.  Note that it is purposefully different
;; than â©» as it is a type, not an operator.  Inhabitants of (â x y)
;; are proofs that x â©» y == True.  For now â is only axiomatized for
;; Nat.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â\x8D\\x83\',[->,True,True,'Type']])
</span><span class="ansi38-255165000">  (: â 
    (-> $True $True Type))
</span>

;; Zero is always less than the successor of something
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['zero-lt-succ-axiom'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ['zero-lt-succ-axiom',Assign2] :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=_370618 ,
%~                              u_assign(['â\x8D\\x83\','Z',_370618],Assign1) ,
%~                              Assign1=_370648 ,
%~                              u_assign([:,'ZeroLTSucc',_370648],Assign2))]
%~ [convert(_271632),head_preconds_into_body((['zero-lt-succ-axiom',_269792]:-(((u_assign(['S',K],_272004),_272004=_271994),u_assign(['â\x8D\\x83\','Z',_271994],_271950)),_271950=_271940),u_assign([:,'ZeroLTSucc',_271940],_269792)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['zero-lt-succ-axiom'],[:,'ZeroLTSucc',['â\x8D\\x83\','Z',['S',K]]])
</span><span class="ansi38-255165000">  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (â Z 
        (S $K))))
</span><span class="ansi38-000082136">
  ['zero-lt-succ-axiom', A] :-
    ( u_assign(['S', K], B),
      B=C,
      u_assign(['â\u008D\u0083', 'Z', C], D)
    ),
    D=E,
    u_assign([:, 'ZeroLTSucc', E], A).

</span>

;; If x â y then (S x) â (S y)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['succ-monotonicity-rule'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ['succ-monotonicity-rule',Assign5] :-
%~                              u_assign(['â\x8D\\x83\',X,Y],Assign) ,
%~                              Assign=_63306 ,
%~                              u_assign(['S',X],Assign1) ,
%~                              Assign1=_63342 ,
%~                              u_assign(['S',Y],Assign2) ,
%~                              Assign2=_63360 ,
%~                              u_assign(['â\x8D\\x83\',_63342,_63360],Assign3) ,
%~                              Assign3=_63390 ,
%~                              u_assign([->,_63306,_63390],Assign4) ,
%~                              Assign4=_63420 ,
%~                              u_assign([:,'SuccMonotonicity',_63420],Assign5))]
%~ [convert(_4054),head_preconds_into_body((['succ-monotonicity-rule',_4030]:-((((u_assign(['â\x8D\\x83\',X,Y],_4124),_4124=_4120),(((u_assign(['S',X],_4200),_4200=_4196),u_assign(['S',Y],_4244),_4244=_4240),u_assign(['â\x8D\\x83\',_4196,_4240],_4174)),_4174=_4170),u_assign([->,_4120,_4170],_4098)),_4098=_4094),u_assign([:,'SuccMonotonicity',_4094],_4030)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['succ-monotonicity-rule'],[:,'SuccMonotonicity',[->,['â\x8D\\x83\',X,Y],['â\x8D\\x83\',['S',X],['S',Y]]]])
</span><span class="ansi38-255165000">  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (â $X $Y) 
        (â 
          (S $X) 
          (S $Y)))))
</span><span class="ansi38-000082136">
  ['succ-monotonicity-rule', A] :-
    ( ( u_assign(['â\u008D\u0083', X, Y], B),
        B=C
      ),
      ( ( u_assign(['S', X], D),
          D=E
        ),
        u_assign(['S', Y], F),
        F=G,
        u_assign(['â\u008D\u0083', E, G], H)
      ),
      H=I,
      u_assign([->, C, I], J)
    ),
    J=K,
    u_assign([:, 'SuccMonotonicity', K], A).

</span>

; Evaluation took 1499.75 ms.
<span class="ansi33"> &self

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'TruthValue','Type'])
</span><span class="ansi38-255165000">  (: TruthValue Type)
</span>

;;;;;;;;;;;;;;;;;;
;; Constructors ;;
;;;;;;;;;;;;;;;;;;
;; Boolean TV constructor
;; TODO: alternatively we could have (: â¤ TruthValue) and (: â¥ TruthValue)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Bl',[->,'Bool','TruthValue']])
</span><span class="ansi38-255165000">  (: Bl 
    (-> Bool TruthValue))
</span>

;; First order probability TV constructor, i.e. mere probability.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Pr',[->,'Number','TruthValue']])
</span><span class="ansi38-255165000">  (: Pr 
    (-> Number TruthValue))
</span>

;; Second order probability TV constructor, i.e. probability and
;; count.  The second order probability is distributed according to a
;; beta distribution.  The first argument of the constructor
;; represents the mode of the second order distribution.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'PrCnt',[->,'Number','Number','TruthValue']])
</span><span class="ansi38-255165000">  (: PrCnt 
    (-> Number Number TruthValue))
</span>

;; Simple Truth Value.  A Second order probability TV constructor,
;; i.e. probability and confidence.  The probability is in fact the
;; mode of the corresponding beta distribution.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'STV',[->,'Number','Number','TruthValue']])
</span><span class="ansi38-255165000">  (: STV 
    (-> Number Number TruthValue))
</span>

;;;;;;;;;;;;;;;
;; Constants ;;
;;;;;;;;;;;;;;;
;; For now the underlying beta distributions have a Jeffreys prior,
;; i.e. the prior alpha and beta are 0.5.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,prior_alpha,[->,'Number']])
</span><span class="ansi38-255165000">  (: prior_alpha 
    (-> Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(([prior_alpha,0.5]:-true))]
%~ [convert(_346998),head_preconds_into_body(([prior_alpha,0.5]:-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[prior_alpha],0.5)
</span><span class="ansi38-255165000">  (= 
    (prior_alpha) 0.5)
</span><span class="ansi38-000082136">
  [prior_alpha, 0.5].

</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,prior_beta,[->,'Number']])
</span><span class="ansi38-255165000">  (: prior_beta 
    (-> Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(([prior_beta,0.5]:-true))]
%~ [convert(_437628),head_preconds_into_body(([prior_beta,0.5]:-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[prior_beta],0.5)
</span><span class="ansi38-255165000">  (= 
    (prior_beta) 0.5)
</span><span class="ansi38-000082136">
  [prior_beta, 0.5].

</span>

;; Lookahead
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,lookahead,[->,'Number']])
</span><span class="ansi38-255165000">  (: lookahead 
    (-> Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(([lookahead,1.0]:-true))]
%~ [convert(_7896),head_preconds_into_body(([lookahead,1.0]:-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[lookahead],1.0)
</span><span class="ansi38-255165000">  (= 
    (lookahead) 1.0)
</span><span class="ansi38-000082136">
  [lookahead, 1.0].

</span>

;; Maximum supported count (till +inf is supported, possibly).
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'max-count',[->,'Number']])
</span><span class="ansi38-255165000">  (: max-count 
    (-> Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((['max-count',1000000000.0]:-true))]
%~ [convert(_99230),head_preconds_into_body((['max-count',1000000000.0]:-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['max-count'],1000000000.0)
</span><span class="ansi38-255165000">  (= 
    (max-count) 1000000000.0)
</span><span class="ansi38-000082136">
  ['max-count', 1000000000.0].

</span>

;;;;;;;;;;;;;
;; Methods ;;
;;;;;;;;;;;;;
;; Convert count to confidence using the formula
;;
;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'count->confidence',[->,'Number','Number']])
</span><span class="ansi38-255165000">  (: count->confidence 
    (-> Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'count->confidence'(Cnt,Count_c62_confidence_Cnt) :-
%~                              [lookahead,_288920] ,
%~                              _288920=_288928 ,
%~                              u_assign([+,Cnt,_288928],Assign) ,
%~                              Assign=_288958 ,
%~                              u_assign([/,Cnt,_288958],Count_c62_confidence_Cnt))]
%~ [convert(_190996),head_preconds_into_body(('count->confidence'(Cnt,_189830):-((([lookahead,_192004],_192004=_191994),u_assign([+,Cnt,_191994],_191906)),_191906=_191896),u_assign([/,Cnt,_191896],_189830)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['count->confidence',Cnt],[/,Cnt,[+,Cnt,[lookahead]]])
</span><span class="ansi38-255165000">  (= 
    (count->confidence $Cnt) 
    (/ $Cnt 
      (+ $Cnt 
        (lookahead))))
</span><span class="ansi38-000082136">  :- dynamic('count->confidence',2).

  'count->confidence'(Cnt, A) :-
    ( [lookahead, B],
      B=C,
      u_assign([+, Cnt, C], D)
    ),
    D=E,
    u_assign([/, Cnt, E], A).

</span>

;; Convert confidence to count using the formula
;;
;; count = (confidence * lookahead) / (1 - confidence)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'confidence->count',[->,'Number','Number']])
</span><span class="ansi38-255165000">  (: confidence->count 
    (-> Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'confidence->count'(Conf,Assign_Conf) :-
%~                              u_assign([approxEq,1.0,Conf,1.0e-9],Assign) ,
%~                              Assign=_41356 ,
%~                              ['max-count',_41378] ,
%~                              _41378=_41386 ,
%~                              [lookahead,_41432] ,
%~                              _41432=_41440 ,
%~                              u_assign([*,Conf,_41440],Assign2) ,
%~                              Assign2=_41470 ,
%~                              u_assign([-,1.0,Conf],Assign3) ,
%~                              Assign3=_41488 ,
%~                              u_assign([/,_41470,_41488],Assign4) ,
%~                              Assign4=_41518 ,
%~                              u_assign([if,_41356,_41386,_41518],Assign_Conf))]
%~ [convert(_3642),head_preconds_into_body(('confidence->count'(Conf,_3606):-((u_assign([approxEq,1.0,Conf,1.0e-9],_3680),_3680=_3676),(['max-count',_3736],_3736=_3732),((((([lookahead,_3826],_3826=_3822),u_assign([*,Conf,_3822],_3794)),_3794=_3790),u_assign([-,1.0,Conf],_3870),_3870=_3866),u_assign([/,_3790,_3866],_3768)),_3768=_3764),u_assign([if,_3676,_3732,_3764],_3606)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['confidence->count',Conf],[if,[approxEq,1.0,Conf,1.0e-9],['max-count'],[/,[*,Conf,[lookahead]],[-,1.0,Conf]]])
</span><span class="ansi38-255165000">  (= 
    (confidence->count $Conf) 
    (if 
      (approxEq 1.0 $Conf 1.0e-9) 
      (max-count) 
      (/ 
        (* $Conf 
          (lookahead)) 
        (- 1.0 $Conf))))
</span><span class="ansi38-000082136">  :- dynamic('confidence->count',2).

  'confidence->count'(Conf, A) :-
    ( u_assign([approxEq, 1.0, Conf, 1.0e-9], B),
      B=C
    ),
    ( ['max-count', D],
      D=E
    ),
    ( ( ( [lookahead, F],
          F=G
        ),
        u_assign([*, Conf, G], H),
        H=I
      ),
      u_assign([-, 1.0, Conf], J),
      J=K,
      u_assign([/, I, K], L)
    ),
    L=M,
    u_assign([if, C, E, M], A).

</span>

;; Increment the given count by 1
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'inc-count',[->,'Number','Number']])
</span><span class="ansi38-255165000">  (: inc-count 
    (-> Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'inc-count'(Cnt,Inc_count_Cnt) :-
%~                              u_assign([+,1,Cnt],Inc_count_Cnt))]
%~ [convert(_118680),head_preconds_into_body(('inc-count'(Cnt,_117514):-u_assign([+,1,Cnt],_117514)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['inc-count',Cnt],[+,1,Cnt])
</span><span class="ansi38-255165000">  (= 
    (inc-count $Cnt) 
    (+ 1 $Cnt))
</span><span class="ansi38-000082136">  :- dynamic('inc-count',2).

  'inc-count'(Cnt, A) :-
    u_assign([+, 1, Cnt], A).

</span>

;; Increment the corresponding count of the given confidence by 1 and
;; return the confidence of that corresponding incremented count.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'inc-confidence',[->,'Number','Number']])
</span><span class="ansi38-255165000">  (: inc-confidence 
    (-> Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'inc-confidence'(Conf,Assign_Conf) :-
%~                              u_assign(['confidence->count',Conf],Assign) ,
%~                              Assign=_318476 ,
%~                              u_assign(['inc-count',_318476],Assign2) ,
%~                              Assign2=_318500 ,
%~                              u_assign(['count->confidence',_318500],Assign_Conf))]
%~ [convert(_230048),head_preconds_into_body(('inc-confidence'(Conf,_228882):-(((u_assign(['confidence->count',Conf],_230396),_230396=_230386),u_assign(['inc-count',_230386],_230354)),_230354=_230344),u_assign(['count->confidence',_230344],_228882)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['inc-confidence',Conf],['count->confidence',['inc-count',['confidence->count',Conf]]])
</span><span class="ansi38-255165000">  (= 
    (inc-confidence $Conf) 
    (count->confidence 
      (inc-count 
        (confidence->count $Conf))))
</span><span class="ansi38-000082136">  :- dynamic('inc-confidence',2).

  'inc-confidence'(Conf, A) :-
    ( u_assign(['confidence->count', Conf], B),
      B=C,
      u_assign(['inc-count', C], D)
    ),
    D=E,
    u_assign(['count->confidence', E], A).

</span>

;; Return the strength of a truth value, given that its count has been
;; incremented by one but its positive count has not.
;;
;; The formula is derived from new_s = s*cnt / (cnt + 1), where cnt is
;; the count of the original truth value, that is cnt = c*k / (1-c).
;; Thus
;;
;; new_s = (s*c*k / (1-c)) / (c*k / (1-c) + 1)
;;       = (s*c*k / (1-c)) / ((c*k + 1-c) / (1-c))
;;       = (s*c*k) / (c*k + 1-c)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'inc-count-strength',[->,'Number','Number','Number']])
</span><span class="ansi38-255165000">  (: inc-count-strength 
    (-> Number Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'inc-count-strength'(S,C,Assign_C) :-
%~                              [lookahead,_93938] ,
%~                              _93938=_93946 ,
%~                              u_assign([*,C,_93946],Assign) ,
%~                              Assign=_93976 ,
%~                              u_assign([*,S,_93976],Assign2) ,
%~                              Assign2=_94006 ,
%~                              [lookahead,_94058] ,
%~                              _94058=_94066 ,
%~                              u_assign([*,C,_94066],Assign3) ,
%~                              Assign3=_94096 ,
%~                              u_assign([+,_94096,1],Assign4) ,
%~                              Assign4=_94120 ,
%~                              u_assign([-,_94120,C],Assign5) ,
%~                              Assign5=_94144 ,
%~                              u_assign([/,_94006,_94144],Assign_C))]
%~ [convert(_3652),head_preconds_into_body(('inc-count-strength'(S,C,_3610):-(((((([lookahead,_3754],_3754=_3750),u_assign([*,C,_3750],_3722)),_3722=_3718),u_assign([*,S,_3718],_3690)),_3690=_3686),(((((([lookahead,_3894],_3894=_3890),u_assign([*,C,_3890],_3862)),_3862=_3858),u_assign([+,_3858,1],_3836)),_3836=_3832),u_assign([-,_3832,C],_3810)),_3810=_3806),u_assign([/,_3686,_3806],_3610)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['inc-count-strength',S,C],[/,[*,S,[*,C,[lookahead]]],[-,[+,[*,C,[lookahead]],1],C]])
</span><span class="ansi38-255165000">  (= 
    (inc-count-strength $S $C) 
    (/ 
      (* $S 
        (* $C 
          (lookahead))) 
      (- 
        (+ 
          (* $C 
            (lookahead)) 1) $C)))
</span><span class="ansi38-000082136">  :- dynamic('inc-count-strength',3).

  'inc-count-strength'(S, C, A) :-
    ( ( ( [lookahead, B],
          B=C
        ),
        u_assign([*, C, C], D),
        D=E
      ),
      u_assign([*, S, E], F),
      F=G
    ),
    ( ( ( [lookahead, H],
          H=I,
          u_assign([*, C, I], J)
        ),
        J=K,
        u_assign([+, K, 1], L)
      ),
      L=M,
      u_assign([-, M, C], N)
    ),
    N=O,
    u_assign([/, G, O], A).

</span>

;; Return the first order probability mode of the second order
;; distribution associated to a truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,mode,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">  (: mode 
    (-> TruthValue Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mode(_207342,1.0) :-
%~                              is_True(True) ,
%~                              u_assign(['Bl',True],Assign) ,
%~                              Assign=_203320)]
%~ [convert(_156062),head_preconds_into_body((mode(_155158,1.0):-(is_True(_155200),u_assign(['Bl',_155200],_155168)),_155168=_155158))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mode,['Bl','True']],1.0)
</span><span class="ansi38-255165000">  (= 
    (mode 
      (Bl True)) 1.0)
</span><span class="ansi38-000082136">  :- dynamic(mode,2).

  mode(A, 1.0) :-
    is_True(B),
    u_assign(['Bl', B], C),
    C=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mode(_282914,0.0) :-
%~                              u_assign(['Bl','False'],Assign) ,
%~                              Assign=_278970)]
%~ [convert(_239722),head_preconds_into_body((mode(_238812,0.0):-u_assign(['Bl','False'],_238822),_238822=_238812))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mode,['Bl','False']],0.0)
</span><span class="ansi38-255165000">  (= 
    (mode 
      (Bl False)) 0.0)
</span><span class="ansi38-000082136">  :- dynamic(mode,2).

  mode(A, 0.0) :-
    u_assign(['Bl', 'False'], B),
    B=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mode(Pr,Pr) :-
%~                              u_assign(['Pr',Pr],Assign) ,
%~                              Assign=Pr)]
%~ [convert(_316834),head_preconds_into_body((mode(_315880,Pr):-u_assign(['Pr',Pr],_315890),_315890=_315880))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mode,['Pr',Pr]],Pr)
</span><span class="ansi38-255165000">  (= 
    (mode 
      (Pr $Pr)) $Pr)
</span><span class="ansi38-000082136">  :- dynamic(mode,2).

  mode(A, Pr) :-
    u_assign(['Pr', Pr], B),
    B=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mode(Pr,Pr) :-
%~                              u_assign(['PrCnt',Pr,_],Assign) ,
%~                              Assign=Pr)]
%~ [convert(_388210),head_preconds_into_body((mode(_387186,Pr):-u_assign(['PrCnt',Pr,_],_387196),_387196=_387186))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mode,['PrCnt',Pr,_]],Pr)
</span><span class="ansi38-255165000">  (= 
    (mode 
      (PrCnt $Pr $_)) $Pr)
</span><span class="ansi38-000082136">  :- dynamic(mode,2).

  mode(A, Pr) :-
    u_assign(['PrCnt', Pr, _], B),
    B=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mode(Pr,Pr) :-
%~                              u_assign(['STV',Pr,_],Assign) ,
%~                              Assign=Pr)]
%~ [convert(_463638),head_preconds_into_body((mode(_462614,Pr):-u_assign(['STV',Pr,_],_462624),_462624=_462614))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mode,['STV',Pr,_]],Pr)
</span><span class="ansi38-255165000">  (= 
    (mode 
      (STV $Pr $_)) $Pr)
</span><span class="ansi38-000082136">  :- dynamic(mode,2).

  mode(A, Pr) :-
    u_assign(['STV', Pr, _], B),
    B=A.

</span>

;; Return the total count of a truth value.  For truth values not
;; capturing a notion of confidence, such as Bl or Pr then the count
;; is assumed to be a very large number (cause +inf does not seem to
;; be supported at the moment).  For truth values capturing a notion
;; of confidence, such as PrCnt, the total count is the count
;; component of the truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,count,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">  (: count 
    (-> TruthValue Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( count(Count,Count1) :-
%~                              u_assign(['Bl',_],Assign) ,
%~                              Assign=Count ,
%~                              ['max-count',Count1])]
%~ [convert(_28996),head_preconds_into_body((count(_28042,_27762):-(u_assign(['Bl',_],_28052),_28052=_28042),['max-count',_27762]))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[count,['Bl',_]],['max-count'])
</span><span class="ansi38-255165000">  (= 
    (count 
      (Bl $_)) 
    (max-count))
</span><span class="ansi38-000082136">  :- dynamic(count,2).

  count(A, B) :-
    u_assign(['Bl', _], C),
    C=A,
    ['max-count', B].

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( count(Count,Count1) :-
%~                              u_assign(['Pr',_],Assign) ,
%~                              Assign=Count ,
%~                              ['max-count',Count1])]
%~ [convert(_107538),head_preconds_into_body((count(_106584,_106304):-(u_assign(['Pr',_],_106594),_106594=_106584),['max-count',_106304]))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[count,['Pr',_]],['max-count'])
</span><span class="ansi38-255165000">  (= 
    (count 
      (Pr $_)) 
    (max-count))
</span><span class="ansi38-000082136">  :- dynamic(count,2).

  count(A, B) :-
    u_assign(['Pr', _], C),
    C=A,
    ['max-count', B].

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( count(Cnt,Cnt) :-
%~                              u_assign(['PrCnt',_,Cnt],Assign) ,
%~                              Assign=Cnt)]
%~ [convert(_187178),head_preconds_into_body((count(_186154,Cnt):-u_assign(['PrCnt',_,Cnt],_186164),_186164=_186154))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[count,['PrCnt',_,Cnt]],Cnt)
</span><span class="ansi38-255165000">  (= 
    (count 
      (PrCnt $_ $Cnt)) $Cnt)
</span><span class="ansi38-000082136">  :- dynamic(count,2).

  count(A, Cnt) :-
    u_assign(['PrCnt', _, Cnt], B),
    B=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( count(Count,Assign_Count1) :-
%~                              u_assign(['STV',_,Conf],Assign) ,
%~                              Assign=Count ,
%~                              u_assign(['confidence->count',Conf],Assign_Count1))]
%~ [convert(_260566),head_preconds_into_body((count(_259542,_259262):-(u_assign(['STV',_,Conf],_259552),_259552=_259542),u_assign(['confidence->count',Conf],_259262)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[count,['STV',_,Conf]],['confidence->count',Conf])
</span><span class="ansi38-255165000">  (= 
    (count 
      (STV $_ $Conf)) 
    (confidence->count $Conf))
</span><span class="ansi38-000082136">  :- dynamic(count,2).

  count(A, B) :-
    u_assign(['STV', _, Conf], C),
    C=A,
    u_assign(['confidence->count', Conf], B).

</span>

;; Return the confidence of a truth value.  For truth values not
;; capturing a notion of confidence, such as Bl or Pr then the
;; confidence is assumed to be 1.0.  For truth values capturing a
;; notion of confidence, such as PrCnt, the formula to convert a count
;; into confidence is as follows
;;
;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,confidence,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">  (: confidence 
    (-> TruthValue Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( confidence(_393724,1.0) :-
%~                              u_assign(['Bl',_],Assign) ,
%~                              Assign=_389780)]
%~ [convert(_348238),head_preconds_into_body((confidence(_347284,1.0):-u_assign(['Bl',_],_347294),_347294=_347284))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[confidence,['Bl',_]],1.0)
</span><span class="ansi38-255165000">  (= 
    (confidence 
      (Bl $_)) 1.0)
</span><span class="ansi38-000082136">  :- dynamic(confidence,2).

  confidence(A, 1.0) :-
    u_assign(['Bl', _], B),
    B=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( confidence(_465206,1.0) :-
%~                              u_assign(['Pr',_],Assign) ,
%~                              Assign=_461262)]
%~ [convert(_420332),head_preconds_into_body((confidence(_419378,1.0):-u_assign(['Pr',_],_419388),_419388=_419378))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[confidence,['Pr',_]],1.0)
</span><span class="ansi38-255165000">  (= 
    (confidence 
      (Pr $_)) 1.0)
</span><span class="ansi38-000082136">  :- dynamic(confidence,2).

  confidence(A, 1.0) :-
    u_assign(['Pr', _], B),
    B=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( confidence(Confidence,Assign_Confidence1) :-
%~                              u_assign(['PrCnt',_,Cnt],Assign) ,
%~                              Assign=Confidence ,
%~                              u_assign(['count->confidence',Cnt],Assign_Confidence1))]
%~ [convert(_3596),head_preconds_into_body((confidence(_3540,_3516):-(u_assign(['PrCnt',_,Cnt],_3544),_3544=_3540),u_assign(['count->confidence',Cnt],_3516)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[confidence,['PrCnt',_,Cnt]],['count->confidence',Cnt])
</span><span class="ansi38-255165000">  (= 
    (confidence 
      (PrCnt $_ $Cnt)) 
    (count->confidence $Cnt))
</span><span class="ansi38-000082136">  :- dynamic(confidence,2).

  confidence(A, B) :-
    u_assign(['PrCnt', _, Cnt], C),
    C=A,
    u_assign(['count->confidence', Cnt], B).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( confidence(Conf,Conf) :-
%~                              u_assign(['STV',_,Conf],Assign) ,
%~                              Assign=Conf)]
%~ [convert(_51814),head_preconds_into_body((confidence(_50790,Conf):-u_assign(['STV',_,Conf],_50800),_50800=_50790))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[confidence,['STV',_,Conf]],Conf)
</span><span class="ansi38-255165000">  (= 
    (confidence 
      (STV $_ $Conf)) $Conf)
</span><span class="ansi38-000082136">  :- dynamic(confidence,2).

  confidence(A, Conf) :-
    u_assign(['STV', _, Conf], B),
    B=A.

</span>

;; Return the positive count of a truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,pos_count,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">  (: pos_count 
    (-> TruthValue Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( pos_count(Tv,Assign_Count_Tv) :-
%~                              u_assign([mode,Tv],Assign) ,
%~                              Assign=_210746 ,
%~                              u_assign([count,Tv],Assign3) ,
%~                              Assign3=_210764 ,
%~                              u_assign([*,_210746,_210764],Assign_Count_Tv))]
%~ [convert(_133682),head_preconds_into_body((pos_count(Tv,_132516):-((u_assign([mode,Tv],_133988),_133988=_133978),u_assign([count,Tv],_134122),_134122=_134112),u_assign([*,_133978,_134112],_132516)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[pos_count,Tv],[*,[mode,Tv],[count,Tv]])
</span><span class="ansi38-255165000">  (= 
    (pos_count $Tv) 
    (* 
      (mode $Tv) 
      (count $Tv)))
</span><span class="ansi38-000082136">  :- dynamic(pos_count,2).

  pos_count(Tv, A) :-
    ( u_assign([mode, Tv], B),
      B=C
    ),
    u_assign([count, Tv], D),
    D=E,
    u_assign([*, C, E], A).

</span>

;; Return the negative count of a truth value.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,neg_count,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">  (: neg_count 
    (-> TruthValue Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( neg_count(Tv,Assign_Count_Tv) :-
%~                              u_assign([mode,Tv],Assign) ,
%~                              [-,1,Assign,_352392] ,
%~                              _352392=_352400 ,
%~                              u_assign([count,Tv],Assign3) ,
%~                              Assign3=_352418 ,
%~                              u_assign([*,_352400,_352418],Assign_Count_Tv))]
%~ [convert(_258144),head_preconds_into_body((neg_count(Tv,_256978):-(((u_assign([mode,Tv],_258510),[-,1,_258510,_258450]),_258450=_258440),u_assign([count,Tv],_258656),_258656=_258646),u_assign([*,_258440,_258646],_256978)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[neg_count,Tv],[*,[-,1,[mode,Tv]],[count,Tv]])
</span><span class="ansi38-255165000">  (= 
    (neg_count $Tv) 
    (* 
      (- 1 
        (mode $Tv)) 
      (count $Tv)))
</span><span class="ansi38-000082136">  :- dynamic(neg_count,2).

  neg_count(Tv, A) :-
    ( u_assign([mode, Tv], B),
      [-, 1, B, C],
      C=D
    ),
    u_assign([count, Tv], E),
    E=F,
    u_assign([*, D, F], A).

</span>

;; Return the posterior alpha of a truth value
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,post_alpha,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">  (: post_alpha 
    (-> TruthValue Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( post_alpha(Tv,Assign_Alpha_Tv) :-
%~                              [prior_alpha,_479258] ,
%~                              _479258=_479266 ,
%~                              u_assign([pos_count,Tv],Assign) ,
%~                              Assign=_479284 ,
%~                              u_assign([+,_479266,_479284],Assign_Alpha_Tv))]
%~ [convert(_396910),head_preconds_into_body((post_alpha(Tv,_395744):-(([prior_alpha,_397684],_397684=_397674),u_assign([pos_count,Tv],_398232),_398232=_398222),u_assign([+,_397674,_398222],_395744)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[post_alpha,Tv],[+,[prior_alpha],[pos_count,Tv]])
</span><span class="ansi38-255165000">  (= 
    (post_alpha $Tv) 
    (+ 
      (prior_alpha) 
      (pos_count $Tv)))
</span><span class="ansi38-000082136">  :- dynamic(post_alpha,2).

  post_alpha(Tv, A) :-
    ( [prior_alpha, B],
      B=C
    ),
    u_assign([pos_count, Tv], D),
    D=E,
    u_assign([+, C, E], A).

</span>

;; Return the posterior beta of a truth value
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,post_beta,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">  (: post_beta 
    (-> TruthValue Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( post_beta(Tv,Assign_Beta_Tv) :-
%~                              [prior_beta,_86586] ,
%~                              _86586=_86594 ,
%~                              u_assign([neg_count,Tv],Assign) ,
%~                              Assign=_86612 ,
%~                              u_assign([+,_86594,_86612],Assign_Beta_Tv))]
%~ [convert(_4910),head_preconds_into_body((post_beta(Tv,_3744):-(([prior_beta,_5684],_5684=_5674),u_assign([neg_count,Tv],_6232),_6232=_6222),u_assign([+,_5674,_6222],_3744)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[post_beta,Tv],[+,[prior_beta],[neg_count,Tv]])
</span><span class="ansi38-255165000">  (= 
    (post_beta $Tv) 
    (+ 
      (prior_beta) 
      (neg_count $Tv)))
</span><span class="ansi38-000082136">  :- dynamic(post_beta,2).

  post_beta(Tv, A) :-
    ( [prior_beta, B],
      B=C
    ),
    u_assign([neg_count, Tv], D),
    D=E,
    u_assign([+, C, E], A).

</span>

;; Return the first order probability mean of the second order
;; distribution associated to a truth value.  For truth values not
;; capturing a notion of confidence, such as Bl or Pr then the
;; confidence is assumed to be 1.0.  For truth values capturing a
;; notion of confidence, such as PrCnt, a beta distribution is
;; assumed.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,mean,[->,'TruthValue','Number']])
</span><span class="ansi38-255165000">  (: mean 
    (-> TruthValue Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mean(_171572,1.0) :-
%~                              is_True(True) ,
%~                              u_assign(['Bl',True],Assign) ,
%~                              Assign=_167550)]
%~ [convert(_120292),head_preconds_into_body((mean(_119388,1.0):-(is_True(_119430),u_assign(['Bl',_119430],_119398)),_119398=_119388))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mean,['Bl','True']],1.0)
</span><span class="ansi38-255165000">  (= 
    (mean 
      (Bl True)) 1.0)
</span><span class="ansi38-000082136">  :- dynamic(mean,2).

  mean(A, 1.0) :-
    is_True(B),
    u_assign(['Bl', B], C),
    C=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mean(_234316,0.0) :-
%~                              u_assign(['Bl','False'],Assign) ,
%~                              Assign=_230372)]
%~ [convert(_191124),head_preconds_into_body((mean(_190214,0.0):-u_assign(['Bl','False'],_190224),_190224=_190214))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mean,['Bl','False']],0.0)
</span><span class="ansi38-255165000">  (= 
    (mean 
      (Bl False)) 0.0)
</span><span class="ansi38-000082136">  :- dynamic(mean,2).

  mean(A, 0.0) :-
    u_assign(['Bl', 'False'], B),
    B=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mean(Pr,Pr) :-
%~                              u_assign(['Pr',Pr],Assign) ,
%~                              Assign=Pr)]
%~ [convert(_255408),head_preconds_into_body((mean(_254454,Pr):-u_assign(['Pr',Pr],_254464),_254464=_254454))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mean,['Pr',Pr]],Pr)
</span><span class="ansi38-255165000">  (= 
    (mean 
      (Pr $Pr)) $Pr)
</span><span class="ansi38-000082136">  :- dynamic(mean,2).

  mean(A, Pr) :-
    u_assign(['Pr', Pr], B),
    B=A.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mean(Mean,Assign_Mean1) :-
%~                              u_assign(['PrCnt',Pr,Cnt],Assign) ,
%~                              Assign=Mean ,
%~                              [ post_alpha,
%~                                ['PrCnt',Pr,Cnt]] =
%~                                A ,
%~                              [ post_beta,
%~                                ['PrCnt',Pr,Cnt]] =
%~                                B ,
%~                              u_assign([+,A,B],Assign3) ,
%~                              Assign3=_414346 ,
%~                              u_assign([/,A,_414346],Assign_Mean1))]
%~ [convert(_326334),head_preconds_into_body((mean(_325310,_325030):-(u_assign(['PrCnt',Pr,Cnt],_325320),_325320=_325310),([post_alpha,['PrCnt',Pr,Cnt]]=A,[post_beta,['PrCnt',Pr,Cnt]]=B),(u_assign([+,A,B],_328956),_328956=_328946),u_assign([/,A,_328946],_325030)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mean,['PrCnt',Pr,Cnt]],['let*',[[A,[post_alpha,['PrCnt',Pr,Cnt]]],[B,[post_beta,['PrCnt',Pr,Cnt]]]],[/,A,[+,A,B]]])
</span><span class="ansi38-255165000">  (= 
    (mean 
      (PrCnt $Pr $Cnt)) 
    (let* 
      ( ($A 
          (post_alpha 
            (PrCnt $Pr $Cnt))) 
        ($B 
          (post_beta 
            (PrCnt $Pr $Cnt)))) 
      (/ $A 
        (+ $A $B))))
</span><span class="ansi38-000082136">  :- dynamic(mean,2).

  mean(A, B) :-
    u_assign(['PrCnt', Pr, Cnt], C),
    C=A,
    [post_alpha, ['PrCnt', Pr, Cnt]]=A,
    [post_beta, ['PrCnt', Pr, Cnt]]=B,
    u_assign([+, A, B], D),
    D=E,
    u_assign([/, A, E], B).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( mean(Mean,Assign_Mean1) :-
%~                              u_assign(['STV',Pr,Conf],Assign) ,
%~                              Assign=Mean ,
%~                              [ post_alpha,
%~                                ['STV',Pr,Conf]] =
%~                                A ,
%~                              [ post_beta,
%~                                ['STV',Pr,Conf]] =
%~                                B ,
%~                              u_assign([+,A,B],Assign3) ,
%~                              Assign3=_41652 ,
%~                              u_assign([/,A,_41652],Assign_Mean1))]
%~ [convert(_3760),head_preconds_into_body((mean(_3704,_3680):-(u_assign(['STV',Pr,Conf],_3708),_3708=_3704),([post_alpha,['STV',Pr,Conf]]=A,[post_beta,['STV',Pr,Conf]]=B),(u_assign([+,A,B],_3834),_3834=_3830),u_assign([/,A,_3830],_3680)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[mean,['STV',Pr,Conf]],['let*',[[A,[post_alpha,['STV',Pr,Conf]]],[B,[post_beta,['STV',Pr,Conf]]]],[/,A,[+,A,B]]])
</span><span class="ansi38-255165000">  (= 
    (mean 
      (STV $Pr $Conf)) 
    (let* 
      ( ($A 
          (post_alpha 
            (STV $Pr $Conf))) 
        ($B 
          (post_beta 
            (STV $Pr $Conf)))) 
      (/ $A 
        (+ $A $B))))
</span><span class="ansi38-000082136">  :- dynamic(mean,2).

  mean(A, B) :-
    u_assign(['STV', Pr, Conf], C),
    C=A,
    [post_alpha, ['STV', Pr, Conf]]=A,
    [post_beta, ['STV', Pr, Conf]]=B,
    u_assign([+, A, B], D),
    D=E,
    u_assign([/, A, E], B).

</span>

; Evaluation took 3.95 seconds.
<span class="ansi33"> &self

</span><span class="ansi38-000068000">!(import! &self "../Num.metta")

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&self', '../Num.metta'], A).

</span>; Consistency Conditions
;; Collection of functions operating on numbers
;; Define max
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,max,[->,A,A,A]])
</span><span class="ansi38-255165000">  (: max 
    (-> $A $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( max(X,Y,Assign_Max_Y) :-
%~                              u_assign([>,X,Y],Assign) ,
%~                              Assign=_239044 ,
%~                              u_assign([if,_239044,X,Y],Assign_Max_Y))]
%~ [convert(_181314),head_preconds_into_body((max(X,Y,_180078):-(u_assign([>,X,Y],_181620),_181620=_181610),u_assign([if,_181610,X,Y],_180078)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[max,X,Y],[if,[>,X,Y],X,Y])
</span><span class="ansi38-255165000">  (= 
    (max $X $Y) 
    (if 
      (> $X $Y) $X $Y))
</span><span class="ansi38-000082136">  :- dynamic(max,3).

  max(X, Y, A) :-
    u_assign([>, X, Y], B),
    B=C,
    u_assign([if, C, X, Y], A).

</span>

;; Define min
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,min,[->,A,A,A]])
</span><span class="ansi38-255165000">  (: min 
    (-> $A $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( min(X,Y,Assign_Min_Y) :-
%~                              u_assign([<,X,Y],Assign) ,
%~                              Assign=_360740 ,
%~                              u_assign([if,_360740,X,Y],Assign_Min_Y))]
%~ [convert(_303010),head_preconds_into_body((min(X,Y,_301774):-(u_assign([<,X,Y],_303316),_303316=_303306),u_assign([if,_303306,X,Y],_301774)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[min,X,Y],[if,[<,X,Y],X,Y])
</span><span class="ansi38-255165000">  (= 
    (min $X $Y) 
    (if 
      (< $X $Y) $X $Y))
</span><span class="ansi38-000082136">  :- dynamic(min,3).

  min(X, Y, A) :-
    u_assign([<, X, Y], B),
    B=C,
    u_assign([if, C, X, Y], A).

</span>

;; Clamp a number to be within a certain range
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,clamp,[->,A,A,A,A]])
</span><span class="ansi38-255165000">  (: clamp 
    (-> $A $A $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( clamp(X,L,U,Assign_Clamp_U) :-
%~                              u_assign([min,U,X],Assign) ,
%~                              Assign=_483762 ,
%~                              u_assign([max,L,_483762],Assign_Clamp_U))]
%~ [convert(_424034),head_preconds_into_body((clamp(X,L,U,_422728):-(u_assign([min,U,X],_424396),_424396=_424386),u_assign([max,L,_424386],_422728)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[clamp,X,L,U],[max,L,[min,U,X]])
</span><span class="ansi38-255165000">  (= 
    (clamp $X $L $U) 
    (max $L 
      (min $U $X)))
</span><span class="ansi38-000082136">  :- dynamic(clamp,4).

  clamp(X, L, U, A) :-
    u_assign([min, U, X], B),
    B=C,
    u_assign([max, L, C], A).

</span>

;; Define abs
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,abs,[->,A,A]])
</span><span class="ansi38-255165000">  (: abs 
    (-> $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( abs(X,Assign_Abs_X) :-
%~                              u_assign([<,X,0],Assign) ,
%~                              Assign=_113822 ,
%~                              u_assign([*,-1,X],Assign3) ,
%~                              Assign3=_113840 ,
%~                              u_assign([if,_113822,_113840,X],Assign_Abs_X))]
%~ [convert(_28130),head_preconds_into_body((abs(X,_26964):-((u_assign([<,X,0],_28436),_28436=_28426),u_assign([*,-1,X],_28596),_28596=_28586),u_assign([if,_28426,_28586,X],_26964)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[abs,X],[if,[<,X,0],[*,-1,X],X])
</span><span class="ansi38-255165000">  (= 
    (abs $X) 
    (if 
      (< $X 0) 
      (* -1 $X) $X))
</span><span class="ansi38-000082136">
  abs(X, A) :-
    ( u_assign([<, X, 0], B),
      B=C
    ),
    u_assign([*, -1, X], D),
    D=E,
    u_assign([if, C, E, X], A).

</span>

;; Define <=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,<=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: <= 
    (-> $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( <=(X,Y,Assign_Y) :-
%~                              u_assign([<,X,Y],Assign) ,
%~                              Assign=_249752 ,
%~                              u_assign([==,X,Y],Assign2) ,
%~                              Assign2=_249770 ,
%~                              u_assign([or,_249752,_249770],Assign_Y))]
%~ [convert(_174716),head_preconds_into_body((<=(X,Y,_173480):-((u_assign([<,X,Y],_175022),_175022=_175012),u_assign([==,X,Y],_175226),_175226=_175216),u_assign([or,_175012,_175216],_173480)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[<=,X,Y],[or,[<,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">  (= 
    (<= $X $Y) 
    (or 
      (< $X $Y) 
      (== $X $Y)))
</span><span class="ansi38-000082136">  :- dynamic(<=,3).

  <=(X, Y, A) :-
    ( u_assign([<, X, Y], B),
      B=C
    ),
    u_assign([==, X, Y], D),
    D=E,
    u_assign([or, C, E], A).

</span>

;; Define >=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,>=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: >= 
    (-> $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( >=(X,Y,Assign_Y) :-
%~                              u_assign([>,X,Y],Assign) ,
%~                              Assign=_384926 ,
%~                              u_assign([==,X,Y],Assign2) ,
%~                              Assign2=_384944 ,
%~                              u_assign([or,_384926,_384944],Assign_Y))]
%~ [convert(_309890),head_preconds_into_body((>=(X,Y,_308654):-((u_assign([>,X,Y],_310196),_310196=_310186),u_assign([==,X,Y],_310400),_310400=_310390),u_assign([or,_310186,_310390],_308654)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[>=,X,Y],[or,[>,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">  (= 
    (>= $X $Y) 
    (or 
      (> $X $Y) 
      (== $X $Y)))
</span><span class="ansi38-000082136">  :- dynamic(>=,3).

  >=(X, Y, A) :-
    ( u_assign([>, X, Y], B),
      B=C
    ),
    u_assign([==, X, Y], D),
    D=E,
    u_assign([or, C, E], A).

</span>

;; Define approximately equal
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,approxEq,[->,A,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: approxEq 
    (-> $A $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( approxEq(X,Y,Epsilon,Assign_ApproxEq_Epsilon) :-
%~                              u_assign([-,X,Y],Assign) ,
%~                              Assign=_15760 ,
%~                              u_assign([abs,_15760],Assign3) ,
%~                              Assign3=_15784 ,
%~                              u_assign([<=,_15784,Epsilon],Assign_ApproxEq_Epsilon))]
%~ [convert(_3590),head_preconds_into_body((approxEq(X,Y,Epsilon,_3542):-(((u_assign([-,X,Y],_3654),_3654=_3650),u_assign([abs,_3650],_3628)),_3628=_3624),u_assign([<=,_3624,Epsilon],_3542)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[approxEq,X,Y,Epsilon],[<=,[abs,[-,X,Y]],Epsilon])
</span><span class="ansi38-255165000">  (= 
    (approxEq $X $Y $Epsilon) 
    (<= 
      (abs 
        (- $X $Y)) $Epsilon))
</span><span class="ansi38-000082136">  :- dynamic(approxEq,4).

  approxEq(X, Y, Epsilon, A) :-
    ( u_assign([-, X, Y], B),
      B=C,
      u_assign([abs, C], D)
    ),
    D=E,
    u_assign([<=, E, Epsilon], A).

</span>

;; Define Nat
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Nat','Type'])
</span><span class="ansi38-255165000">  (: Nat Type)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Z','Nat'])
</span><span class="ansi38-255165000">  (: Z Nat)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'S',[->,'Nat','Nat']])
</span><span class="ansi38-255165000">  (: S 
    (-> Nat Nat))
</span>

;; Define cast functions between Nat and Number
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNumber,[->,'Number','Nat']])
</span><span class="ansi38-255165000">  (: fromNumber 
    (-> Number Nat))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( fromNumber(N,N) :-
%~                              u_assign([<=,N,0],Assign) ,
%~                              Assign=_239566 ,
%~                              u_assign([-,N,1],Assign2) ,
%~                              Assign2=_239608 ,
%~                              u_assign([fromNumber,_239608],Assign3) ,
%~                              Assign3=_239632 ,
%~                              u_assign(['S',_239632],Assign4) ,
%~                              Assign4=_239656 ,
%~                              u_assign([if,_239566,'Z',_239656],N))]
%~ [convert(_117410),head_preconds_into_body((fromNumber(N,_116244):-((u_assign([<=,N,0],_117716),_117716=_117706),((((u_assign([-,N,1],_117972),_117972=_117962),u_assign([fromNumber,_117962],_117930)),_117930=_117920),u_assign(['S',_117920],_117888)),_117888=_117878),u_assign([if,_117706,'Z',_117878],_116244)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNumber,N],[if,[<=,N,0],'Z',['S',[fromNumber,[-,N,1]]]])
</span><span class="ansi38-255165000">  (= 
    (fromNumber $N) 
    (if 
      (<= $N 0) Z 
      (S 
        (fromNumber 
          (- $N 1)))))
</span><span class="ansi38-000082136">  :- dynamic(fromNumber,2).

  fromNumber(N, A) :-
    ( u_assign([<=, N, 0], B),
      B=C
    ),
    ( ( u_assign([-, N, 1], D),
        D=E,
        u_assign([fromNumber, E], F)
      ),
      F=G,
      u_assign(['S', G], H)
    ),
    H=I,
    u_assign([if, C, 'Z', I], A).

</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNat,[->,'Nat','Number']])
</span><span class="ansi38-255165000">  (: fromNat 
    (-> Nat Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((fromNat('Z',0):-true))]
%~ [convert(_286644),head_preconds_into_body((fromNat('Z',0):-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,'Z'],0)
</span><span class="ansi38-255165000">  (= 
    (fromNat Z) 0)
</span><span class="ansi38-000082136">  :- dynamic(fromNat,2).

  fromNat('Z', 0).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( fromNat(FromNat,FromNat1) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=FromNat ,
%~                              u_assign([fromNat,K],Assign3) ,
%~                              [+,1,Assign3,FromNat1])]
%~ [convert(_332412),head_preconds_into_body((fromNat(_331458,_331178):-(u_assign(['S',K],_331468),_331468=_331458),u_assign([fromNat,K],_332736),[+,1,_332736,_331178]))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,['S',K]],[+,1,[fromNat,K]])
</span><span class="ansi38-255165000">  (= 
    (fromNat 
      (S $K)) 
    (+ 1 
      (fromNat $K)))
</span><span class="ansi38-000082136">  :- dynamic(fromNat,2).

  fromNat(A, B) :-
    u_assign(['S', K], C),
    C=A,
    u_assign([fromNat, K], D),
    [+, 1, D, B].

</span>

;; Define a generic less than operator, â©», for Nat.  < cannot be used
;; because it is a built-in, its type is hardwired and cannot be
;; overloaded.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Nat','Nat','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Nat Nat Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('â©»'(_,'Z',_431766):-_431766='False'))]
%~ [convert(_432958),head_preconds_into_body(('â©»'(_,'Z',_431766):-_431766='False'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',_,'Z'],'False')
</span><span class="ansi38-255165000">  (= 
    (â©» $_ Z) False)
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(_, 'Z', A) :-
    A='False'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'('Z',Z,True) :-
%~                              u_assign(['S',_],Assign) ,
%~                              Assign=Z ,
%~                              True='True')]
%~ [convert(_3584),head_preconds_into_body(('â©»'('Z',_3534,_3504):-(u_assign(['S',_],_3538),_3538=_3534),_3504='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»','Z',['S',_]],'True')
</span><span class="ansi38-255165000">  (= 
    (â©» Z 
      (S $_)) True)
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'('Z', A, B) :-
    u_assign(['S', _], C),
    C=A,
    B='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'(Â1,Â,Assign_Â2) :-
%~                              u_assign(['S',X],Assign) ,
%~                              Assign=Â1 ,
%~                              u_assign(['S',Y],Assign4) ,
%~                              Assign4=Â ,
%~                              u_assign(['â©»',X,Y],Assign_Â2))]
%~ [convert(_31930),head_preconds_into_body(('â©»'(_30814,_30948,_30534):-((u_assign(['S',X],_30824),_30824=_30814),u_assign(['S',Y],_30958),_30958=_30948),u_assign(['â©»',X,Y],_30534)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',['S',X],['S',Y]],['â©»',X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» 
      (S $X) 
      (S $Y)) 
    (â©» $X $Y))
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(A, B, C) :-
    ( u_assign(['S', X], D),
      D=A
    ),
    u_assign(['S', Y], E),
    E=B,
    u_assign(['â©»', X, Y], C).

</span>

;; Overload â©» for Number.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Number','Number','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Number Number Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'(X,Y,Assign_Â_Y) :-
%~                              u_assign([<,X,Y],Assign_Â_Y))]
%~ [convert(_129630),head_preconds_into_body(('â©»'(X,Y,_128394):-u_assign([<,X,Y],_128394)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',X,Y],[<,X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» $X $Y) 
    (< $X $Y))
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(X, Y, A) :-
    u_assign([<, X, Y], A).

</span>

;; Return the ceiling of a non negative number.  If the number is
;; negative it returns 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,ceil,[->,'Number','Number']])
</span><span class="ansi38-255165000">  (: ceil 
    (-> Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ceil(N,Assign_Ceil_N) :-
%~                              u_assign([fromNumber,N],Assign) ,
%~                              Assign=_261088 ,
%~                              u_assign([fromNat,_261088],Assign_Ceil_N))]
%~ [convert(_205386),head_preconds_into_body((ceil(N,_204220):-(u_assign([fromNumber,N],_205692),_205692=_205682),u_assign([fromNat,_205682],_204220)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[ceil,N],[fromNat,[fromNumber,N]])
</span><span class="ansi38-255165000">  (= 
    (ceil $N) 
    (fromNat 
      (fromNumber $N)))
</span><span class="ansi38-000082136">  :- dynamic(ceil,2).

  ceil(N, A) :-
    u_assign([fromNumber, N], B),
    B=C,
    u_assign([fromNat, C], A).

</span>

;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'number->bool',[->,'Number','Bool']])
</span><span class="ansi38-255165000">  (: number->bool 
    (-> Number Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'number->bool'(X,Number_c62_bool_X) :-
%~                              u_assign([<,0,X],Number_c62_bool_X))]
%~ [convert(_302384),head_preconds_into_body(('number->bool'(X,_301218):-u_assign([<,0,X],_301218)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['number->bool',X],[<,0,X])
</span><span class="ansi38-255165000">  (= 
    (number->bool $X) 
    (< 0 $X))
</span><span class="ansi38-000082136">  :- dynamic('number->bool',2).

  'number->bool'(X, A) :-
    u_assign([<, 0, X], A).

</span>

;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'bool->number',[->,'Bool','Number']])
</span><span class="ansi38-255165000">  (: bool->number 
    (-> Bool Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('bool->number'('False',0):-true))]
%~ [convert(_373484),head_preconds_into_body(('bool->number'('False',0):-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','False'],0)
</span><span class="ansi38-255165000">  (= 
    (bool->number False) 0)
</span><span class="ansi38-000082136">  :- dynamic('bool->number',2).

  'bool->number'('False', 0).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('bool->number'(_410056,1):-is_True(_410056)))]
%~ [convert(_410892),head_preconds_into_body(('bool->number'(_410056,1):-is_True(_410056)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','True'],1)
</span><span class="ansi38-255165000">  (= 
    (bool->number True) 1)
</span><span class="ansi38-000082136">  :- dynamic('bool->number',2).

  'bool->number'(A, 1) :-
    is_True(A).

</span>

;; Define a less than type.  Note that it is purposefully different
;; than â©» as it is a type, not an operator.  Inhabitants of (â x y)
;; are proofs that x â©» y == True.  For now â is only axiomatized for
;; Nat.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â\x8D\\x83\',[->,True,True,'Type']])
</span><span class="ansi38-255165000">  (: â 
    (-> $True $True Type))
</span>

;; Zero is always less than the successor of something
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['zero-lt-succ-axiom'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ['zero-lt-succ-axiom',Assign2] :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=_58970 ,
%~                              u_assign(['â\x8D\\x83\','Z',_58970],Assign1) ,
%~                              Assign1=_59000 ,
%~                              u_assign([:,'ZeroLTSucc',_59000],Assign2))]
%~ [convert(_3574),head_preconds_into_body((['zero-lt-succ-axiom',_3550]:-(((u_assign(['S',K],_3650),_3650=_3646),u_assign(['â\x8D\\x83\','Z',_3646],_3618)),_3618=_3614),u_assign([:,'ZeroLTSucc',_3614],_3550)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['zero-lt-succ-axiom'],[:,'ZeroLTSucc',['â\x8D\\x83\','Z',['S',K]]])
</span><span class="ansi38-255165000">  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (â Z 
        (S $K))))
</span><span class="ansi38-000082136">
  ['zero-lt-succ-axiom', A] :-
    ( u_assign(['S', K], B),
      B=C,
      u_assign(['â\u008D\u0083', 'Z', C], D)
    ),
    D=E,
    u_assign([:, 'ZeroLTSucc', E], A).

</span>

;; If x â y then (S x) â (S y)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['succ-monotonicity-rule'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ['succ-monotonicity-rule',Assign5] :-
%~                              u_assign(['â\x8D\\x83\',X,Y],Assign) ,
%~                              Assign=_259918 ,
%~                              u_assign(['S',X],Assign1) ,
%~                              Assign1=_259954 ,
%~                              u_assign(['S',Y],Assign2) ,
%~                              Assign2=_259972 ,
%~                              u_assign(['â\x8D\\x83\',_259954,_259972],Assign3) ,
%~                              Assign3=_260002 ,
%~                              u_assign([->,_259918,_260002],Assign4) ,
%~                              Assign4=_260032 ,
%~                              u_assign([:,'SuccMonotonicity',_260032],Assign5))]
%~ [convert(_98610),head_preconds_into_body((['succ-monotonicity-rule',_96770]:-((((u_assign(['â\x8D\\x83\',X,Y],_98970),_98970=_98960),(((u_assign(['S',X],_99216),_99216=_99206),u_assign(['S',Y],_99350),_99350=_99340),u_assign(['â\x8D\\x83\',_99206,_99340],_99174)),_99174=_99164),u_assign([->,_98960,_99164],_98928)),_98928=_98918),u_assign([:,'SuccMonotonicity',_98918],_96770)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['succ-monotonicity-rule'],[:,'SuccMonotonicity',[->,['â\x8D\\x83\',X,Y],['â\x8D\\x83\',['S',X],['S',Y]]]])
</span><span class="ansi38-255165000">  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (â $X $Y) 
        (â 
          (S $X) 
          (S $Y)))))
</span><span class="ansi38-000082136">
  ['succ-monotonicity-rule', A] :-
    ( ( u_assign(['â\u008D\u0083', X, Y], B),
        B=C
      ),
      ( ( u_assign(['S', X], D),
          D=E
        ),
        u_assign(['S', Y], F),
        F=G,
        u_assign(['â\u008D\u0083', E, G], H)
      ),
      H=I,
      u_assign([->, C, I], J)
    ),
    J=K,
    u_assign([:, 'SuccMonotonicity', K], A).

</span>

; Evaluation took 1395.57 ms.
<span class="ansi33"> &self

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'smallest-intersection-probability',[->,'Number','Number','Number']])
</span><span class="ansi38-255165000">  (: smallest-intersection-probability 
    (-> Number Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'smallest-intersection-probability'(As,Bs,Smallest_intersection_probability_Bs) :-
%~                              u_assign([+,As,Bs],Assign) ,
%~                              Assign=_459286 ,
%~                              u_assign([-,_459286,1],Assign3) ,
%~                              Assign3=_459310 ,
%~                              u_assign([/,_459310,As],Assign4) ,
%~                              Assign4=_459334 ,
%~                              u_assign([clamp,_459334,0,1],Smallest_intersection_probability_Bs))]
%~ [convert(_330374),head_preconds_into_body(('smallest-intersection-probability'(As,Bs,_329138):-(((((u_assign([+,As,Bs],_330764),_330764=_330754),u_assign([-,_330754,1],_330722)),_330722=_330712),u_assign([/,_330712,As],_330680)),_330680=_330670),u_assign([clamp,_330670,0,1],_329138)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['smallest-intersection-probability',As,Bs],[clamp,[/,[-,[+,As,Bs],1],As],0,1])
</span><span class="ansi38-255165000">  (= 
    (smallest-intersection-probability $As $Bs) 
    (clamp 
      (/ 
        (- 
          (+ $As $Bs) 1) $As) 0 1))
</span><span class="ansi38-000082136">  :- dynamic('smallest-intersection-probability',3).

  'smallest-intersection-probability'(As, Bs, A) :-
    ( ( u_assign([+, As, Bs], B),
        B=C,
        u_assign([-, C, 1], D)
      ),
      D=E,
      u_assign([/, E, As], F)
    ),
    F=G,
    u_assign([clamp, G, 0, 1], A).

</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'largest-intersection-probability',[->,'Number','Number','Number']])
</span><span class="ansi38-255165000">  (: largest-intersection-probability 
    (-> Number Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'largest-intersection-probability'(As,Bs,Largest_intersection_probability_Bs) :-
%~                              u_assign([/,Bs,As],Assign) ,
%~                              Assign=_71984 ,
%~                              u_assign([clamp,_71984,0,1],Largest_intersection_probability_Bs))]
%~ [convert(_3056),head_preconds_into_body(('largest-intersection-probability'(As,Bs,_3050):-(u_assign([/,Bs,As],_3086),_3086=_3082),u_assign([clamp,_3082,0,1],_3050)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['largest-intersection-probability',As,Bs],[clamp,[/,Bs,As],0,1])
</span><span class="ansi38-255165000">  (= 
    (largest-intersection-probability $As $Bs) 
    (clamp 
      (/ $Bs $As) 0 1))
</span><span class="ansi38-000082136">  :- dynamic('largest-intersection-probability',3).

  'largest-intersection-probability'(As, Bs, A) :-
    u_assign([/, Bs, As], B),
    B=C,
    u_assign([clamp, C, 0, 1], A).

</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'conditional-probability-consistency',[->,'Number','Number','Number','Bool']])
</span><span class="ansi38-255165000">  (: conditional-probability-consistency 
    (-> Number Number Number Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'conditional-probability-consistency'( As,
%~                              Bs,  ABs, Conditional_probability_consistency_True_Bs) :-
%~                              Conditional_probability_consistency_True_Bs='True')]
%~ [convert(_133044),head_preconds_into_body(('conditional-probability-consistency'(As,Bs,ABs,_131738):-_131738='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['conditional-probability-consistency',As,Bs,ABs],'True')
</span><span class="ansi38-255165000">  (= 
    (conditional-probability-consistency $As $Bs $ABs) True)
</span><span class="ansi38-000082136">  :- dynamic('conditional-probability-consistency',4).

  'conditional-probability-consistency'(As, Bs, ABs, A) :-
    A='True'.

</span>

;; (and (< 0 $As)
;;      (and (<= (smallest-intersection-probability $As $Bs) $ABs)
;;           (<= $ABs (largest-intersection-probability $As $Bs)))))
;; Main Formula
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'simple-deduction-strength-formula',[->,'Number','Number','Number','Number','Number','Number']])
</span><span class="ansi38-255165000">  (: simple-deduction-strength-formula 
    (-> Number Number Number Number Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'simple-deduction-strength-formula'( As,
%~                              Bs, Cs,ABs,BCs,
%~                              Simple_deduction_strength_formula_Cs) :-
%~                              u_assign( ['conditional-probability-consistency',As,Bs,ABs],
%~                                Assign_True) ,
%~                              Assign_True='True' ,
%~                              u_assign( ['conditional-probability-consistency',Bs,Cs,BCs],
%~                                Assign) ,
%~                              Assign=_110858 ,
%~                              u_assign([<,0.99,Bs],Assign5) ,
%~                              Assign5=_110894 ,
%~                              u_assign([*,ABs,BCs],Assign6) ,
%~                              Assign6=_110930 ,
%~                              u_assign([-,1,ABs],Assign7) ,
%~                              Assign7=_110984 ,
%~                              u_assign([*,Bs,BCs],Assign8) ,
%~                              Assign8=_111014 ,
%~                              u_assign([-,Cs,_111014],Assign9) ,
%~                              Assign9=_111044 ,
%~                              u_assign([*,_110984,_111044],Assign10) ,
%~                              Assign10=_111074 ,
%~                              u_assign([-,1,Bs],Assign11) ,
%~                              Assign11=_111092 ,
%~                              u_assign([/,_111074,_111092],Assign12) ,
%~                              Assign12=_111122 ,
%~                              u_assign([+,_110930,_111122],Assign13) ,
%~                              Assign13=_111152 ,
%~                              u_assign([if,_110894,Cs,_111152],Assign14) ,
%~                              Assign14=_111188 ,
%~                              u_assign([if,_110858,_111188,0],Simple_deduction_strength_formula_Cs))]
%~ [convert(_3454),head_preconds_into_body(('simple-deduction-strength-formula'(As,Bs,Cs,ABs,BCs,_3394):-(((u_assign(['conditional-probability-consistency',As,Bs,ABs],_3494),_3494='True',u_assign(['conditional-probability-consistency',Bs,Cs,BCs],_3492)),_3492=_3488),(((u_assign([<,0.99,Bs],_3630),_3630=_3626),(((u_assign([*,ABs,BCs],_3712),_3712=_3708),((((((u_assign([-,1,ABs],_3814),_3814=_3810),((u_assign([*,Bs,BCs],_3896),_3896=_3892),u_assign([-,Cs,_3892],_3864)),_3864=_3860),u_assign([*,_3810,_3860],_3788)),_3788=_3784),u_assign([-,1,Bs],_3976),_3976=_3972),u_assign([/,_3784,_3972],_3762)),_3762=_3758),u_assign([+,_3708,_3758],_3686)),_3686=_3682),u_assign([if,_3626,Cs,_3682],_3604)),_3604=_3600),u_assign([if,_3488,_3600,0],_3394)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['simple-deduction-strength-formula',As,Bs,Cs,ABs,BCs],[if,[and,['conditional-probability-consistency',As,Bs,ABs],['conditional-probability-consistency',Bs,Cs,BCs]],[if,[<,0.99,Bs],Cs,[+,[*,ABs,BCs],[/,[*,[-,1,ABs],[-,Cs,[*,Bs,BCs]]],[-,1,Bs]]]],0])
</span><span class="ansi38-255165000">  (= 
    (simple-deduction-strength-formula $As $Bs $Cs $ABs $BCs) 
    (if 
      (and 
        (conditional-probability-consistency $As $Bs $ABs) 
        (conditional-probability-consistency $Bs $Cs $BCs)) 
      (if 
        (< 0.99 $Bs) $Cs 
        (+ 
          (* $ABs $BCs) 
          (/ 
            (* 
              (- 1 $ABs) 
              (- $Cs 
                (* $Bs $BCs))) 
            (- 1 $Bs)))) 0))
</span><span class="ansi38-000082136">  :- dynamic('simple-deduction-strength-formula',6).

  'simple-deduction-strength-formula'(As,
                                      Bs,
                                      Cs,
                                      ABs,
                                      BCs,
                                      A) :-
    ( u_assign([ 'conditional-probability-consistency',
                 As,
                 Bs,
                 ABs
               ],
               B),
      B='True',
      u_assign([ 'conditional-probability-consistency',
                 Bs,
                 Cs,
                 BCs
               ],
               C),
      C=D
    ),
    ( ( u_assign([<, 0.99, Bs], E),
        E=F
      ),
      ( ( u_assign([*, ABs, BCs], G),
          G=H
        ),
        ( ( ( u_assign([-, 1, ABs], I),
              I=J,
              ( u_assign([*, Bs, BCs], K),
                K=L
              ),
              u_assign([-, Cs, L], M),
              M=N
            ),
            u_assign([*, J, N], O),
            O=P
          ),
          u_assign([-, 1, Bs], Q),
          Q=R,
          u_assign([/, P, R], S)
        ),
        S=T,
        u_assign([+, H, T], U)
      ),
      U=V,
      u_assign([if, F, Cs, V], W)
    ),
    W=X,
    u_assign([if, D, X, 0], A).

</span>

;; Preconditions are met
;; sB tends to 1
;; otherwise
;; Preconditions are not met
;; Deduction formula
%~ [ convert(Convert),
%~   head_preconds_into_body( ded_formula(Ptv,Qtv,Rtv,Pqtv,Qrtv,Assign_Formula_Qrtv) :-
%~                              [confidence,Ptv]=Pc ,
%~                              [confidence,Qtv]=Qc ,
%~                              [confidence,Rtv]=Rc ,
%~                              [confidence,Pqtv]=PQc ,
%~                              [confidence,Qrtv]=QRc ,
%~                              [mode,Pqtv]=PQs ,
%~                              [mode,Qrtv]=QRs ,
%~                              [mode,Ptv]=Ps ,
%~                              [mode,Qtv]=Qs ,
%~                              [mode,Rtv]=Rs ,
%~                              [ 'simple-deduction-strength-formula', Ps,Qs,Rs,
%~                                PQs,QRs] =
%~                                PRs ,
%~                              [ min,
%~                                Pc,
%~                                [ min,
%~                                  Qc,
%~                                  [ min,
%~                                    Rc,
%~                                    [min,PQc,QRc]]]] =
%~                                PRc ,
%~                              u_assign([==,PRs,0],Assign) ,
%~                              Assign=_391978 ,
%~                              u_assign(['PrCnt',1,0],Assign3) ,
%~                              Assign3=_392002 ,
%~                              u_assign(['PrCnt',PRs,PRs],Assign4) ,
%~                              Assign4=_392020 ,
%~                              u_assign([if,_391978,_392002,_392020],Assign_Formula_Qrtv))]
%~ [convert(_223820),head_preconds_into_body((ded_formula(Ptv,Qtv,Rtv,Pqtv,Qrtv,_222374):-([confidence,Ptv]=Pc,[confidence,Qtv]=Qc,[confidence,Rtv]=Rc,[confidence,Pqtv]=PQc,[confidence,Qrtv]=QRc,[mode,Pqtv]=PQs,[mode,Qrtv]=QRs,[mode,Ptv]=Ps,[mode,Qtv]=Qs,[mode,Rtv]=Rs),(['simple-deduction-strength-formula',Ps,Qs,Rs,PQs,QRs]=PRs,[min,Pc,[min,Qc,[min,Rc,[min,PQc,QRc]]]]=PRc),((u_assign([==,PRs,0],_235606),_235606=_235596),(u_assign(['PrCnt',1,0],_235766),_235766=_235756),u_assign(['PrCnt',PRs,PRs],_235882),_235882=_235872),u_assign([if,_235596,_235756,_235872],_222374)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[ded_formula,Ptv,Qtv,Rtv,Pqtv,Qrtv],['let*',[[Pc,[confidence,Ptv]],[Qc,[confidence,Qtv]],[Rc,[confidence,Rtv]],[PQc,[confidence,Pqtv]],[QRc,[confidence,Qrtv]],[PQs,[mode,Pqtv]],[QRs,[mode,Qrtv]],[Ps,[mode,Ptv]],[Qs,[mode,Qtv]],[Rs,[mode,Rtv]]],['let*',[[PRs,['simple-deduction-strength-formula',Ps,Qs,Rs,PQs,QRs]],[PRc,[min,Pc,[min,Qc,[min,Rc,[min,PQc,QRc]]]]]],[if,[==,PRs,0],['PrCnt',1,0],['PrCnt',PRs,PRs]]]])
</span><span class="ansi38-255165000">  (= 
    (ded_formula $Ptv $Qtv $Rtv $Pqtv $Qrtv) 
    (let* 
      ( ($Pc 
          (confidence $Ptv)) 
        ($Qc 
          (confidence $Qtv)) 
        ($Rc 
          (confidence $Rtv)) 
        ($PQc 
          (confidence $Pqtv)) 
        ($QRc 
          (confidence $Qrtv)) 
        ($PQs 
          (mode $Pqtv)) 
        ($QRs 
          (mode $Qrtv)) 
        ($Ps 
          (mode $Ptv)) 
        ($Qs 
          (mode $Qtv)) 
        ($Rs 
          (mode $Rtv))) 
      (let* 
        ( ($PRs 
            (simple-deduction-strength-formula $Ps $Qs $Rs $PQs $QRs)) 
          ($PRc 
            (min $Pc 
              (min $Qc 
                (min $Rc 
                  (min $PQc $QRc)))))) 
        (if 
          (== $PRs 0) 
          (PrCnt 1 0) 
          (PrCnt $PRs $PRs)))))
</span><span class="ansi38-000082136">  :- dynamic(ded_formula,6).

  ded_formula(Ptv, Qtv, Rtv, Pqtv, Qrtv, A) :-
    [confidence, Ptv]=Pc,
    [confidence, Qtv]=Qc,
    [confidence, Rtv]=Rc,
    [confidence, Pqtv]=PQc,
    [confidence, Qrtv]=QRc,
    [mode, Pqtv]=PQs,
    [mode, Qrtv]=QRs,
    [mode, Ptv]=Ps,
    [mode, Qtv]=Qs,
    [mode, Rtv]=Rs,
    ['simple-deduction-strength-formula', Ps, Qs, Rs, PQs, QRs]=PRs,
    [min, Pc, [min, Qc, [min, Rc, [min, PQc, QRc]]]]=PRc,
    ( u_assign([==, PRs, 0], B),
      B=C
    ),
    ( u_assign(['PrCnt', 1, 0], D),
      D=E
    ),
    u_assign(['PrCnt', PRs, PRs], F),
    F=G,
    u_assign([if, C, E, G], A).

</span>

;; Alternate deduction formula hardwired for STV to make it faster.
%~ [ convert(Convert),
%~   head_preconds_into_body( 'deduction-formula'( Deduction_formula4,
%~                              Deduction_formula3,  Deduction_formula2, Deduction_formula1, Deduction_formula, Assign_Deduction_formula6) :-
%~                              u_assign(['STV',Ps,Pc],Assign) ,
%~                              Assign=Deduction_formula4 ,
%~                              u_assign(['STV',Qs,Qc],Assign8) ,
%~                              Assign8=Deduction_formula3 ,
%~                              u_assign(['STV',Rs,Rc],Assign9) ,
%~                              Assign9=Deduction_formula2 ,
%~                              u_assign(['STV',PQs,PQc],Assign10) ,
%~                              Assign10=Deduction_formula1 ,
%~                              u_assign(['STV',QRs,QRc],Assign11) ,
%~                              Assign11=Deduction_formula ,
%~                              u_assign( ['conditional-probability-consistency',Ps,Qs,PQs],
%~                                Assign_True) ,
%~                              Assign_True='True' ,
%~                              u_assign( ['conditional-probability-consistency',Qs,Rs,QRs],
%~                                Assign13) ,
%~                              Assign13=_65992 ,
%~                              u_assign([<,0.9999,Qs],Assign14) ,
%~                              Assign14=_66052 ,
%~                              u_assign([*,PQs,QRs],Assign15) ,
%~                              Assign15=_66088 ,
%~                              u_assign([-,1,PQs],Assign16) ,
%~                              Assign16=_66142 ,
%~                              u_assign([*,Qs,QRs],Assign17) ,
%~                              Assign17=_66172 ,
%~                              u_assign([-,Rs,_66172],Assign18) ,
%~                              Assign18=_66202 ,
%~                              u_assign([*,_66142,_66202],Assign19) ,
%~                              Assign19=_66232 ,
%~                              u_assign([-,1,Qs],Assign20) ,
%~                              Assign20=_66250 ,
%~                              u_assign([/,_66232,_66250],Assign21) ,
%~                              Assign21=_66280 ,
%~                              u_assign([+,_66088,_66280],Assign22) ,
%~                              Assign22=_66310 ,
%~                              u_assign([if,_66052,Rs,_66310],Assign23) ,
%~                              Assign23=_66346 ,
%~                              u_assign([min,PQc,QRc],Assign24) ,
%~                              Assign24=_66400 ,
%~                              u_assign([min,Rc,_66400],Assign25) ,
%~                              Assign25=_66430 ,
%~                              u_assign([min,Qc,_66430],Assign26) ,
%~                              Assign26=_66460 ,
%~                              u_assign([min,Pc,_66460],Assign27) ,
%~                              Assign27=_66490 ,
%~                              u_assign(['STV',_66346,_66490],Assign28) ,
%~                              Assign28=_66520 ,
%~                              u_assign(['STV',1,0],Assign29) ,
%~                              Assign29=_66538 ,
%~                              u_assign([if,_65992,_66520,_66538],Assign_Deduction_formula6))]
%~ [convert(_3864),head_preconds_into_body(('deduction-formula'(_3584,_3634,_3684,_3734,_3784,_3562):-((u_assign(['STV',Ps,Pc],_3588),_3588=_3584),(u_assign(['STV',Qs,Qc],_3638),_3638=_3634),(u_assign(['STV',Rs,Rc],_3688),_3688=_3684),(u_assign(['STV',PQs,PQc],_3738),_3738=_3734),u_assign(['STV',QRs,QRc],_3788),_3788=_3784),(((u_assign(['conditional-probability-consistency',Ps,Qs,PQs],_3904),_3904='True',u_assign(['conditional-probability-consistency',Qs,Rs,QRs],_3902)),_3902=_3898),(((((((u_assign([<,0.9999,Qs],_4066),_4066=_4062),(((u_assign([*,PQs,QRs],_4148),_4148=_4144),((((((u_assign([-,1,PQs],_4250),_4250=_4246),((u_assign([*,Qs,QRs],_4332),_4332=_4328),u_assign([-,Rs,_4328],_4300)),_4300=_4296),u_assign([*,_4246,_4296],_4224)),_4224=_4220),u_assign([-,1,Qs],_4412),_4412=_4408),u_assign([/,_4220,_4408],_4198)),_4198=_4194),u_assign([+,_4144,_4194],_4122)),_4122=_4118),u_assign([if,_4062,Rs,_4118],_4040)),_4040=_4036),((((((u_assign([min,PQc,QRc],_4612),_4612=_4608),u_assign([min,Rc,_4608],_4580)),_4580=_4576),u_assign([min,Qc,_4576],_4548)),_4548=_4544),u_assign([min,Pc,_4544],_4516)),_4516=_4512),u_assign(['STV',_4036,_4512],_4014)),_4014=_4010),u_assign(['STV',1,0],_4716),_4716=_4712),u_assign([if,_3898,_4010,_4712],_3562)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['deduction-formula',['STV',Ps,Pc],['STV',Qs,Qc],['STV',Rs,Rc],['STV',PQs,PQc],['STV',QRs,QRc]],[if,[and,['conditional-probability-consistency',Ps,Qs,PQs],['conditional-probability-consistency',Qs,Rs,QRs]],['STV',[if,[<,0.9999,Qs],Rs,[+,[*,PQs,QRs],[/,[*,[-,1,PQs],[-,Rs,[*,Qs,QRs]]],[-,1,Qs]]]],[min,Pc,[min,Qc,[min,Rc,[min,PQc,QRc]]]]],['STV',1,0]])
</span><span class="ansi38-255165000">  (= 
    (deduction-formula 
      (STV $Ps $Pc) 
      (STV $Qs $Qc) 
      (STV $Rs $Rc) 
      (STV $PQs $PQc) 
      (STV $QRs $QRc)) 
    (if 
      (and 
        (conditional-probability-consistency $Ps $Qs $PQs) 
        (conditional-probability-consistency $Qs $Rs $QRs)) 
      (STV 
        (if 
          (< 0.9999 $Qs) $Rs 
          (+ 
            (* $PQs $QRs) 
            (/ 
              (* 
                (- 1 $PQs) 
                (- $Rs 
                  (* $Qs $QRs))) 
              (- 1 $Qs)))) 
        (min $Pc 
          (min $Qc 
            (min $Rc 
              (min $PQc $QRc))))) 
      (STV 1 0)))
</span><span class="ansi38-000082136">  :- dynamic('deduction-formula',6).

  'deduction-formula'(A, B, C, D, E, F) :-
    ( u_assign(['STV', Ps, Pc], G),
      G=A
    ),
    ( u_assign(['STV', Qs, Qc], H),
      H=B
    ),
    ( u_assign(['STV', Rs, Rc], I),
      I=C
    ),
    ( u_assign(['STV', PQs, PQc], J),
      J=D
    ),
    u_assign(['STV', QRs, QRc], K),
    K=E,
    ( u_assign([ 'conditional-probability-consistency',
                 Ps,
                 Qs,
                 PQs
               ],
               L),
      L='True',
      u_assign([ 'conditional-probability-consistency',
                 Qs,
                 Rs,
                 QRs
               ],
               M),
      M=N
    ),
    ( ( ( ( u_assign([<, 0.9999, Qs], O),
            O=P
          ),
          ( ( u_assign([*, PQs, QRs], Q),
              Q=R
            ),
            ( ( ( u_assign([-, 1, PQs], S),
                  S=T,
                  ( u_assign([*, Qs, QRs], U),
                    U=V
                  ),
                  u_assign([-, Rs, V], W),
                  W=X
                ),
                u_assign([*, T, X], Y),
                Y=Z
              ),
              u_assign([-, 1, Qs], A1),
              A1=B1,
              u_assign([/, Z, B1], C1)
            ),
            C1=D1,
            u_assign([+, R, D1], E1)
          ),
          E1=F1,
          u_assign([if, P, Rs, F1], G1)
        ),
        G1=H1,
        ( ( ( u_assign([min, PQc, QRc], I1),
              I1=J1
            ),
            u_assign([min, Rc, J1], K1),
            K1=L1
          ),
          u_assign([min, Qc, L1], M1),
          M1=N1
        ),
        u_assign([min, Pc, N1], O1),
        O1=P1
      ),
      u_assign(['STV', H1, P1], Q1),
      Q1=R1
    ),
    u_assign(['STV', 1, 0], S1),
    S1=T1,
    u_assign([if, N, R1, T1], F).

</span>

; Evaluation took 7.42 seconds.
<span class="ansi33"> &self

</span>;; Preconditions are met
; avoid division by 0
;; Qs tends to 1
;; Otherwise
;; Preconditions are not met
<span class="ansi38-000068000">!(assertEqualToResult (max 3 4) (4))

</span><span class="ansi38-017068017">exec(A) :-
    loonit_assert_source_tf([assertEqualToResult, [max, 3, 4], [4]],
                            findall(B,
                                    (true, u_assign([max, 3, 4], B)),
                                    C),
                            equal_enough(C, [4]),
                            A).

</span><h3 id="FORMULA.DEDUCTIONFORMULATEST.01">;; FORMULA.DEDUCTIONFORMULATEST.01</h3><span class="ansi36">
(@ loonit_success 
  (equal_enough  
    (4) 
    (4)))
</span>        -->(0,'&self',[max,3,4],depth(2))
          -->(1,'&self',[if,[>,3,4],3,4],depth(3))
              -->(2,'&self',[>,3,4],depth(5))
              <--(2,retval('False'))
          <--(1,retval(4))
        <--(0,retval([if,[>,3,4],3,4]))
; Evaluation took 0.966 ms. (966.10 microseconds) 
<span class="ansi33"> True

</span><span class="ansi38-000068000">!(assertEqualToResult (min 3 4) (3))

</span><span class="ansi38-017068017">exec(A) :-
    loonit_assert_source_tf([assertEqualToResult, [min, 3, 4], [3]],
                            findall(B,
                                    (true, u_assign([min, 3, 4], B)),
                                    C),
                            equal_enough(C, [3]),
                            A).

</span><h3 id="FORMULA.DEDUCTIONFORMULATEST.02">;; FORMULA.DEDUCTIONFORMULATEST.02</h3><span class="ansi36">
(@ loonit_success 
  (equal_enough  
    (3) 
    (3)))
</span>        -->(0,'&self',[min,3,4],depth(2))
          -->(1,'&self',[if,[<,3,4],3,4],depth(3))
              -->(2,'&self',[<,3,4],depth(5))
              <--(2,retval('True'))
          <--(1,retval(3))
        <--(0,retval([if,[<,3,4],3,4]))
; Evaluation took 0.789 ms. (788.80 microseconds) 
<span class="ansi33"> True

</span><span class="ansi38-000068000">!(assertEqualToResult (and True True) (True))

</span><span class="ansi38-017068017">exec(A) :-
    loonit_assert_source_tf([assertEqualToResult, [and, 'True', 'True'], 'True'()],
                            findall(B,
                                    (C='True', C='True', B='True'),
                                    D),
                            equal_enough(D, 'True'()),
                            A).

</span><h3 id="FORMULA.DEDUCTIONFORMULATEST.03">;; FORMULA.DEDUCTIONFORMULATEST.03</h3><span class="ansi36">
(@ loonit_success 
  (equal_enough  
    (True) 
    (True)))
</span>        -->(0,'&self',[and,'True','True'],depth(2))
        <--(0,retval('True'))
; Evaluation took 0.678 ms. (678.40 microseconds) 
<span class="ansi33"> True

</span><span class="ansi38-000068000">!(assertEqualToResult (or True False) (True))

</span><span class="ansi38-017068017">exec(A) :-
    loonit_assert_source_tf([assertEqualToResult, [or, 'True', 'False'], 'True'()],
                            findall(B,
                                    ((is_True(C), true), u_assign([or, C, 'False'], B)),
                                    D),
                            equal_enough(D, 'True'()),
                            A).

</span><h3 id="FORMULA.DEDUCTIONFORMULATEST.04">;; FORMULA.DEDUCTIONFORMULATEST.04</h3><span class="ansi36">
(@ loonit_success 
  (equal_enough  
    (True) 
    (True)))
</span>        -->(0,'&self',[or,'True','False'],depth(2))
        <--(0,retval('True'))
; Evaluation took 0.652 ms. (652.40 microseconds) 
<span class="ansi33"> True

</span><span class="ansi38-000068000">!(assertEqualToResult (<= 5 4) (False))

</span><span class="ansi38-017068017">exec(A) :-
    loonit_assert_source_tf([assertEqualToResult, [<=, 5, 4], 'False'()],
                            findall(B,
                                    (true, u_assign([<=, 5, 4], B)),
                                    C),
                            equal_enough(C, 'False'()),
                            A).

</span><h3 id="FORMULA.DEDUCTIONFORMULATEST.05">;; FORMULA.DEDUCTIONFORMULATEST.05</h3><span class="ansi36">
(@ loonit_success 
  (equal_enough  
    (False) 
    (False)))
</span>        -->(0,'&self',[<=,5,4],depth(2))
          -->(1,'&self',[or,[<,5,4],[==,5,4]],depth(3))
              -->(2,'&self',[<,5,4],depth(5))
              <--(2,retval('False'))
              -->(3,'&self',[or,'False',[==,5,4]],depth(5))
                  -->(4,'&self',[==,5,4],depth(7))
                  <--(4,retval('False'))
                  -->(5,'&self',[or,'False','False'],depth(7))
                  <--(5,retval('False'))
                  -->(6,'&self',[==,5,4],depth(7))
                  <--(6,retval('False'))
              <--(3,retval('False'))
              -->(7,'&self',[<,5,4],depth(5))
              <--(7,retval('False'))
              -->(8,'&self',[==,5,4],depth(5))
              <--(8,retval('False'))
          <--(1,retval('False'))
        <--(0,retval([or,[<,5,4],[==,5,4]]))
; Evaluation took 1.71 ms.
<span class="ansi33"> True

</span><span class="ansi38-000068000">!(clamp 2 0 1)

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign([clamp, 2, 0, 1], A).

</span>; Evaluation took 0.241 ms. (240.70 microseconds) 
<span class="ansi33"> 1

</span><span class="ansi38-000068000">!(smallest-intersection-probability 0.9 0.6)

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['smallest-intersection-probability', 0.9, 0.6], A).

</span>; Evaluation took 1.56 ms.
<span class="ansi33"> 1

</span><span class="ansi38-000068000">!(conditional-probability-consistency 0.9 0.6 0.5)

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['conditional-probability-consistency', 0.9, 0.6, 0.5], A).

</span>; Evaluation took 0.053 ms. (52.50 microseconds) 
<span class="ansi33"> True

</span><span class="ansi38-000068000">!(simple-deduction-strength-formula 0.9 0.6 0.5 0.3 0.4)

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['simple-deduction-strength-formula', 0.9, 0.6, 0.5, 0.3, 0.4], A).

</span>; Evaluation took 56.75 ms.
<span class="ansi33">  (+ 
    (* 0.3 0.4) 
    (/ 
      (* 0.7 
        (- 0.5 
          (* 0.6 0.4))) 0.4))

</span>; Evaluation took 138.25 ms.
<span class="ansi33">  (+ 
    (* 0.3 0.4) 
    (/ 
      (* 0.7 
        (- 0.5 
          (* 0.6 0.4))) 
      (- 1 0.6)))

</span><span class="ansi38-000068000">!(ded_formula (PrCnt 1 10) (PrCnt 1 4) (PrCnt 1 2) (PrCnt 1 3) (PrCnt 1 5))

</span><span class="ansi38-017068017">exec(A) :-
    ( true,
      u_assign(['PrCnt', 1, 10], B),
      B=C
    ),
    ( true,
      u_assign(['PrCnt', 1, 4], D),
      D=E
    ),
    ( true,
      u_assign(['PrCnt', 1, 2], F),
      F=G
    ),
    ( true,
      u_assign(['PrCnt', 1, 3], H),
      H=I
    ),
    ( true,
      u_assign(['PrCnt', 1, 5], J)
    ),
    J=K,
    u_assign([ded_formula, C, E, G, I, K], A).

</span>; Evaluation took 23.81 ms.
<span class="ansi33">  (PrCnt 1 1)

</span><span class="ansi38-000068000">!(conditional-probability-consistency 0.2 0.3 1)

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['conditional-probability-consistency', 0.2, 0.3, 1], A).

</span>; Evaluation took 0.038 ms. (38.20 microseconds) 
<span class="ansi33"> True

</span><span class="ansi38-000068000">!(conditional-probability-consistency 0.3 0.4 0.9)

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['conditional-probability-consistency', 0.3, 0.4, 0.9], A).

</span>; Evaluation took 0.037 ms. (36.50 microseconds) 
<span class="ansi33"> True

</span><span class="ansi38-000068000">!(deduction-formula (STV 0.2 0.3) (STV 0.3 0.2) (STV 0.4 0.1) (STV 1 0.5) (STV 0.9 0.7))

</span><span class="ansi38-017068017">exec(A) :-
    ( true,
      u_assign(['STV', 0.2, 0.3], B),
      B=C
    ),
    ( true,
      u_assign(['STV', 0.3, 0.2], D),
      D=E
    ),
    ( true,
      u_assign(['STV', 0.4, 0.1], F),
      F=G
    ),
    ( true,
      u_assign(['STV', 1, 0.5], H),
      H=I
    ),
    ( true,
      u_assign(['STV', 0.9, 0.7], J)
    ),
    J=K,
    u_assign(['deduction-formula', C, E, G, I, K],
             A).

</span>; Evaluation took 110.03 ms.
<span class="ansi33">  (STV 
    (+ 
      (* 1 0.9) 
      (/ 
        (* 0 
          (- 0.4 
            (* 0.3 0.9))) 0.7)) 0.1)

</span>; Evaluation took 284.93 ms.
<span class="ansi33">  (STV 
    (+ 
      (* 1 0.9) 
      (/ 
        (* 0 
          (- 0.4 
            (* 0.3 0.9))) 
        (- 1 0.3))) 0.1)

</span><span class="ansi32">% 52,269,123 inferences, 8.219 CPU in 8.219 seconds (100% CPU, 6359886 Lips)
</span> (@ = "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/common/formula/DeductionFormulaTest.metta" 0)
<span class="ansi1">LoonIt Report
</span>------------
<span class="ansi32">Successes: 5
</span><span class="ansi31">Failures: 0
</span><br/><a href="https://github.com/logicmoo/vspace-metta/blob/main/MeTTaLog.md">Return to Summaries</a><br/>
doing(ansi2html -u < "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/TEE.ansi" > "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/common/formula/DeductionFormulaTest.html" )

</pre>
</body>

</html>
