<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>
<style type="text/css">
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi36 { color: #00aaaa; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content">
 (@ track_load_into_file "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/hyperon-pln/metta/backward-chainer/backward-chainer-xp.metta")
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/hyperon-pln/metta/backward-chainer/backward-chainer-xp.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/hyperon-pln/metta/backward-chainer/backward-chainer-xp.metta')
1=["=== Bare Entail ==="]
2=[()]
3=[()]
4=[()]
5=[()]
6=["=== Equality ==="]
7=[()]
8=[()]
9=[()]
10=[()]
11=[()]
12=[()]
13=["=== Bare Entail Match ==="]
14=[()]
15=[()]
16=[()]
17=[()]
18=[()]
19=[()]
20=[()]
21=[()]
22=[()]
23=[()]
24=[()]
25=[()]
26=[()]
27=["=== Equality Match ==="]
28=[()]
29=[()]
30=[()]
31=[()]
32=[()]
33=[()]
34=[()]
35=[()]
36=[()]
37=[()]
38=["=== DTL Equality Match ==="]
39=[()]
40=[()]
41=[()]
42=[()]
43=[()]
44=[()]
45=[()]
46=[()]
47=[()]
48=[()]
49=[()]
50=4.21user 0.01system 0:04.23elapsed 99%CPU (0avgtext+0avgdata 34472maxresident)k
50=0inputs+0outputs (0major+3875minor)pagefaults 0swaps
;;;;;;;;;;
;;; Nat ;;
;;;;;;;;;;
;; Define Nat
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Nat','Type'])
</span><span class="ansi38-255165000">  (: Nat Type)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Z','Nat'])
</span><span class="ansi38-255165000">  (: Z Nat)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'S',[->,'Nat','Nat']])
</span><span class="ansi38-255165000">  (: S 
    (-> Nat Nat))
</span>

;; Define <=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,<=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: <= 
    (-> $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[<=,X,Y],[or,[<,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">  (= 
    (<= $X $Y) 
    (or 
      (< $X $Y) 
      (== $X $Y)))
</span>

;; Define cast functions between Nat and Number
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNumber,[->,'Number','Nat']])
</span><span class="ansi38-255165000">  (: fromNumber 
    (-> Number Nat))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNumber,N],[if,[<=,N,0],'Z',['S',[fromNumber,[-,N,1]]]])
</span><span class="ansi38-255165000">  (= 
    (fromNumber $N) 
    (if 
      (<= $N 0) Z 
      (S 
        (fromNumber 
          (- $N 1)))))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNat,[->,'Nat','Number']])
</span><span class="ansi38-255165000">  (: fromNat 
    (-> Nat Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,'Z'],0)
</span><span class="ansi38-255165000">  (= 
    (fromNat Z) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,['S',K]],[+,1,[fromNat,K]])
</span><span class="ansi38-255165000">  (= 
    (fromNat 
      (S $K)) 
    (+ 1 
      (fromNat $K)))
</span>

;;;;;;;;;;;;;;;;;
;; Bare Entail ;;
;;;;;;;;;;;;;;;;;
;; Variant of entail where â¢ is not wrapped around the knowledge base.
<span class="ansi38-000068000">!"=== Bare Entail ==="

</span><span class="ansi33"> "=== Bare Entail ==="

</span>;; Backward chainer
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,bc_bare,[->,'Atom',[->,'Atom'],[->,'Atom'],'Nat','Atom']])
</span><span class="ansi38-255165000">  (: bc_bare 
    (-> Atom 
      (-> Atom) 
      (-> Atom) Nat Atom))
</span>

;; Base case
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[bc_bare,Conclusion,Kb,Rb,Depth],[let,Conclusion,[Kb],Conclusion])
</span><span class="ansi38-255165000">  (= 
    (bc_bare $Conclusion $Kb $Rb $Depth) 
    (let $Conclusion 
      ($Kb) $Conclusion))
</span>

;; Recursive step
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[bc_bare,Conclusion,Kb,Rb,['S',K]],['let*',[[['â\x8A\¢',Premise1,Premise2,Conclusion],[Rb]],[Premise1,[bc_bare,Premise1,Kb,Rb,K]],[Premise2,[bc_bare,Premise2,Kb,Rb,K]]],Conclusion])
</span><span class="ansi38-255165000">  (= 
    (bc_bare $Conclusion $Kb $Rb 
      (S $K)) 
    (let* 
      ( ( (â¢ $Premise1 $Premise2 $Conclusion) 
          ($Rb)) 
        ($Premise1 
          (bc_bare $Premise1 $Kb $Rb $K)) 
        ($Premise2 
          (bc_bare $Premise2 $Kb $Rb $K))) $Conclusion))
</span>

;; Knowledge base
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,kb_bare,[->,'Atom']])
</span><span class="ansi38-255165000">  (: kb_bare 
    (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[kb_bare],[superpose,[['â\x86\\x92\','A','B'],['â\x86\\x92\','B','C'],'A']])
</span><span class="ansi38-255165000">  (= 
    (kb_bare) 
    (superpose 
      ( (â A B) 
        (â B C) A)))
</span>

;; Rule base
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,rb_bare,[->,'Atom']])
</span><span class="ansi38-255165000">  (: rb_bare 
    (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[rb_bare],['â\x8A\¢',['â\x86\\x92\',P,Q],P,Q])
</span><span class="ansi38-255165000">  (= 
    (rb_bare) 
    (â¢ 
      (â $P $Q) $P $Q))
</span>

;; Premises
;; Conclusion
;; Test backward chainer
<span class="ansi38-000068000">!(assertEqual 
  (bc_bare A kb_bare rb_bare Z) A)

</span><h3 id="BACKWARD-CHAINER.BACKWARD-CHAINER-XP.01">;; BACKWARD-CHAINER.BACKWARD-CHAINER-XP.01</h3>
; 
; EVAL TEST
; took 0.534 ms. (534.10 microseconds) 
<span class="ansi36">(@ loonit_success 
  (equal_enough_for_test  
    (A) 
    (A)))
</span><span class="ansi33"> Empty

</span><span class="ansi38-000068000">!(assertEqual 
  (bc_bare B kb_bare rb_bare 
    (fromNumber 1)) B)

</span><h3 id="BACKWARD-CHAINER.BACKWARD-CHAINER-XP.02">;; BACKWARD-CHAINER.BACKWARD-CHAINER-XP.02</h3>
; 
; EVAL TEST
; took 8.01 ms.
<span class="ansi36">(@ loonit_success 
  (equal_enough_for_test  
    (B B B) 
    (B)))
</span><span class="ansi33"> Empty

</span><span class="ansi38-000068000">!(assertEqual 
  (bc_bare C kb_bare rb_bare 
    (fromNumber 2)) C)

</span><h3 id="BACKWARD-CHAINER.BACKWARD-CHAINER-XP.03">;; BACKWARD-CHAINER.BACKWARD-CHAINER-XP.03</h3>
; 
; EVAL TEST
; took 52.54 ms.
<span class="ansi36">(@ loonit_success 
  (equal_enough_for_test  
    (C C C C C C C C C) 
    (C)))
</span><span class="ansi33"> Empty

</span><span class="ansi38-000068000">!(assertEqualToResult 
  (bc_bare D kb_bare rb_bare 
    (fromNumber 4)) ())

</span><h3 id="BACKWARD-CHAINER.BACKWARD-CHAINER-XP.04">;; BACKWARD-CHAINER.BACKWARD-CHAINER-XP.04</h3>
; 
; EVAL TEST
; took 622.83 ms.
<span class="ansi36">(@ loonit_success 
  (equal_enough_for_test  () ()))
</span><span class="ansi33"> Empty

</span>;;;;;;;;;;;;;;
;; Equality ;;
;;;;;;;;;;;;;;
<span class="ansi38-000068000">!"=== Equality ==="

</span><span class="ansi33"> "=== Equality ==="

</span>;; Knowledge base
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,kb_eq,[->,'Atom']])
</span><span class="ansi38-255165000">  (: kb_eq 
    (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[kb_eq],[superpose,[['â\x86\\x92\','A','B'],['â\x86\\x92\','B','C'],'A']])
</span><span class="ansi38-255165000">  (= 
    (kb_eq) 
    (superpose 
      ( (â A B) 
        (â B C) A)))
</span>

;; Backward chainer.  The rule based is directly embedded in the
;; backward chainer function.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,bc_eq,[->,'Atom',[->,'Atom'],'Nat','Atom']])
</span><span class="ansi38-255165000">  (: bc_eq 
    (-> Atom 
      (-> Atom) Nat Atom))
</span>

;; Base case
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[bc_eq,Conclusion,Kb,Depth],[let,Conclusion,[Kb],Conclusion])
</span><span class="ansi38-255165000">  (= 
    (bc_eq $Conclusion $Kb $Depth) 
    (let $Conclusion 
      ($Kb) $Conclusion))
</span>

;; Recursive step (modus ponens)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[bc_eq,Q,Kb,['S',K]],['let*',[[['â\x86\\x92\',P,Q],[bc_eq,['â\x86\\x92\',P,Q],Kb,K]],[P,[bc_eq,P,Kb,K]]],Q])
</span><span class="ansi38-255165000">  (= 
    (bc_eq $Q $Kb 
      (S $K)) 
    (let* 
      ( ( (â $P $Q) 
          (bc_eq 
            (â $P $Q) $Kb $K)) 
        ($P 
          (bc_eq $P $Kb $K))) $Q))
</span>

; premise1
; premise2
; conclusion
;; Recursive step (deduction)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[bc_eq,['â\x86\\x92\',P,R],Kb,['S',K]],['let*',[[['â\x86\\x92\',P,Q],[bc_eq,['â\x86\\x92\',P,Q],Kb,K]],[['â\x86\\x92\',Q,R],[bc_eq,['â\x86\\x92\',Q,R],Kb,K]]],['â\x86\\x92\',P,R]])
</span><span class="ansi38-255165000">  (= 
    (bc_eq 
      (â $P $R) $Kb 
      (S $K)) 
    (let* 
      ( ( (â $P $Q) 
          (bc_eq 
            (â $P $Q) $Kb $K)) 
        ( (â $Q $R) 
          (bc_eq 
            (â $Q $R) $Kb $K))) 
      (â $P $R)))
</span>

; premise1
; premise2
; conclusion
;; Test backward chainer
<span class="ansi38-000068000">!(assertEqual 
  (bc_eq A kb_eq Z) A)

</span><h3 id="BACKWARD-CHAINER.BACKWARD-CHAINER-XP.05">;; BACKWARD-CHAINER.BACKWARD-CHAINER-XP.05</h3>
; 
; EVAL TEST
; took 0.444 ms. (443.60 microseconds) 
<span class="ansi36">(@ loonit_success 
  (equal_enough_for_test  
    (A) 
    (A)))
</span><span class="ansi33"> Empty

</span><span class="ansi38-000068000">!(assertEqual 
  (bc_eq B kb_eq 
    (fromNumber 1)) B)

</span><h3 id="BACKWARD-CHAINER.BACKWARD-CHAINER-XP.06">;; BACKWARD-CHAINER.BACKWARD-CHAINER-XP.06</h3>
; 
; EVAL TEST
; took 8.65 ms.
<span class="ansi36">(@ loonit_success 
  (equal_enough_for_test  
    (B B B) 
    (B)))
</span><span class="ansi33"> Empty

</span><span class="ansi38-000068000">!(assertEqualToResult 
  (bc_eq C kb_eq 
    (fromNumber 2)) 
  (C C))

</span><h3 id="BACKWARD-CHAINER.BACKWARD-CHAINER-XP.07">;; BACKWARD-CHAINER.BACKWARD-CHAINER-XP.07</h3>
; 
; EVAL TEST
; took 77.59 ms.
<span class="ansi36">(@ loonit_success 
  (equal_enough_for_test  
    (C C C C C C C C C C C C C C C C C C) 
    (C C)))
</span><span class="ansi33"> Empty

</span>; 2 modus ponens
; deduction + modus ponens
<span class="ansi38-000068000">!(assertEqual 
  (bc_eq 
    (â A B) kb_eq 
    (fromNumber 0)) 
  (â A B))

</span><h3 id="BACKWARD-CHAINER.BACKWARD-CHAINER-XP.08">;; BACKWARD-CHAINER.BACKWARD-CHAINER-XP.08</h3>
; 
; EVAL TEST
; took 0.776 ms. (776.10 microseconds) 
<span class="ansi36">(@ loonit_success 
  (equal_enough_for_test  
    ( (â A B)) 
    ( (â A B))))
</span><span class="ansi33"> Empty

</span><span class="ansi38-000068000">!(assertEqual 
  (bc_eq 
    (â B C) kb_eq 
    (fromNumber 0)) 
  (â B C))

</span><h3 id="BACKWARD-CHAINER.BACKWARD-CHAINER-XP.09">;; BACKWARD-CHAINER.BACKWARD-CHAINER-XP.09</h3>
; 
; EVAL TEST
; took 0.919 ms. (919.30 microseconds) 
<span class="ansi36">(@ loonit_success 
  (equal_enough_for_test  
    ( (â B C)) 
    ( (â B C))))
</span><span class="ansi33"> Empty

</span><span class="ansi38-000068000">!(assertEqual 
  (bc_eq 
    (â A C) kb_eq 
    (fromNumber 2)) 
  (â A C))

</span><h3 id="BACKWARD-CHAINER.BACKWARD-CHAINER-XP.10">;; BACKWARD-CHAINER.BACKWARD-CHAINER-XP.10</h3>
; 
; EVAL TEST
; took 0.596 ms. (595.70 microseconds) 
<span class="ansi31">(@ loonit_failureR 
  (equal_enough_for_test  () 
    ( (â A C))))
</span>; Trace took 0.577 ms. (577.20 microseconds) 
<span class="ansi33">  (got () expected 
    ( (â A C)))

</span>;;;;;;;;;;;;;;;;;;;;;;;
;; Bare Entail Match ;;
;;;;;;;;;;;;;;;;;;;;;;;
;; Like bare entail but let is replaced by match
<span class="ansi38-000068000">!"=== Bare Entail Match ==="

</span><span class="ansi33"> "=== Bare Entail Match ==="

</span>;; Knowledge base
<span class="ansi38-000068000">!(bind! &kb_bem 
  (new-space))

</span><span class="ansi33"> Empty

</span><span class="ansi38-000068000">!(add-atom &kb_bem 
  (â A B))

</span>; (add-atom &kb_bem 
    (â A B))
; (type-method is_not_meTTa_space &kb_bem add_to_space)
<span class="ansi31">
! (assertEqualToResult 
    (add-atom &kb_bem 
      (â A B)) 
    (()))
(@ ! 
  (assertEqual () 
    (())))
write_pass_fail_result("BACKWARD-CHAINER.BACKWARD-CHAINER-XP.115",exec,['add-atom','&kb_bem',['â\x86\\x92\','A','B']],'FAIL',[[]],[])

</span>

--------------------------------------------------------------------------
<span class="ansi38-000068000">!(add-atom &kb_bem 
  (â B C))

</span>; (add-atom &kb_bem 
    (â B C))
; (type-method is_not_meTTa_space &kb_bem add_to_space)
<span class="ansi31">
! (assertEqualToResult 
    (add-atom &kb_bem 
      (â B C)) 
    (()))
(@ ! 
  (assertEqual () 
    (())))
write_pass_fail_result("BACKWARD-CHAINER.BACKWARD-CHAINER-XP.116",exec,['add-atom','&kb_bem',['â\x86\\x92\','B','C']],'FAIL',[[]],[])

</span>

--------------------------------------------------------------------------
<span class="ansi38-000068000">!(add-atom &kb_bem A)

</span>; (add-atom &kb_bem A)
; (type-method is_not_meTTa_space &kb_bem add_to_space)
<span class="ansi31">
! (assertEqualToResult 
    (add-atom &kb_bem A) 
    (()))
(@ ! 
  (assertEqual () 
    (())))
write_pass_fail_result("BACKWARD-CHAINER.BACKWARD-CHAINER-XP.117",exec,['add-atom','&kb_bem','A'],'FAIL',[[]],[])

</span>

--------------------------------------------------------------------------
;; Rule base
<span class="ansi38-000068000">!(bind! &rb_bem 
  (new-space))

</span><span class="ansi33"> Empty

</span><span class="ansi38-000068000">!(add-atom &rb_bem 
  (â¢ 
    (â $P $Q) $P $Q))

</span>; (add-atom &rb_bem 
    (â¢ 
      (â $_138478 $_138762) $_138478 $_138762))
; (type-method is_not_meTTa_space &rb_bem add_to_space)
<span class="ansi31">
! (assertEqualToResult 
    (add-atom &rb_bem 
      (â¢ 
        (â $P $Q) $P $Q)) 
    (()))
(@ ! 
  (assertEqual () 
    (())))
write_pass_fail_result("BACKWARD-CHAINER.BACKWARD-CHAINER-XP.119",exec,['add-atom','&rb_bem',['â\x8A\¢',['â\x86\\x92\',P,Q],P,Q]],'FAIL',[[]],[])

</span>

--------------------------------------------------------------------------
;; Premises
;; Conclusion
<span class="ansi38-000068000">!(add-atom &rb_bem 
  (â¢ 
    (â $P $Q) 
    (â $Q $R) 
    (â $P $R)))

</span>; (add-atom &rb_bem 
    (â¢ 
      (â $_222670 $_222954) 
      (â $_222954 $_223534) 
      (â $_222670 $_223534)))
; (type-method is_not_meTTa_space &rb_bem add_to_space)
<span class="ansi31">
! (assertEqualToResult 
    (add-atom &rb_bem 
      (â¢ 
        (â $P $Q) 
        (â $Q $R) 
        (â $P $R))) 
    (()))
(@ ! 
  (assertEqual () 
    (())))
write_pass_fail_result("BACKWARD-CHAINER.BACKWARD-CHAINER-XP.120",exec,['add-atom','&rb_bem',['â\x8A\¢',['â\x86\\x92\',P,Q],['â\x86\\x92\',Q,R],['â\x86\\x92\',P,R]]],'FAIL',[[]],[])

</span>

--------------------------------------------------------------------------
;; Premises
;; Conclusion
;; Backward chainer
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,bc_bem,[->,'Atom','Nat','Atom']])
</span><span class="ansi38-255165000">  (: bc_bem 
    (-> Atom Nat Atom))
</span>

;; Base case
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[bc_bem,Conclusion,Depth],[match,'&kb_bem',Conclusion,Conclusion])
</span><span class="ansi38-255165000">  (= 
    (bc_bem $Conclusion $Depth) 
    (match &kb_bem $Conclusion $Conclusion))
</span>

;; Recursive step
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[bc_bem,Conclusion,['S',K]],[match,'&rb_bem',['â\x8A\¢',Premise1,Premise2,Conclusion],['let*',[[Premise1,[bc_bem,Premise1,K]],[Premise2,[bc_bem,Premise2,K]]],Conclusion]])
</span><span class="ansi38-255165000">  (= 
    (bc_bem $Conclusion 
      (S $K)) 
    (match &rb_bem 
      (â¢ $Premise1 $Premise2 $Conclusion) 
      (let* 
        ( ($Premise1 
            (bc_bem $Premise1 $K)) 
          ($Premise2 
            (bc_bem $Premise2 $K))) $Conclusion)))
</span>

;; Test backward chainer
<span class="ansi38-000068000">!(assertEqual 
  (bc_bem A Z) A)

</span><h3 id="BACKWARD-CHAINER.BACKWARD-CHAINER-XP.11">;; BACKWARD-CHAINER.BACKWARD-CHAINER-XP.11</h3>
; 
; EVAL TEST
; took 0.102 ms. (102.00 microseconds) 
<span class="ansi31">(@ loonit_failureR 
  (equal_enough_for_test  () 
    (A)))
</span>; Trace took 0.072 ms. (72.40 microseconds) 
<span class="ansi33">  (got () expected 
    (A))

</span><span class="ansi38-000068000">!(assertEqual 
  (bc_bem B 
    (fromNumber 1)) B)

</span><h3 id="BACKWARD-CHAINER.BACKWARD-CHAINER-XP.12">;; BACKWARD-CHAINER.BACKWARD-CHAINER-XP.12</h3>
; 
; EVAL TEST
; took 1.92 ms.
<span class="ansi31">(@ loonit_failureR 
  (equal_enough_for_test  () 
    (B)))
</span>; Trace took 1.91 ms.
<span class="ansi33">  (got () expected 
    (B))

</span><span class="ansi38-000068000">!(assertEqualToResult 
  (bc_bem C 
    (fromNumber 2)) 
  (C C))

</span><h3 id="BACKWARD-CHAINER.BACKWARD-CHAINER-XP.13">;; BACKWARD-CHAINER.BACKWARD-CHAINER-XP.13</h3>
; 
; EVAL TEST
; took 7.09 ms.
<span class="ansi31">(@ loonit_failureR 
  (equal_enough_for_test  () 
    (C C)))
</span>; Trace took 7.00 ms.
<span class="ansi33">  (got () expected 
    (C C))

</span>; 2 modus ponens
; deduction + modus ponens
<span class="ansi38-000068000">!(assertEqual 
  (bc_bem 
    (â A B) 
    (fromNumber 0)) 
  (â A B))

</span><h3 id="BACKWARD-CHAINER.BACKWARD-CHAINER-XP.14">;; BACKWARD-CHAINER.BACKWARD-CHAINER-XP.14</h3>
; 
; EVAL TEST
; took 0.278 ms. (278.40 microseconds) 
<span class="ansi31">(@ loonit_failureR 
  (equal_enough_for_test  () 
    ( (â A B))))
</span>; Trace took 0.221 ms. (220.80 microseconds) 
<span class="ansi33">  (got () expected 
    ( (â A B)))

</span><span class="ansi38-000068000">!(assertEqual 
  (bc_bem 
    (â B C) 
    (fromNumber 0)) 
  (â B C))

</span><h3 id="BACKWARD-CHAINER.BACKWARD-CHAINER-XP.15">;; BACKWARD-CHAINER.BACKWARD-CHAINER-XP.15</h3>
; 
; EVAL TEST
; took 0.267 ms. (267.50 microseconds) 
<span class="ansi31">(@ loonit_failureR 
  (equal_enough_for_test  () 
    ( (â B C))))
</span>; Trace took 0.225 ms. (225.50 microseconds) 
<span class="ansi33">  (got () expected 
    ( (â B C)))

</span><span class="ansi38-000068000">!(assertEqual 
  (bc_bem 
    (â A C) 
    (fromNumber 2)) 
  (â A C))

</span><h3 id="BACKWARD-CHAINER.BACKWARD-CHAINER-XP.16">;; BACKWARD-CHAINER.BACKWARD-CHAINER-XP.16</h3>
; 
; EVAL TEST
; took 0.446 ms. (446.10 microseconds) 
<span class="ansi31">(@ loonit_failureR 
  (equal_enough_for_test  () 
    ( (â A C))))
</span>; Trace took 0.326 ms. (325.60 microseconds) 
<span class="ansi33">  (got () expected 
    ( (â A C)))

</span>;;;;;;;;;;;;;;;;;;;;
;; Equality Match ;;
;;;;;;;;;;;;;;;;;;;;
;; Like equality but let is replaced by match
<span class="ansi38-000068000">!"=== Equality Match ==="

</span><span class="ansi33"> "=== Equality Match ==="

</span>;; Knowledge base
<span class="ansi38-000068000">!(bind! &kb_em 
  (new-space))

</span><span class="ansi33"> Empty

</span><span class="ansi38-000068000">!(add-atom &kb_em 
  (â A B))

</span>; (add-atom &kb_em 
    (â A B))
; (type-method is_not_meTTa_space &kb_em add_to_space)
<span class="ansi31">
! (assertEqualToResult 
    (add-atom &kb_em 
      (â A B)) 
    (()))
(@ ! 
  (assertEqual () 
    (())))
write_pass_fail_result("BACKWARD-CHAINER.BACKWARD-CHAINER-XP.129",exec,['add-atom','&kb_em',['â\x86\\x92\','A','B']],'FAIL',[[]],[])

</span>

--------------------------------------------------------------------------
<span class="ansi38-000068000">!(add-atom &kb_em 
  (â B C))

</span>; (add-atom &kb_em 
    (â B C))
; (type-method is_not_meTTa_space &kb_em add_to_space)
<span class="ansi31">
! (assertEqualToResult 
    (add-atom &kb_em 
      (â B C)) 
    (()))
(@ ! 
  (assertEqual () 
    (())))
write_pass_fail_result("BACKWARD-CHAINER.BACKWARD-CHAINER-XP.130",exec,['add-atom','&kb_em',['â\x86\\x92\','B','C']],'FAIL',[[]],[])

</span>

--------------------------------------------------------------------------
<span class="ansi38-000068000">!(add-atom &kb_em A)

</span>; (add-atom &kb_em A)
; (type-method is_not_meTTa_space &kb_em add_to_space)
<span class="ansi31">
! (assertEqualToResult 
    (add-atom &kb_em A) 
    (()))
(@ ! 
  (assertEqual () 
    (())))
write_pass_fail_result("BACKWARD-CHAINER.BACKWARD-CHAINER-XP.131",exec,['add-atom','&kb_em','A'],'FAIL',[[]],[])

</span>

--------------------------------------------------------------------------
;; Backward chainer.  The rule based is directly embedded in the
;; backward chainer function.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,bc_em,[->,'Atom','Nat','Atom']])
</span><span class="ansi38-255165000">  (: bc_em 
    (-> Atom Nat Atom))
</span>

;; Base case
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[bc_em,Conclusion,Depth],[match,'&kb_em',Conclusion,Conclusion])
</span><span class="ansi38-255165000">  (= 
    (bc_em $Conclusion $Depth) 
    (match &kb_em $Conclusion $Conclusion))
</span>

;; Recursive step (modus ponens)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[bc_em,Q,['S',K]],['let*',[[['â\x86\\x92\',P,Q],[bc_em,['â\x86\\x92\',P,Q],K]],[P,[bc_em,P,K]]],Q])
</span><span class="ansi38-255165000">  (= 
    (bc_em $Q 
      (S $K)) 
    (let* 
      ( ( (â $P $Q) 
          (bc_em 
            (â $P $Q) $K)) 
        ($P 
          (bc_em $P $K))) $Q))
</span>

; premise1
; premise2
; conclusion
;; Recursive step (deduction)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[bc_em,['â\x86\\x92\',P,R],['S',K]],['let*',[[['â\x86\\x92\',P,Q],[bc_em,['â\x86\\x92\',P,Q],K]],[['â\x86\\x92\',Q,R],[bc_em,['â\x86\\x92\',Q,R],K]]],['â\x86\\x92\',P,R]])
</span><span class="ansi38-255165000">  (= 
    (bc_em 
      (â $P $R) 
      (S $K)) 
    (let* 
      ( ( (â $P $Q) 
          (bc_em 
            (â $P $Q) $K)) 
        ( (â $Q $R) 
          (bc_em 
            (â $Q $R) $K))) 
      (â $P $R)))
</span>

; premise1
; premise2
; conclusion
;; Test backward chainer
<span class="ansi38-000068000">!(assertEqual 
  (bc_em A Z) A)

</span><h3 id="BACKWARD-CHAINER.BACKWARD-CHAINER-XP.17">;; BACKWARD-CHAINER.BACKWARD-CHAINER-XP.17</h3>
; 
; EVAL TEST
; took 0.104 ms. (104.40 microseconds) 
<span class="ansi31">(@ loonit_failureR 
  (equal_enough_for_test  () 
    (A)))
</span>; Trace took 0.120 ms. (120.00 microseconds) 
<span class="ansi33">  (got () expected 
    (A))

</span><span class="ansi38-000068000">!(assertEqual 
  (bc_em B 
    (fromNumber 1)) B)

</span><h3 id="BACKWARD-CHAINER.BACKWARD-CHAINER-XP.18">;; BACKWARD-CHAINER.BACKWARD-CHAINER-XP.18</h3>
; 
; EVAL TEST
; took 2.65 ms.
<span class="ansi31">(@ loonit_failureR 
  (equal_enough_for_test  () 
    (B)))
</span>; Trace took 2.42 ms.
<span class="ansi33">  (got () expected 
    (B))

</span><span class="ansi38-000068000">!(assertEqualToResult 
  (bc_em C 
    (fromNumber 2)) 
  (C C))

</span><h3 id="BACKWARD-CHAINER.BACKWARD-CHAINER-XP.19">;; BACKWARD-CHAINER.BACKWARD-CHAINER-XP.19</h3>
; 
; EVAL TEST
; took 14.82 ms.
<span class="ansi31">(@ loonit_failureR 
  (equal_enough_for_test  () 
    (C C)))
</span>; Trace took 13.92 ms.
<span class="ansi33">  (got () expected 
    (C C))

</span>; 2 modus ponens
; deduction + modus ponens
<span class="ansi38-000068000">!(assertEqual 
  (bc_em 
    (â A B) 
    (fromNumber 0)) 
  (â A B))

</span><h3 id="BACKWARD-CHAINER.BACKWARD-CHAINER-XP.20">;; BACKWARD-CHAINER.BACKWARD-CHAINER-XP.20</h3>
; 
; EVAL TEST
; took 0.288 ms. (288.30 microseconds) 
<span class="ansi31">(@ loonit_failureR 
  (equal_enough_for_test  () 
    ( (â A B))))
</span>; Trace took 0.239 ms. (238.60 microseconds) 
<span class="ansi33">  (got () expected 
    ( (â A B)))

</span><span class="ansi38-000068000">!(assertEqual 
  (bc_em 
    (â B C) 
    (fromNumber 0)) 
  (â B C))

</span><h3 id="BACKWARD-CHAINER.BACKWARD-CHAINER-XP.21">;; BACKWARD-CHAINER.BACKWARD-CHAINER-XP.21</h3>
; 
; EVAL TEST
; took 0.366 ms. (365.50 microseconds) 
<span class="ansi31">(@ loonit_failureR 
  (equal_enough_for_test  () 
    ( (â B C))))
</span>; Trace took 0.239 ms. (239.10 microseconds) 
<span class="ansi33">  (got () expected 
    ( (â B C)))

</span><span class="ansi38-000068000">!(assertEqual 
  (bc_em 
    (â A C) 
    (fromNumber 2)) 
  (â A C))

</span><h3 id="BACKWARD-CHAINER.BACKWARD-CHAINER-XP.22">;; BACKWARD-CHAINER.BACKWARD-CHAINER-XP.22</h3>
; 
; EVAL TEST
; took 0.311 ms. (311.10 microseconds) 
<span class="ansi31">(@ loonit_failureR 
  (equal_enough_for_test  () 
    ( (â A C))))
</span>; Trace took 0.253 ms. (253.00 microseconds) 
<span class="ansi33">  (got () expected 
    ( (â A C)))

</span>;;;;;;;;;;;;;;;;;;;;;;;;
;; DTL Equality Match ;;
;;;;;;;;;;;;;;;;;;;;;;;;
;; Like DTL (Synthesizer) but the rules are hard wired in the backward
;; chainer and match is used instead of let (as far as matching
;; premises is concerned).
<span class="ansi38-000068000">!"=== DTL Equality Match ==="

</span><span class="ansi33"> "=== DTL Equality Match ==="

</span>;; Knowledge base
<span class="ansi38-000068000">!(bind! &kb_dem 
  (new-space))

</span><span class="ansi33"> Empty

</span><span class="ansi38-000068000">!(add-atom &kb_dem 
  (: ab 
    (â A B)))

</span>; (add-atom &kb_dem 
    (: ab 
      (â A B)))
; (type-method is_not_meTTa_space &kb_dem add_to_space)
<span class="ansi31">
! (assertEqualToResult 
    (add-atom &kb_dem 
      (: ab 
        (â A B))) 
    (()))
(@ ! 
  (assertEqual () 
    (())))
write_pass_fail_result("BACKWARD-CHAINER.BACKWARD-CHAINER-XP.140",exec,['add-atom','&kb_dem',[:,ab,['â\x86\\x92\','A','B']]],'FAIL',[[]],[])

</span>

--------------------------------------------------------------------------
<span class="ansi38-000068000">!(add-atom &kb_dem 
  (: bc 
    (â B C)))

</span>; (add-atom &kb_dem 
    (: bc 
      (â B C)))
; (type-method is_not_meTTa_space &kb_dem add_to_space)
<span class="ansi31">
! (assertEqualToResult 
    (add-atom &kb_dem 
      (: bc 
        (â B C))) 
    (()))
(@ ! 
  (assertEqual () 
    (())))
write_pass_fail_result("BACKWARD-CHAINER.BACKWARD-CHAINER-XP.141",exec,['add-atom','&kb_dem',[:,bc,['â\x86\\x92\','B','C']]],'FAIL',[[]],[])

</span>

--------------------------------------------------------------------------
<span class="ansi38-000068000">!(add-atom &kb_dem 
  (: a A))

</span>; (add-atom &kb_dem 
    (: a A))
; (type-method is_not_meTTa_space &kb_dem add_to_space)
<span class="ansi31">
! (assertEqualToResult 
    (add-atom &kb_dem 
      (: a A)) 
    (()))
(@ ! 
  (assertEqual () 
    (())))
write_pass_fail_result("BACKWARD-CHAINER.BACKWARD-CHAINER-XP.142",exec,['add-atom','&kb_dem',[:,a,'A']],'FAIL',[[]],[])

</span>

--------------------------------------------------------------------------
;; Backward chainer.  The rule based is directly embedded in the
;; backward chainer function.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,bc_dem,[->,'Atom','Nat','Atom']])
</span><span class="ansi38-255165000">  (: bc_dem 
    (-> Atom Nat Atom))
</span>

;; Base case
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[bc_dem,[:,Prf,Conclusion],Depth],[match,'&kb_dem',[:,Prf,Conclusion],[:,Prf,Conclusion]])
</span><span class="ansi38-255165000">  (= 
    (bc_dem 
      (: $Prf $Conclusion) $Depth) 
    (match &kb_dem 
      (: $Prf $Conclusion) 
      (: $Prf $Conclusion)))
</span>

;; Recursive step (modus ponens)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[bc_dem,[:,Prf_q,Q],['S',K]],['let*',[[[:,Prf_pq,['â\x86\\x92\',P,Q]],[bc_dem,[:,Prf_pq,['â\x86\\x92\',P,Q]],K]],[[:,Prf_p,P],[bc_dem,[:,Prf_p,P],K]],[[:,['ModusPonens',Prf_pq,Prf_p],Q],[:,Prf_q,Q]]],[:,Prf_q,Q]])
</span><span class="ansi38-255165000">  (= 
    (bc_dem 
      (: $Prf_q $Q) 
      (S $K)) 
    (let* 
      ( ( (: $Prf_pq 
            (â $P $Q)) 
          (bc_dem 
            (: $Prf_pq 
              (â $P $Q)) $K)) 
        ( (: $Prf_p $P) 
          (bc_dem 
            (: $Prf_p $P) $K)) 
        ( (: 
            (ModusPonens $Prf_pq $Prf_p) $Q) 
          (: $Prf_q $Q))) 
      (: $Prf_q $Q)))
</span>

; premise1
; premise2
; conclusion
;; Recursive step (deduction)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[bc_dem,[:,Prf_pr,['â\x86\\x92\',P,R]],['S',K]],['let*',[[[:,Prf_pq,['â\x86\\x92\',P,Q]],[bc_dem,[:,Prf_pq,['â\x86\\x92\',P,Q]],K]],[[:,Prf_qr,['â\x86\\x92\',Q,R]],[bc_dem,[:,Prf_qr,['â\x86\\x92\',Q,R]],K]],[[:,['Deduction',Prf_pq,Prf_qr],['â\x86\\x92\',P,R]],[:,Prf_pr,['â\x86\\x92\',P,R]]]],[:,Prf_pr,['â\x86\\x92\',P,R]]])
</span><span class="ansi38-255165000">  (= 
    (bc_dem 
      (: $Prf_pr 
        (â $P $R)) 
      (S $K)) 
    (let* 
      ( ( (: $Prf_pq 
            (â $P $Q)) 
          (bc_dem 
            (: $Prf_pq 
              (â $P $Q)) $K)) 
        ( (: $Prf_qr 
            (â $Q $R)) 
          (bc_dem 
            (: $Prf_qr 
              (â $Q $R)) $K)) 
        ( (: 
            (Deduction $Prf_pq $Prf_qr) 
            (â $P $R)) 
          (: $Prf_pr 
            (â $P $R)))) 
      (: $Prf_pr 
        (â $P $R))))
</span>

; premise1
; premise2
; conclusion
;; Test backward chainer
<span class="ansi38-000068000">!(assertEqual 
  (bc_dem 
    (: $Prf A) Z) 
  (: a A))

</span><h3 id="BACKWARD-CHAINER.BACKWARD-CHAINER-XP.23">;; BACKWARD-CHAINER.BACKWARD-CHAINER-XP.23</h3>
; 
; EVAL TEST
; took 0.300 ms. (299.70 microseconds) 
<span class="ansi31">(@ loonit_failureR 
  (equal_enough_for_test  () 
    ( (: a A))))
</span>; Trace took 0.255 ms. (255.50 microseconds) 
<span class="ansi33">  (got () expected 
    ( (: a A)))

</span><span class="ansi38-000068000">!(assertEqual 
  (bc_dem 
    (: $Prf 
      (â A B)) Z) 
  (: ab 
    (â A B)))

</span><h3 id="BACKWARD-CHAINER.BACKWARD-CHAINER-XP.24">;; BACKWARD-CHAINER.BACKWARD-CHAINER-XP.24</h3>
; 
; EVAL TEST
; took 0.841 ms. (840.70 microseconds) 
<span class="ansi31">(@ loonit_failureR 
  (equal_enough_for_test  () 
    ( (: ab 
        (â A B)))))
</span>; Trace took 0.586 ms. (585.60 microseconds) 
<span class="ansi33">  (got () expected 
    ( (: ab 
        (â A B))))

</span><span class="ansi38-000068000">!(assertEqual 
  (bc_dem 
    (: $Prf B) 
    (fromNumber 1)) 
  (: 
    (ModusPonens ab a) B))

</span><h3 id="BACKWARD-CHAINER.BACKWARD-CHAINER-XP.25">;; BACKWARD-CHAINER.BACKWARD-CHAINER-XP.25</h3>
; 
; EVAL TEST
; took 5.53 ms.
<span class="ansi31">(@ loonit_failureR 
  (equal_enough_for_test  () 
    ( (: 
        (ModusPonens ab a) B))))
</span>; Trace took 4.12 ms.
<span class="ansi33">  (got () expected 
    ( (: 
        (ModusPonens ab a) B)))

</span><span class="ansi38-000068000">!(assertEqualToResult 
  (bc_dem 
    (: $Prf C) 
    (fromNumber 2)) 
  ( (: 
      (ModusPonens bc 
        (ModusPonens ab a)) C) 
    (: 
      (ModusPonens 
        (Deduction ab bc) a) C)))

</span><h3 id="BACKWARD-CHAINER.BACKWARD-CHAINER-XP.26">;; BACKWARD-CHAINER.BACKWARD-CHAINER-XP.26</h3>
; 
; EVAL TEST
; took 21.19 ms.
<span class="ansi31">(@ loonit_failureR 
  (equal_enough_for_test  () 
    ( (: 
        (ModusPonens bc 
          (ModusPonens ab a)) C) 
      (: 
        (ModusPonens 
          (Deduction ab bc) a) C))))
</span>; Trace took 20.51 ms.
<span class="ansi33">  (got () expected 
    ( (: 
        (ModusPonens bc 
          (ModusPonens ab a)) C) 
      (: 
        (ModusPonens 
          (Deduction ab bc) a) C)))

</span><span class="ansi38-000068000">!(assertEqual 
  (bc_dem 
    (: $Prf 
      (â A B)) 
    (fromNumber 0)) 
  (: ab 
    (â A B)))

</span><h3 id="BACKWARD-CHAINER.BACKWARD-CHAINER-XP.27">;; BACKWARD-CHAINER.BACKWARD-CHAINER-XP.27</h3>
; 
; EVAL TEST
; took 0.570 ms. (570.40 microseconds) 
<span class="ansi31">(@ loonit_failureR 
  (equal_enough_for_test  () 
    ( (: ab 
        (â A B)))))
</span>; Trace took 0.557 ms. (556.90 microseconds) 
<span class="ansi33">  (got () expected 
    ( (: ab 
        (â A B))))

</span><span class="ansi38-000068000">!(assertEqual 
  (bc_dem 
    (: $Prf 
      (â B C)) 
    (fromNumber 0)) 
  (: bc 
    (â B C)))

</span><h3 id="BACKWARD-CHAINER.BACKWARD-CHAINER-XP.28">;; BACKWARD-CHAINER.BACKWARD-CHAINER-XP.28</h3>
; 
; EVAL TEST
; took 0.547 ms. (547.00 microseconds) 
<span class="ansi31">(@ loonit_failureR 
  (equal_enough_for_test  () 
    ( (: bc 
        (â B C)))))
</span>; Trace took 0.671 ms. (671.00 microseconds) 
<span class="ansi33">  (got () expected 
    ( (: bc 
        (â B C))))

</span><span class="ansi38-000068000">!(assertEqual 
  (bc_dem 
    (: $Prf 
      (â A C)) 
    (fromNumber 2)) 
  (: 
    (Deduction ab bc) 
    (â A C)))

</span><h3 id="BACKWARD-CHAINER.BACKWARD-CHAINER-XP.29">;; BACKWARD-CHAINER.BACKWARD-CHAINER-XP.29</h3>
; 
; EVAL TEST
; took 0.666 ms. (665.70 microseconds) 
<span class="ansi31">(@ loonit_failureR 
  (equal_enough_for_test  () 
    ( (: 
        (Deduction ab bc) 
        (â A C)))))
</span>; Trace took 0.874 ms. (873.70 microseconds) 
<span class="ansi33">  (got () expected 
    ( (: 
        (Deduction ab bc) 
        (â A C))))

</span><span class="ansi32">% 5,950,972 inferences, 2.837 CPU in 2.837 seconds (100% CPU, 2097952 Lips)
</span> (@ = "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/hyperon-pln/metta/backward-chainer/backward-chainer-xp.metta" 0)
<span class="ansi1">LoonIt Report
</span>------------
<span class="ansi32">Successes: 9
</span><span class="ansi31">Failures: 31
</span>doing(ansi2html -u < "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/TEE.ansi" > "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/hyperon-pln/metta/backward-chainer/backward-chainer-xp.html" )

</pre>
</body>

</html>
