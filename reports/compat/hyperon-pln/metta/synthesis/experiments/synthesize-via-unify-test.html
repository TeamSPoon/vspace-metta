<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>
<style type="text/css">
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi35 { color: #E850A8; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content">
 (track_load_into_file "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/hyperon-pln/metta/synthesis/experiments/synthesize-via-unify-test.metta")
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/hyperon-pln/metta/synthesis/experiments/synthesize-via-unify-test.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/hyperon-pln/metta/synthesis/experiments/synthesize-via-unify-test.metta')
:- dynamic file_answers/3.


;;; Import modules
<span class="ansi38-000068000">!(import! &self synthesize-via-unify.metta)

</span>%~ synthesize-via-unify.metta:1 
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/hyperon-pln/metta/synthesis/experiments/synthesize-via-unify.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/hyperon-pln/metta/synthesis/experiments/synthesize-via-unify.metta')
;;; Import modules
<span class="ansi38-000068000">!(import! &self "../../common/Num.metta")

</span>%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/hyperon-pln/metta/common/Num.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/hyperon-pln/metta/common/Num.metta')
;;; Collection of functions operating on numbers
;;; Define max
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,max,[[->,A,A,A]])
</span><span class="ansi38-255165000">(: max 
  (-> $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[max,X,Y],[if,[>,X,Y],X,Y])
</span><span class="ansi38-255165000">(= 
  (max $X $Y) 
  (if 
    (> $X $Y) $X $Y))
</span>

;;; Define min
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,min,[[->,A,A,A]])
</span><span class="ansi38-255165000">(: min 
  (-> $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[min,X,Y],[if,[<,X,Y],X,Y])
</span><span class="ansi38-255165000">(= 
  (min $X $Y) 
  (if 
    (< $X $Y) $X $Y))
</span>

;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,clamp,[[->,A,A,A,A]])
</span><span class="ansi38-255165000">(: clamp 
  (-> $A $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[clamp,X,L,U],[max,L,[min,U,X]])
</span><span class="ansi38-255165000">(= 
  (clamp $X $L $U) 
  (max $L 
    (min $U $X)))
</span>

;;; Define abs
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,abs,[[->,A,A]])
</span><span class="ansi38-255165000">(: abs 
  (-> $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[abs,X],[if,[<,X,0],[*,-1,X],X])
</span><span class="ansi38-255165000">(= 
  (abs $X) 
  (if 
    (< $X 0) 
    (* -1 $X) $X))
</span>

;;; Define <=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,<=,[[->,A,A,'Bool']])
</span><span class="ansi38-255165000">(: <= 
  (-> $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[<=,X,Y],[or,[<,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">(= 
  (<= $X $Y) 
  (or 
    (< $X $Y) 
    (== $X $Y)))
</span>

;;; Define >=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,>=,[[->,A,A,'Bool']])
</span><span class="ansi38-255165000">(: >= 
  (-> $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[>=,X,Y],[or,[>,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">(= 
  (>= $X $Y) 
  (or 
    (> $X $Y) 
    (== $X $Y)))
</span>

;;; Define approximately equal
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,approxEq,[[->,A,A,A,'Bool']])
</span><span class="ansi38-255165000">(: approxEq 
  (-> $A $A $A Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[approxEq,X,Y,Epsilon],[<=,[abs,[-,X,Y]],Epsilon])
</span><span class="ansi38-255165000">(= 
  (approxEq $X $Y $Epsilon) 
  (<= 
    (abs 
      (- $X $Y)) $Epsilon))
</span>

;;; Define Nat
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'Nat',['Type'])
</span><span class="ansi38-255165000">(: Nat Type)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'Z',['Nat'])
</span><span class="ansi38-255165000">(: Z Nat)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'S',[[->,'Nat','Nat']])
</span><span class="ansi38-255165000">(: S 
  (-> Nat Nat))
</span>

;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,fromNumber,[[->,'Number','Nat']])
</span><span class="ansi38-255165000">(: fromNumber 
  (-> Number Nat))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[fromNumber,N],[if,[<=,N,0],'Z',['S',[fromNumber,[-,N,1]]]])
</span><span class="ansi38-255165000">(= 
  (fromNumber $N) 
  (if 
    (<= $N 0) Z 
    (S 
      (fromNumber 
        (- $N 1)))))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,fromNat,[[->,'Nat','Number']])
</span><span class="ansi38-255165000">(: fromNat 
  (-> Nat Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[fromNat,'Z'],0)
</span><span class="ansi38-255165000">(= 
  (fromNat Z) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[fromNat,['S',K]],[+,1,[fromNat,K]])
</span><span class="ansi38-255165000">(= 
  (fromNat 
    (S $K)) 
  (+ 1 
    (fromNat $K)))
</span>

;;; Define a generic less than operator, â©», for Nat.  < cannot be used
;;; because it is a built-in, its type is hardwired and cannot be
;;; overloaded.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'â©»',[[->,'Nat','Nat','Bool']])
</span><span class="ansi38-255165000">(: â©» 
  (-> Nat Nat Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['â©»',_,'Z'],'False')
</span><span class="ansi38-255165000">(= 
  (â©» $_ Z) False)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['â©»','Z',['S',_]],'True')
</span><span class="ansi38-255165000">(= 
  (â©» Z 
    (S $_)) True)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['â©»',['S',X],['S',Y]],['â©»',X,Y])
</span><span class="ansi38-255165000">(= 
  (â©» 
    (S $X) 
    (S $Y)) 
  (â©» $X $Y))
</span>

;;; Overload â©» for Number.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'â©»',[[->,'Number','Number','Bool']])
</span><span class="ansi38-255165000">(: â©» 
  (-> Number Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['â©»',X,Y],[<,X,Y])
</span><span class="ansi38-255165000">(= 
  (â©» $X $Y) 
  (< $X $Y))
</span>

;;; Return the ceiling of a non negative number.  If the number is
;;; negative it returns 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,ceil,[[->,'Number','Number']])
</span><span class="ansi38-255165000">(: ceil 
  (-> Number Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[ceil,N],[fromNat,[fromNumber,N]])
</span><span class="ansi38-255165000">(= 
  (ceil $N) 
  (fromNat 
    (fromNumber $N)))
</span>

;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'number->bool',[[->,'Number','Bool']])
</span><span class="ansi38-255165000">(: number->bool 
  (-> Number Bool))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['number->bool',X],[<,0,X])
</span><span class="ansi38-255165000">(= 
  (number->bool $X) 
  (< 0 $X))
</span>

;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'bool->number',[[->,'Bool','Number']])
</span><span class="ansi38-255165000">(: bool->number 
  (-> Bool Number))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['bool->number','False'],0)
</span><span class="ansi38-255165000">(= 
  (bool->number False) 0)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['bool->number','True'],1)
</span><span class="ansi38-255165000">(= 
  (bool->number True) 1)
</span>

;;; Define a less than type.  Note that it is purposefully different
;;; than â©» as it is a type, not an operator.  Inhabitants of (â x y)
;;; are proofs that x â©» y == True.  For now â is only axiomatized for
;;; Nat.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'â\x8D\\x83\',[[->,T,T,'Type']])
</span><span class="ansi38-255165000">(: â 
  (-> $T $T Type))
</span>

;;; Zero is always less than the successor of something
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,['zero-lt-succ-axiom'],[[->,'Atom']])
</span><span class="ansi38-255165000">(: 
  (zero-lt-succ-axiom) 
  (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['zero-lt-succ-axiom'],[:,'ZeroLTSucc',['â\x8D\\x83\','Z',['S',K]]])
</span><span class="ansi38-255165000">(= 
  (zero-lt-succ-axiom) 
  (: ZeroLTSucc 
    (â Z 
      (S $K))))
</span>

;;; If x â y then (S x) â (S y)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,['succ-monotonicity-rule'],[[->,'Atom']])
</span><span class="ansi38-255165000">(: 
  (succ-monotonicity-rule) 
  (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['succ-monotonicity-rule'],[:,'SuccMonotonicity',[->,['â\x8D\\x83\',X,Y],['â\x8D\\x83\',['S',X],['S',Y]]]])
</span><span class="ansi38-255165000">(= 
  (succ-monotonicity-rule) 
  (: SuccMonotonicity 
    (-> 
      (â $X $Y) 
      (â 
        (S $X) 
        (S $Y)))))
</span>

; Evaluation took 264.36 milliseconds.
<span class="ansi33">Deterministic: </span><span class="ansi33">Empty
</span>
<span class="ansi38-000068000">!(import! &self "../Unify.metta")

</span>%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/hyperon-pln/metta/synthesis/Unify.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/hyperon-pln/metta/synthesis/Unify.metta')
;;; Enumerate all programs up to a given depth that are consistent with
;;; the query, using the given axioms and rules.
;;;
;;; The arguments are:
;;;
;;; $query: an Atom under the form (: TERM TYPE).  The atom may contain
;;;         free variables within TERM and TYPE to form various sort of
;;;         queries, such as:
;;;         1. Backward chaining: (: $term (Inheritance $x Mammal))
;;;         2. Forward chaining: (: ($rule $premise AXIOM) $type)
;;;         3. Mixed chaining: (: ($rule $premise AXIOM) (Inheritance $x Mammal))
;;;         4. Type checking: (: TERM TYPE)
;;;         5. Type inference: (: TERM $type)
;;;
;;; $axiom: a nullary function to axiom, to non-deterministically pick
;;;         up an axiom.  An axiom is an Atom of the form
;;;         (: TERM TYPE).
;;;
;;; $rule: a nullary function to rule, to non-deterministically pick up
;;;        a rule.  A rule is a function mapping premises to
;;;        conclusion, where premises and conclusion have the form
;;;        (: TERM TYPE).
;;;
;;; $depth: a Nat representing the maximum depth of the generated
;;;         programs.
;;;
;;; up to a given depth that are consistent with the query, using the
;;; provided rule and axiom non-deterministic functions.  An axiom is
;;; an Atom of the form
;;;
;;; TODO: recurse over curried rules instead of duplicating code over
;;; tuples.
;;; TODO: this should be revised as there is now a unify function in
;;; the standard library.
;;; Implement a unifier.  Like with `let` the left term must be an
;;; Atom, so if it is function it will not be evaluated.  The
;;; implementation however uses `case`, not `let`, that way it filters
;;; out terms which have not been fully rewritten.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,unify,[[->,'Atom',A,A,A]])
</span><span class="ansi38-255165000">(: unify 
  (-> Atom $A $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[unify,Lterm,Rterm,Rewrite],[case,Rterm,[[Lterm,Rewrite]]])
</span><span class="ansi38-255165000">(= 
  (unify $Lterm $Rterm $Rewrite) 
  (case $Rterm 
    ( ($Lterm $Rewrite))))
</span>

;;; Definition of `unify*`
;;; Similar to `unify`, but it takes a tuple containing pairs of terms to unify,
;;; and a rewrite term.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,'unify*',[[->,'Atom',A,A]])
</span><span class="ansi38-255165000">(: unify* 
  (-> Atom $A $A))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,['unify*',Pairs,Rewrite],[case,Pairs,[[[],Rewrite],[Pairs,['let*',[[Head,['car-atom',Pairs]],[Tail,['cdr-atom',Pairs]]],[case,Head,[[[Lterm,Rterm],[unify,Lterm,Rterm,['unify*',Tail,Rewrite]]]]]]]]])
</span><span class="ansi38-255165000">(= 
  (unify* $Pairs $Rewrite) 
  (case $Pairs 
    ( (() $Rewrite) 
      ($Pairs 
        (let* 
          ( ($Head 
              (car-atom $Pairs)) 
            ($Tail 
              (cdr-atom $Pairs))) 
          (case $Head 
            ( ( ($Lterm $Rterm) 
                (unify $Lterm $Rterm 
                  (unify* $Tail $Rewrite))))))))))
</span>

; Evaluation took 41.54 milliseconds.
<span class="ansi33">Deterministic: </span><span class="ansi33">Empty
</span>
;;; Base case
;;; Recursive step
;; By using a case we guaranty
;; that ill-formed inputs (non
;; tuple of pairs) will be
;; discarded
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,synthesize,[[->,'Atom',[->,'Atom'],[->,'Atom'],'Nat','Atom']])
</span><span class="ansi38-255165000">(: synthesize 
  (-> Atom 
    (-> Atom) 
    (-> Atom) Nat Atom))
</span>

;;; Nullary rule (axiom)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[synthesize,Query,Axiom,Rule,Depth],[unify,Query,[Axiom],Query])
</span><span class="ansi38-255165000">(= 
  (synthesize $Query $Axiom $Rule $Depth) 
  (unify $Query 
    ($Axiom) $Query))
</span>

;;; Binary rule
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[synthesize,Query,Axiom,Rule,['S',K]],['unify*',[[[:,Ructor,[->,Premise1,Premise2,Conclusion]],[Rule]],[[:,[Ructor,Proof1,Proof2],Conclusion],Query],[[:,Proof1,Premise1],[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]],[[:,Proof2,Premise2],[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]]],Query])
</span><span class="ansi38-255165000">(= 
  (synthesize $Query $Axiom $Rule 
    (S $K)) 
  (unify* 
    ( ( (: $Ructor 
          (-> $Premise1 $Premise2 $Conclusion)) 
        ($Rule)) 
      ( (: 
          ($Ructor $Proof1 $Proof2) $Conclusion) $Query) 
      ( (: $Proof1 $Premise1) 
        (synthesize 
          (: $Proof1 $Premise1) $Axiom $Rule $K)) 
      ( (: $Proof2 $Premise2) 
        (synthesize 
          (: $Proof2 $Premise2) $Axiom $Rule $K))) $Query))
</span>

; Evaluation took 396.12 milliseconds.
<span class="ansi33">Last Result(2): </span><span class="ansi33">Empty
</span>
<span class="ansi38-000068000">!(import! &self "../../common/Record.metta")

</span>%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/hyperon-pln/metta/common/Record.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/hyperon-pln/metta/common/Record.metta')
;;; Knowledge base
;;; Given a function call, produce records of that function call.
;;; There can be multiple records with only one call due to the
;;; non-determinism of MeTTa.  Each record is represented by (⊷ f x y)
;;; which can be read as
;;;
;;; "under f, the image of x is y"
;;;
;;; It was chosen because it is described as IMAGE OF in UTF-8.  It is
;;; the MeTTa equivalent of ExecutionLink in Atomese.  The character ⊷
;;; has description: IMAGE OF, hexadecimal code: 0x22B7, unicode-math
;;; code: \imageof and latex code: \multimapdotbothB.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[record,F,[Arg]],['â\x8A\·',F,Arg,[F,Arg]])
</span><span class="ansi38-255165000">(= 
  (record $F 
    ($Arg)) 
  (â· $F $Arg 
    ($F $Arg)))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[record,F,[Arg1,Arg2]],['â\x8A\·',F,[Arg1,Arg2],[F,Arg1,Arg2]])
</span><span class="ansi38-255165000">(= 
  (record $F 
    ($Arg1 $Arg2)) 
  (â· $F 
    ($Arg1 $Arg2) 
    ($F $Arg1 $Arg2)))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[record,F,[Arg1,Arg2,Arg3]],['â\x8A\·',F,[Arg1,Arg2,Arg3],[F,Arg1,Arg2,Arg3]])
</span><span class="ansi38-255165000">(= 
  (record $F 
    ($Arg1 $Arg2 $Arg3)) 
  (â· $F 
    ($Arg1 $Arg2 $Arg3) 
    ($F $Arg1 $Arg2 $Arg3)))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[record,F,[Arg1,Arg2,Arg3,Arg4]],['â\x8A\·',F,[Arg1,Arg2,Arg3,Arg4],[F,Arg1,Arg2,Arg3,Arg4]])
</span><span class="ansi38-255165000">(= 
  (record $F 
    ($Arg1 $Arg2 $Arg3 $Arg4)) 
  (â· $F 
    ($Arg1 $Arg2 $Arg3 $Arg4) 
    ($F $Arg1 $Arg2 $Arg3 $Arg4)))
</span>

; Evaluation took 18.94 milliseconds.
<span class="ansi33">Deterministic: </span><span class="ansi33">Empty
</span>
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,kb,[[->,'Atom']])
</span><span class="ansi38-255165000">(: kb 
  (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[kb],[superpose,[[:,f,[->,'Number','String']],[:,g,[->,'String','Bool']],[:,h,[->,'Bool','Number']],[:,i,[->,'String','Number','Bool']]]])
</span><span class="ansi38-255165000">(= 
  (kb) 
  (superpose 
    ( (: f 
        (-> Number String)) 
      (: g 
        (-> String Bool)) 
      (: h 
        (-> Bool Number)) 
      (: i 
        (-> String Number Bool)))))
</span>

;;; Rule base
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',:,rb,[[->,'Atom']])
</span><span class="ansi38-255165000">(: rb 
  (-> Atom))
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',=,[rb],[superpose,[[:,->,[->,B,C],[->,A,B],[->,A,C]],[:,.:,[->,[->,C,D],[->,A,B,C],[->,A,B,D]]]]])
</span><span class="ansi38-255165000">(= 
  (rb) 
  (superpose 
    ( (: -> 
        (-> $B $C) 
        (-> $A $B) 
        (-> $A $C)) 
      (: .: 
        (-> 
          (-> $C $D) 
          (-> $A $B $C) 
          (-> $A $B $D))))))
</span>

;; Function composition
;; Blackbird
;;; Test program synthesizer
<span class="ansi38-000068000">!(record synthesize 
  ( (: $Term $Type) kb rb Z))

</span>; Evaluation took 0.710 ms. (710.10 microseconds) 
<span class="ansi33">NDet Result(1): </span><span class="ansi33">(â· synthesize 
  ( (: $_15812 $_16114) kb rb Z) 
  (: f 
    (-> Number String)))
</span>
More Solutions? <span class="ansi35"> l

</span>; Evaluation took 1.66 milliseconds.
<span class="ansi33">NDet Result(2): </span><span class="ansi33">(â· synthesize 
  ( (: $_15812 $_16114) kb rb Z) 
  (: g 
    (-> String Bool)))
</span>
; Evaluation took 2.33 milliseconds.
<span class="ansi33">NDet Result(3): </span><span class="ansi33">(â· synthesize 
  ( (: $_15812 $_16114) kb rb Z) 
  (: h 
    (-> Bool Number)))
</span>
; Evaluation took 3.02 milliseconds.
<span class="ansi33">NDet Result(4): </span><span class="ansi33">(â· synthesize 
  ( (: $_15812 $_16114) kb rb Z) 
  (: i 
    (-> String Number Bool)))
</span>
;; (: f (-> Number String)), (: g (-> String Bool)), (: h (-> Bool Number)), (: i (-> String Number Bool))
<span class="ansi38-000068000">!(record synthesize 
  ( (: $Term 
      (-> Number String)) kb rb Z))

</span>; Evaluation took 0.633 ms. (633.40 microseconds) 
<span class="ansi33">NDet Result(1): </span><span class="ansi33">(â· synthesize 
  ( (: $_62020 
      (-> Number String)) kb rb Z) 
  (: f 
    (-> Number String)))
</span>
More Solutions? <span class="ansi35"> l

</span>;; (: f (-> Number String))
<span class="ansi38-000068000">!(record synthesize 
  ( (: $Term 
      (-> String Number Number)) kb rb 
    (S Z)))

</span>; Evaluation took 181.03 milliseconds.
<span class="ansi33">NDet Result(1): </span><span class="ansi33">(â· synthesize 
  ( (: $_1588 
      (-> String Number Number)) kb rb 
    (S Z)) 
  (synthesize 
    (: $_1588 
      (-> String Number Number)) kb rb 
    (S Z)))
</span>
More Solutions? <span class="ansi35"> l

</span>;; (: f (-> Number String))
<span class="ansi38-000068000">!(record synthesize 
  ( (: $Term 
      (-> Number Bool)) kb rb 
    (S Z)))

</span>; Evaluation took 201.31 milliseconds.
<span class="ansi33">NDet Result(1): </span><span class="ansi33">(â· synthesize 
  ( (: $_1582 
      (-> Number Bool)) kb rb 
    (S Z)) 
  (synthesize 
    (: $_1582 
      (-> Number Bool)) kb rb 
    (S Z)))
</span>
More Solutions? <span class="ansi35"> l

</span>;; (: (. g f) (-> Number Bool))
<span class="ansi38-000068000">!(record synthesize 
  ( (: 
      (. g f) 
      (-> Number Bool)) kb rb 
    (S Z)))

</span>; Evaluation took 190.07 milliseconds.
<span class="ansi33">NDet Result(1): </span><span class="ansi33">(â· synthesize 
  ( (: 
      (. g f) 
      (-> Number Bool)) kb rb 
    (S Z)) 
  (synthesize 
    (: 
      (. g f) 
      (-> Number Bool)) kb rb 
    (S Z)))
</span>
More Solutions? <span class="ansi35"> l

</span>;; (: (. g f) (-> Number Bool))
<span class="ansi38-000068000">!(record synthesize 
  ( (: 
      (. g f) $Type) kb rb 
    (S Z)))

</span>; Evaluation took 182.03 milliseconds.
<span class="ansi33">NDet Result(1): </span><span class="ansi33">(â· synthesize 
  ( (: 
      (. g f) $_1606) kb rb 
    (S Z)) 
  (synthesize 
    (: 
      (. g f) $_1606) kb rb 
    (S Z)))
</span>
More Solutions? <span class="ansi35"> l

</span>;; (: (. g f) (-> Number Bool))
<span class="ansi38-000068000">!(record synthesize 
  ( (: $Term $Type) kb rb 
    (S Z)))

</span>; Evaluation took 1.43 milliseconds.
<span class="ansi33">NDet Result(1): </span><span class="ansi33">(â· synthesize 
  ( (: $_264958 $_265260) kb rb 
    (S Z)) 
  (: f 
    (-> Number String)))
</span>
More Solutions? <span class="ansi35"> l

</span>; Evaluation took 2.86 milliseconds.
<span class="ansi33">NDet Result(2): </span><span class="ansi33">(â· synthesize 
  ( (: $_264958 $_265260) kb rb 
    (S Z)) 
  (: g 
    (-> String Bool)))
</span>
; Evaluation took 4.03 milliseconds.
<span class="ansi33">NDet Result(3): </span><span class="ansi33">(â· synthesize 
  ( (: $_264958 $_265260) kb rb 
    (S Z)) 
  (: h 
    (-> Bool Number)))
</span>
; Evaluation took 5.22 milliseconds.
<span class="ansi33">NDet Result(4): </span><span class="ansi33">(â· synthesize 
  ( (: $_264958 $_265260) kb rb 
    (S Z)) 
  (: i 
    (-> String Number Bool)))
</span>
;; (: f (-> Number String)), ..., (: (. f h) (-> Bool String)), ...
<span class="ansi38-000068000">!(record synthesize 
  ( (: 
      (. 
        (. g f) h) 
      (-> $In Bool)) kb rb 
    (fromNumber 2)))

</span>; Evaluation took 564.86 milliseconds.
<span class="ansi33">NDet Result(1): </span><span class="ansi33">(â· synthesize 
  ( (: 
      (. 
        (. g f) h) 
      (-> $_1672 Bool)) kb rb 
    (S 
      (fromNumber 
        (- 2 1)))) 
  (synthesize 
    (: 
      (. 
        (. g f) h) 
      (-> $_1672 Bool)) kb rb 
    (S 
      (fromNumber 
        (- 2 1)))))
</span>
More Solutions? <span class="ansi35"> l

</span>;; (: (. (. g f) h) (-> Bool Bool)) (fromNumber 3))
<span class="ansi38-000068000">!(record synthesize 
  ( (: 
      (. $G h) $Type) kb rb 
    (fromNumber 3)))

</span>; Evaluation took 772.54 milliseconds.
<span class="ansi33">NDet Result(1): </span><span class="ansi33">(â· synthesize 
  ( (: 
      (. $_1598 h) $_1622) kb rb 
    (S 
      (fromNumber 
        (- 3 1)))) 
  (synthesize 
    (: 
      (. $_1598 h) $_1622) kb rb 
    (S 
      (fromNumber 
        (- 3 1)))))
</span>
More Solutions? <span class="ansi35"> l

</span>;; (: (. f h) (-> Bool String))
<span class="ansi38-000068000">!(record synthesize 
  ( (: 
      (. $G h) 
      (-> Number $Out)) kb rb 
    (fromNumber 3)))

</span>; Evaluation took 803.38 milliseconds.
<span class="ansi33">NDet Result(1): </span><span class="ansi33">(â· synthesize 
  ( (: 
      (. $_1616 h) 
      (-> Number $_1658)) kb rb 
    (S 
      (fromNumber 
        (- 3 1)))) 
  (synthesize 
    (: 
      (. $_1616 h) 
      (-> Number $_1658)) kb rb 
    (S 
      (fromNumber 
        (- 3 1)))))
</span>
More Solutions? <span class="ansi35"> l

</span>;; No answer
<span class="ansi38-000068000">!(record synthesize 
  ( (: 
      (. g $F) 
      (-> $In String)) kb rb 
    (fromNumber 3)))

</span>; Evaluation took 813.68 milliseconds.
<span class="ansi33">NDet Result(1): </span><span class="ansi33">(â· synthesize 
  ( (: 
      (. g $_1622) 
      (-> $_1652 String)) kb rb 
    (S 
      (fromNumber 
        (- 3 1)))) 
  (synthesize 
    (: 
      (. g $_1622) 
      (-> $_1652 String)) kb rb 
    (S 
      (fromNumber 
        (- 3 1)))))
</span>
More Solutions? <span class="ansi35"> l

</span>;; No answer
<span class="ansi38-000068000">!(record synthesize 
  ( (: 
      (. g $F) 
      (-> $In Bool)) kb rb 
    (fromNumber 3)))

</span>; Evaluation took 745.08 milliseconds.
<span class="ansi33">NDet Result(1): </span><span class="ansi33">(â· synthesize 
  ( (: 
      (. g $_1622) 
      (-> $_1652 Bool)) kb rb 
    (S 
      (fromNumber 
        (- 3 1)))) 
  (synthesize 
    (: 
      (. g $_1622) 
      (-> $_1652 Bool)) kb rb 
    (S 
      (fromNumber 
        (- 3 1)))))
</span>
More Solutions? <span class="ansi35"> l

</span>;; (: (. g f) (-> Number Bool)), (: (. g (. f h)) (-> Bool Bool)), (: (. g (. f (. h g))) (-> String Bool))
<span class="ansi38-000068000">!(record synthesize 
  ( (: $Term $Type) kb rb 
    (fromNumber 4)))

</span>; Evaluation took 16.66 milliseconds.
<span class="ansi33">NDet Result(1): </span><span class="ansi33">(â· synthesize 
  ( (: $_147488 $_147790) kb rb 
    (S 
      (fromNumber 
        (- 4 1)))) 
  (: f 
    (-> Number String)))
</span>
More Solutions? <span class="ansi35"> l

</span>; Evaluation took 22.53 milliseconds.
<span class="ansi33">NDet Result(2): </span><span class="ansi33">(â· synthesize 
  ( (: $_147488 $_147790) kb rb 
    (S 
      (fromNumber 
        (- 4 1)))) 
  (: g 
    (-> String Bool)))
</span>
; Evaluation took 28.35 milliseconds.
<span class="ansi33">NDet Result(3): </span><span class="ansi33">(â· synthesize 
  ( (: $_147488 $_147790) kb rb 
    (S 
      (fromNumber 
        (- 4 1)))) 
  (: h 
    (-> Bool Number)))
</span>
; Evaluation took 34.46 milliseconds.
<span class="ansi33">NDet Result(4): </span><span class="ansi33">(â· synthesize 
  ( (: $_147488 $_147790) kb rb 
    (S 
      (fromNumber 
        (- 4 1)))) 
  (: i 
    (-> String Number Bool)))
</span>
<span class="ansi32">% 15,527,126 inferences, 5.312 CPU in 5.312 seconds (100% CPU, 2923030 Lips)
</span> (= "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/hyperon-pln/metta/synthesis/experiments/synthesize-via-unify-test.metta" 0)
<br/><a href="https://github.com/logicmoo/vspace-metta/blob/main/MeTTaLog.md">Return to Summaries</a><br/>
doing(ansi2html -u < "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/TEE.ansi" > "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/hyperon-pln/metta/synthesis/experiments/synthesize-via-unify-test.html" )

</pre>
</body>

</html>
