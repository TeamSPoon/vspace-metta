<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>
<style type="text/css">
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi36 { color: #00aaaa; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
.ansi38-000068000 { color: #004400; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content">
 (@ track_load_into_file "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/hyperon-experimental/python/sandbox/resolve/r.metta")
%~ load_answer_file( '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/hyperon-experimental/python/sandbox/resolve/r.metta.answers',
%~   '/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/hyperon-experimental/python/sandbox/resolve/r.metta')
1=[]
2=[]
3=[<r.MeTTaC object at 0x7f4c8c02c590>]
4=[resolve]
5=[120]
6=[content]
7=[]
8=[some]
9=[r::content]
10=[(content)]
11=[]
12=[720]
13=[720]
14=0.40user 0.00system 0:00.41elapsed 99%CPU (0avgtext+0avgdata 34548maxresident)k
14=0inputs+16outputs (0major+3809minor)pagefaults 0swaps
<span class="ansi38-000068000">!(extend-py! resolve)

</span><span class="ansi33">  (extend-py! resolve)

</span><span class="ansi38-000068000">!(extend-py! r)

</span><span class="ansi33">  (extend-py! r)

</span><span class="ansi38-000068000">!r

</span><span class="ansi33"> r

</span><span class="ansi31">
! (assertEqualToResult r 
    (<r.MeTTaC object at 0 x7f4c8c02c590>))
(@ ! 
  (assertEqual 
    (r) 
    (<r.MeTTaC object at 0 x7f4c8c02c590>)))
write_pass_fail_result("RESOLVE.R.103",exec,r,'FAIL',['<r.MeTTaC',object,at,0,'x7f4c8c02c590>'],[r])

</span>

--------------------------------------------------------------------------
; hyperon.runner.MeTTa object (`r` is registered 'manually' now)
<span class="ansi38-000068000">!resolve

</span><span class="ansi33"> resolve

</span><span class="ansi36">
! (assertEqualToResult resolve 
    (resolve))
(@ ! 
  (assertEqual 
    (resolve) 
    (resolve)))
write_pass_fail_result("RESOLVE.R.104",exec,resolve,'PASS',[resolve],[resolve])

</span>

--------------------------------------------------------------------------
; just a symbol, because `resolve` extension doesn't 'register itself', but it could be possible to automate this
<span class="ansi38-000068000">!(r::fact 5)

</span><span class="ansi33">  (r::fact 5)

</span><span class="ansi31">
! (assertEqualToResult 
    (r::fact 5) 
    (120))
(@ ! 
  (assertEqual 
    ( (r::fact 5)) 
    (120)))
write_pass_fail_result("RESOLVE.R.105",exec,['r::fact',5],'FAIL',[120],[['r::fact',5]])

</span>

--------------------------------------------------------------------------
; 120
<span class="ansi38-000068000">!(r::self-from-self)

</span><span class="ansi33">  (r::self-from-self)

</span><span class="ansi31">
! (assertEqualToResult 
    (r::self-from-self) 
    (content))
(@ ! 
  (assertEqual 
    ( (r::self-from-self)) 
    (content)))
write_pass_fail_result("RESOLVE.R.106",exec,['r::self-from-self'],'FAIL',[content],[['r::self-from-self']])

</span>

--------------------------------------------------------------------------
; content
<span class="ansi38-000068000">!(match &self 
  ($X content) $X)

</span><span class="ansi36">
! (assertEqualToResult 
    (match &self 
      ($X content) $X) ())
(@ ! 
  (assertEqual () ()))
write_pass_fail_result("RESOLVE.R.107",exec,[match,'&self',[X,content],X],'PASS',[],[])

</span>

--------------------------------------------------------------------------
; []
; this returns `some` meaning that `content` from this scripts
; is not distinguished from `content` symbol in `r`
<span class="ansi38-000068000">!(match r::&self 
  ($X content) $X)

</span><span class="ansi31">
! (assertEqualToResult 
    (match r::&self 
      ($X content) $X) 
    (some))
(@ ! 
  (assertEqual () 
    (some)))
write_pass_fail_result("RESOLVE.R.108",exec,[match,'r::&self',[X,content],X],'FAIL',[some],[])

</span>

--------------------------------------------------------------------------
<span class="ansi38-000068000">!r::content

</span><span class="ansi33"> r::content

</span><span class="ansi36">
! (assertEqualToResult r::content 
    (r::content))
(@ ! 
  (assertEqual 
    (r::content) 
    (r::content)))
write_pass_fail_result("RESOLVE.R.109",exec,'r::content','PASS',['r::content'],['r::content'])

</span>

--------------------------------------------------------------------------
; it is turned in OperationAtom, but it is not executed
<span class="ansi38-000068000">!(r::content)

</span><span class="ansi33">  (r::content)

</span><span class="ansi31">
! (assertEqualToResult 
    (r::content) 
    ( (content)))
(@ ! 
  (assertEqual 
    ( (r::content)) 
    ( (content))))
write_pass_fail_result("RESOLVE.R.110",exec,['r::content'],'FAIL',[[content]],[['r::content']])

</span>

--------------------------------------------------------------------------
; its execution results in unreduced `(content)`
; the following doesn't work (it might be ok, but semantics of :: is weird overall)
<span class="ansi38-000068000">!(match r::&self 
  ($X r::content) $X)

</span><span class="ansi36">
! (assertEqualToResult 
    (match r::&self 
      ($X r::content) $X) ())
(@ ! 
  (assertEqual () ()))
write_pass_fail_result("RESOLVE.R.111",exec,[match,'r::&self',[X,'r::content'],X],'PASS',[],[])

</span>

--------------------------------------------------------------------------
; both work, so :: doesn't separate "namespaces" precisely
<span class="ansi38-000068000">!(r::call_func fact 6)

</span><span class="ansi33">  (r::call_func fact 6)

</span><span class="ansi31">
! (assertEqualToResult 
    (r::call_func fact 6) 
    (720))
(@ ! 
  (assertEqual 
    ( (r::call_func fact 6)) 
    (720)))
write_pass_fail_result("RESOLVE.R.112",exec,['r::call_func',fact,6],'FAIL',[720],[['r::call_func',fact,6]])

</span>

--------------------------------------------------------------------------
<span class="ansi38-000068000">!(r::call_func r::fact 6)

</span><span class="ansi33">  (r::call_func r::fact 6)

</span><span class="ansi31">
! (assertEqualToResult 
    (r::call_func r::fact 6) 
    (720))
(@ ! 
  (assertEqual 
    ( (r::call_func r::fact 6)) 
    (720)))
write_pass_fail_result("RESOLVE.R.113",exec,['r::call_func','r::fact',6],'FAIL',[720],[['r::call_func','r::fact',6]])

</span>

--------------------------------------------------------------------------
<span class="ansi32">% 129,010 inferences, 0.061 CPU in 0.061 seconds (100% CPU, 2100080 Lips)
</span> (@ = "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/hyperon-experimental/python/sandbox/resolve/r.metta" 0)
<span class="ansi1">LoonIt Report
</span>------------
<span class="ansi32">Successes: 4
</span><span class="ansi31">Failures: 7
</span>doing(ansi2html -u < "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/TEE.ansi" > "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/hyperon-experimental/python/sandbox/resolve/r.html" )

</pre>
</body>

</html>
