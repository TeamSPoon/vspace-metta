<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>
<style type="text/css">
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content">
 (@ track_load_into_file "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/sumo/orientation/orientation-test.metta")
;; Test reasoning on the content of orientation.kif.metta.  Before
;; running that file, make sure `orientation.kif.metta` has been
;; properly generated.  See `README.md` for more information on how to
;; do that.
;; Import synthesizer
<span class="ansi38-000068000">!(import! &self "../../synthesis/Synthesize.metta")

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&self', '../../synthesis/Synthesize.metta'], A).

</span>;; Import knowledge base
;; Import modules
<span class="ansi38-000068000">!(import! &self "../common/Num.metta")

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&self', '../common/Num.metta'], A).

</span>;; !(import! &self Unify.metta)
;; Enumerate all programs up to a given depth that are consistent with
;; the query, using the given axiom non-deterministic functions and rules.
;;
;; The arguments are:
;;
;; $query: an Atom under the form (: TERM TYPE).  The atom may contain
;;         free variables within TERM and TYPE to form various sort of
;;         queries, such as:
;;         1. Backward chaining: (: $term (Inheritance $x Mammal))
;;         2. Forward chaining: (: ($rule $premise AXIOM) $type)
;;         3. Mixed chaining: (: ($rule $premise AXIOM) (Inheritance $x Mammal))
;;         4. Type checking: (: TERM TYPE)
;;         5. Type inference: (: TERM $type)
;;
;; $axiom: a nullary function to axiom, to non-deterministically pick
;;         up an axiom.  An axiom is an Atom of the form
;;         (: TERM TYPE).
;;
;; $rule: a nullary function to rule, to non-deterministically pick up
;;        a rule.  A rule is a function mapping premises to
;;        conclusion, where premises and conclusion have the form
;;        (: TERM TYPE).
;;
;; $depth: a Nat representing the maximum depth of the generated
;;         programs.
;;
;; TODO: recurse over curried rules instead of duplicating code over
;; tuples.
;; Collection of functions operating on numbers
;; Define max
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,max,[->,A,A,A]])
</span><span class="ansi38-255165000">  (: max 
    (-> $A $A $A))
</span>

%~ /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/metta_vspace/pyswip/metta_interp.pl:1054 
%~ [ convert(Convert),
%~   head_preconds_into_body( max(X,Y,Assign_Max_Y) :-
%~                              u_assign([>,X,Y],Assign) ,
%~                              Assign=_420776 ,
%~                              u_assign([if,_420776,X,Y],Assign_Max_Y))]
%~ [convert(_357326),head_preconds_into_body((max(X,Y,_356090):-(u_assign([>,X,Y],_357632),_357632=_357622),u_assign([if,_357622,X,Y],_356090)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[max,X,Y],[if,[>,X,Y],X,Y])
</span><span class="ansi38-255165000">  (= 
    (max $X $Y) 
    (if 
      (> $X $Y) $X $Y))
</span><span class="ansi38-000082136">  :- dynamic(max,3).

  max(X, Y, A) :-
    u_assign([>, X, Y], B),
    B=C,
    u_assign([if, C, X, Y], A).

</span>

;; Define min
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,min,[->,A,A,A]])
</span><span class="ansi38-255165000">  (: min 
    (-> $A $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( min(X,Y,Assign_Min_Y) :-
%~                              u_assign([<,X,Y],Assign) ,
%~                              Assign=_29324 ,
%~                              u_assign([if,_29324,X,Y],Assign_Min_Y))]
%~ [convert(_3246),head_preconds_into_body((min(X,Y,_3204):-(u_assign([<,X,Y],_3284),_3284=_3280),u_assign([if,_3280,X,Y],_3204)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[min,X,Y],[if,[<,X,Y],X,Y])
</span><span class="ansi38-255165000">  (= 
    (min $X $Y) 
    (if 
      (< $X $Y) $X $Y))
</span><span class="ansi38-000082136">  :- dynamic(min,3).

  min(X, Y, A) :-
    u_assign([<, X, Y], B),
    B=C,
    u_assign([if, C, X, Y], A).

</span>

;; Clamp a number to be within a certain range
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,clamp,[->,A,A,A,A]])
</span><span class="ansi38-255165000">  (: clamp 
    (-> $A $A $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( clamp(X,L,U,Assign_Clamp_U) :-
%~                              u_assign([min,U,X],Assign) ,
%~                              Assign=_152342 ,
%~                              u_assign([max,L,_152342],Assign_Clamp_U))]
%~ [convert(_92614),head_preconds_into_body((clamp(X,L,U,_91308):-(u_assign([min,U,X],_92976),_92976=_92966),u_assign([max,L,_92966],_91308)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[clamp,X,L,U],[max,L,[min,U,X]])
</span><span class="ansi38-255165000">  (= 
    (clamp $X $L $U) 
    (max $L 
      (min $U $X)))
</span><span class="ansi38-000082136">  :- dynamic(clamp,4).

  clamp(X, L, U, A) :-
    u_assign([min, U, X], B),
    B=C,
    u_assign([max, L, C], A).

</span>

;; Define abs
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,abs,[->,A,A]])
</span><span class="ansi38-255165000">  (: abs 
    (-> $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( abs(X,Assign_Abs_X) :-
%~                              u_assign([<,X,0],Assign) ,
%~                              Assign=_297748 ,
%~                              u_assign([*,-1,X],Assign3) ,
%~                              Assign3=_297766 ,
%~                              u_assign([if,_297748,_297766,X],Assign_Abs_X))]
%~ [convert(_212086),head_preconds_into_body((abs(X,_210920):-((u_assign([<,X,0],_212392),_212392=_212382),u_assign([*,-1,X],_212552),_212552=_212542),u_assign([if,_212382,_212542,X],_210920)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[abs,X],[if,[<,X,0],[*,-1,X],X])
</span><span class="ansi38-255165000">  (= 
    (abs $X) 
    (if 
      (< $X 0) 
      (* -1 $X) $X))
</span><span class="ansi38-000082136">
  abs(X, A) :-
    ( u_assign([<, X, 0], B),
      B=C
    ),
    u_assign([*, -1, X], D),
    D=E,
    u_assign([if, C, E, X], A).

</span>

;; Define <=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,<=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: <= 
    (-> $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( <=(X,Y,Assign_Y) :-
%~                              u_assign([<,X,Y],Assign) ,
%~                              Assign=_477864 ,
%~                              u_assign([==,X,Y],Assign2) ,
%~                              Assign2=_477882 ,
%~                              u_assign([or,_477864,_477882],Assign_Y))]
%~ [convert(_402828),head_preconds_into_body((<=(X,Y,_401592):-((u_assign([<,X,Y],_403134),_403134=_403124),u_assign([==,X,Y],_403338),_403338=_403328),u_assign([or,_403124,_403328],_401592)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[<=,X,Y],[or,[<,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">  (= 
    (<= $X $Y) 
    (or 
      (< $X $Y) 
      (== $X $Y)))
</span><span class="ansi38-000082136">  :- dynamic(<=,3).

  <=(X, Y, A) :-
    ( u_assign([<, X, Y], B),
      B=C
    ),
    u_assign([==, X, Y], D),
    D=E,
    u_assign([or, C, E], A).

</span>

;; Define >=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,>=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: >= 
    (-> $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( >=(X,Y,Assign_Y) :-
%~                              u_assign([>,X,Y],Assign) ,
%~                              Assign=_102656 ,
%~                              u_assign([==,X,Y],Assign2) ,
%~                              Assign2=_102674 ,
%~                              u_assign([or,_102656,_102674],Assign_Y))]
%~ [convert(_27620),head_preconds_into_body((>=(X,Y,_26384):-((u_assign([>,X,Y],_27926),_27926=_27916),u_assign([==,X,Y],_28130),_28130=_28120),u_assign([or,_27916,_28120],_26384)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[>=,X,Y],[or,[>,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">  (= 
    (>= $X $Y) 
    (or 
      (> $X $Y) 
      (== $X $Y)))
</span><span class="ansi38-000082136">  :- dynamic(>=,3).

  >=(X, Y, A) :-
    ( u_assign([>, X, Y], B),
      B=C
    ),
    u_assign([==, X, Y], D),
    D=E,
    u_assign([or, C, E], A).

</span>

;; Define approximately equal
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,approxEq,[->,A,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: approxEq 
    (-> $A $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( approxEq(X,Y,Epsilon,Assign_ApproxEq_Epsilon) :-
%~                              u_assign([-,X,Y],Assign) ,
%~                              Assign=_249020 ,
%~                              u_assign([abs,_249020],Assign3) ,
%~                              Assign3=_249044 ,
%~                              u_assign([<=,_249044,Epsilon],Assign_ApproxEq_Epsilon))]
%~ [convert(_162780),head_preconds_into_body((approxEq(X,Y,Epsilon,_161474):-(((u_assign([-,X,Y],_163128),_163128=_163118),u_assign([abs,_163118],_163086)),_163086=_163076),u_assign([<=,_163076,Epsilon],_161474)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[approxEq,X,Y,Epsilon],[<=,[abs,[-,X,Y]],Epsilon])
</span><span class="ansi38-255165000">  (= 
    (approxEq $X $Y $Epsilon) 
    (<= 
      (abs 
        (- $X $Y)) $Epsilon))
</span><span class="ansi38-000082136">  :- dynamic(approxEq,4).

  approxEq(X, Y, Epsilon, A) :-
    ( u_assign([-, X, Y], B),
      B=C,
      u_assign([abs, C], D)
    ),
    D=E,
    u_assign([<=, E, Epsilon], A).

</span>

;; Define Nat
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Nat','Type'])
</span><span class="ansi38-255165000">  (: Nat Type)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Z','Nat'])
</span><span class="ansi38-255165000">  (: Z Nat)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'S',[->,'Nat','Nat']])
</span><span class="ansi38-255165000">  (: S 
    (-> Nat Nat))
</span>

;; Define cast functions between Nat and Number
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNumber,[->,'Number','Nat']])
</span><span class="ansi38-255165000">  (: fromNumber 
    (-> Number Nat))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( fromNumber(N,N) :-
%~                              u_assign([<=,N,0],Assign) ,
%~                              Assign=_472834 ,
%~                              u_assign([-,N,1],Assign2) ,
%~                              Assign2=_472876 ,
%~                              u_assign([fromNumber,_472876],Assign3) ,
%~                              Assign3=_472900 ,
%~                              u_assign(['S',_472900],Assign4) ,
%~                              Assign4=_472924 ,
%~                              u_assign([if,_472834,'Z',_472924],N))]
%~ [convert(_350678),head_preconds_into_body((fromNumber(N,_349512):-((u_assign([<=,N,0],_350984),_350984=_350974),((((u_assign([-,N,1],_351240),_351240=_351230),u_assign([fromNumber,_351230],_351198)),_351198=_351188),u_assign(['S',_351188],_351156)),_351156=_351146),u_assign([if,_350974,'Z',_351146],_349512)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNumber,N],[if,[<=,N,0],'Z',['S',[fromNumber,[-,N,1]]]])
</span><span class="ansi38-255165000">  (= 
    (fromNumber $N) 
    (if 
      (<= $N 0) Z 
      (S 
        (fromNumber 
          (- $N 1)))))
</span><span class="ansi38-000082136">  :- dynamic(fromNumber,2).

  fromNumber(N, A) :-
    ( u_assign([<=, N, 0], B),
      B=C
    ),
    ( ( u_assign([-, N, 1], D),
        D=E,
        u_assign([fromNumber, E], F)
      ),
      F=G,
      u_assign(['S', G], H)
    ),
    H=I,
    u_assign([if, C, 'Z', I], A).

</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNat,[->,'Nat','Number']])
</span><span class="ansi38-255165000">  (: fromNat 
    (-> Nat Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((fromNat('Z',0):-true))]
%~ [convert(_3484),head_preconds_into_body((fromNat('Z',0):-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,'Z'],0)
</span><span class="ansi38-255165000">  (= 
    (fromNat Z) 0)
</span><span class="ansi38-000082136">  :- dynamic(fromNat,2).

  fromNat('Z', 0).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( fromNat(FromNat,FromNat1) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=FromNat ,
%~                              u_assign([fromNat,K],Assign3) ,
%~                              [+,1,Assign3,FromNat1])]
%~ [convert(_47304),head_preconds_into_body((fromNat(_46350,_46070):-(u_assign(['S',K],_46360),_46360=_46350),u_assign([fromNat,K],_47628),[+,1,_47628,_46070]))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,['S',K]],[+,1,[fromNat,K]])
</span><span class="ansi38-255165000">  (= 
    (fromNat 
      (S $K)) 
    (+ 1 
      (fromNat $K)))
</span><span class="ansi38-000082136">  :- dynamic(fromNat,2).

  fromNat(A, B) :-
    u_assign(['S', K], C),
    C=A,
    u_assign([fromNat, K], D),
    [+, 1, D, B].

</span>

;; Define a generic less than operator, â©», for Nat.  < cannot be used
;; because it is a built-in, its type is hardwired and cannot be
;; overloaded.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Nat','Nat','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Nat Nat Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('â©»'(_,'Z',_146044):-_146044='False'))]
%~ [convert(_147236),head_preconds_into_body(('â©»'(_,'Z',_146044):-_146044='False'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',_,'Z'],'False')
</span><span class="ansi38-255165000">  (= 
    (â©» $_ Z) False)
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(_, 'Z', A) :-
    A='False'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'('Z',Z,True) :-
%~                              u_assign(['S',_],Assign) ,
%~                              Assign=Z ,
%~                              True='True')]
%~ [convert(_193614),head_preconds_into_body(('â©»'('Z',_192646,_192354):-(u_assign(['S',_],_192656),_192656=_192646),_192354='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»','Z',['S',_]],'True')
</span><span class="ansi38-255165000">  (= 
    (â©» Z 
      (S $_)) True)
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'('Z', A, B) :-
    u_assign(['S', _], C),
    C=A,
    B='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'(Â1,Â,Assign_Â2) :-
%~                              u_assign(['S',X],Assign) ,
%~                              Assign=Â1 ,
%~                              u_assign(['S',Y],Assign4) ,
%~                              Assign4=Â ,
%~                              u_assign(['â©»',X,Y],Assign_Â2))]
%~ [convert(_264656),head_preconds_into_body(('â©»'(_263540,_263674,_263260):-((u_assign(['S',X],_263550),_263550=_263540),u_assign(['S',Y],_263684),_263684=_263674),u_assign(['â©»',X,Y],_263260)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',['S',X],['S',Y]],['â©»',X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» 
      (S $X) 
      (S $Y)) 
    (â©» $X $Y))
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(A, B, C) :-
    ( u_assign(['S', X], D),
      D=A
    ),
    u_assign(['S', Y], E),
    E=B,
    u_assign(['â©»', X, Y], C).

</span>

;; Overload â©» for Number.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Number','Number','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Number Number Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'(X,Y,Assign_Â_Y) :-
%~                              u_assign([<,X,Y],Assign_Â_Y))]
%~ [convert(_362358),head_preconds_into_body(('â©»'(X,Y,_361122):-u_assign([<,X,Y],_361122)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',X,Y],[<,X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» $X $Y) 
    (< $X $Y))
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(X, Y, A) :-
    u_assign([<, X, Y], A).

</span>

;; Return the ceiling of a non negative number.  If the number is
;; negative it returns 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,ceil,[->,'Number','Number']])
</span><span class="ansi38-255165000">  (: ceil 
    (-> Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ceil(N,Assign_Ceil_N) :-
%~                              u_assign([fromNumber,N],Assign) ,
%~                              Assign=_493816 ,
%~                              u_assign([fromNat,_493816],Assign_Ceil_N))]
%~ [convert(_438114),head_preconds_into_body((ceil(N,_436948):-(u_assign([fromNumber,N],_438420),_438420=_438410),u_assign([fromNat,_438410],_436948)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[ceil,N],[fromNat,[fromNumber,N]])
</span><span class="ansi38-255165000">  (= 
    (ceil $N) 
    (fromNat 
      (fromNumber $N)))
</span><span class="ansi38-000082136">  :- dynamic(ceil,2).

  ceil(N, A) :-
    u_assign([fromNumber, N], B),
    B=C,
    u_assign([fromNat, C], A).

</span>

;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'number->bool',[->,'Number','Bool']])
</span><span class="ansi38-255165000">  (: number->bool 
    (-> Number Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'number->bool'(X,Number_c62_bool_X) :-
%~                              u_assign([<,0,X],Number_c62_bool_X))]
%~ [convert(_18332),head_preconds_into_body(('number->bool'(X,_17166):-u_assign([<,0,X],_17166)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['number->bool',X],[<,0,X])
</span><span class="ansi38-255165000">  (= 
    (number->bool $X) 
    (< 0 $X))
</span><span class="ansi38-000082136">  :- dynamic('number->bool',2).

  'number->bool'(X, A) :-
    u_assign([<, 0, X], A).

</span>

;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'bool->number',[->,'Bool','Number']])
</span><span class="ansi38-255165000">  (: bool->number 
    (-> Bool Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('bool->number'('False',0):-true))]
%~ [convert(_88820),head_preconds_into_body(('bool->number'('False',0):-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','False'],0)
</span><span class="ansi38-255165000">  (= 
    (bool->number False) 0)
</span><span class="ansi38-000082136">  :- dynamic('bool->number',2).

  'bool->number'('False', 0).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('bool->number'(_125392,1):-is_True(_125392)))]
%~ [convert(_126228),head_preconds_into_body(('bool->number'(_125392,1):-is_True(_125392)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','True'],1)
</span><span class="ansi38-255165000">  (= 
    (bool->number True) 1)
</span><span class="ansi38-000082136">  :- dynamic('bool->number',2).

  'bool->number'(A, 1) :-
    is_True(A).

</span>

;; Define a less than type.  Note that it is purposefully different
;; than â©» as it is a type, not an operator.  Inhabitants of (â x y)
;; are proofs that x â©» y == True.  For now â is only axiomatized for
;; Nat.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â\x8D\\x83\',[->,True,True,'Type']])
</span><span class="ansi38-255165000">  (: â 
    (-> $True $True Type))
</span>

;; Zero is always less than the successor of something
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['zero-lt-succ-axiom'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ['zero-lt-succ-axiom',Assign2] :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=_289846 ,
%~                              u_assign(['â\x8D\\x83\','Z',_289846],Assign1) ,
%~                              Assign1=_289876 ,
%~                              u_assign([:,'ZeroLTSucc',_289876],Assign2))]
%~ [convert(_190860),head_preconds_into_body((['zero-lt-succ-axiom',_189020]:-(((u_assign(['S',K],_191232),_191232=_191222),u_assign(['â\x8D\\x83\','Z',_191222],_191178)),_191178=_191168),u_assign([:,'ZeroLTSucc',_191168],_189020)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['zero-lt-succ-axiom'],[:,'ZeroLTSucc',['â\x8D\\x83\','Z',['S',K]]])
</span><span class="ansi38-255165000">  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (â Z 
        (S $K))))
</span><span class="ansi38-000082136">
  ['zero-lt-succ-axiom', A] :-
    ( u_assign(['S', K], B),
      B=C,
      u_assign(['â\u008D\u0083', 'Z', C], D)
    ),
    D=E,
    u_assign([:, 'ZeroLTSucc', E], A).

</span>

;; If x â y then (S x) â (S y)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['succ-monotonicity-rule'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ['succ-monotonicity-rule',Assign5] :-
%~                              u_assign(['â\x8D\\x83\',X,Y],Assign) ,
%~                              Assign=_490190 ,
%~                              u_assign(['S',X],Assign1) ,
%~                              Assign1=_490226 ,
%~                              u_assign(['S',Y],Assign2) ,
%~                              Assign2=_490244 ,
%~                              u_assign(['â\x8D\\x83\',_490226,_490244],Assign3) ,
%~                              Assign3=_490274 ,
%~                              u_assign([->,_490190,_490274],Assign4) ,
%~                              Assign4=_490304 ,
%~                              u_assign([:,'SuccMonotonicity',_490304],Assign5))]
%~ [convert(_329494),head_preconds_into_body((['succ-monotonicity-rule',_327654]:-((((u_assign(['â\x8D\\x83\',X,Y],_329854),_329854=_329844),(((u_assign(['S',X],_330100),_330100=_330090),u_assign(['S',Y],_330234),_330234=_330224),u_assign(['â\x8D\\x83\',_330090,_330224],_330058)),_330058=_330048),u_assign([->,_329844,_330048],_329812)),_329812=_329802),u_assign([:,'SuccMonotonicity',_329802],_327654)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['succ-monotonicity-rule'],[:,'SuccMonotonicity',[->,['â\x8D\\x83\',X,Y],['â\x8D\\x83\',['S',X],['S',Y]]]])
</span><span class="ansi38-255165000">  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (â $X $Y) 
        (â 
          (S $X) 
          (S $Y)))))
</span><span class="ansi38-000082136">
  ['succ-monotonicity-rule', A] :-
    ( ( u_assign(['â\u008D\u0083', X, Y], B),
        B=C
      ),
      ( ( u_assign(['S', X], D),
          D=E
        ),
        u_assign(['S', Y], F),
        F=G,
        u_assign(['â\u008D\u0083', E, G], H)
      ),
      H=I,
      u_assign([->, C, I], J)
    ),
    J=K,
    u_assign([:, 'SuccMonotonicity', K], A).

</span>

; Evaluation took 1421.91 ms.
<span class="ansi33"> &self

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,synthesize,[->,'Atom',[->,'Atom'],[->,'Atom'],'Nat','Atom']])
</span><span class="ansi38-255165000">  (: synthesize 
    (-> Atom 
      (-> Atom) 
      (-> Atom) Nat Atom))
</span>

;; Nullary rule (axiom)
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Depth,Query) :-
%~                              u_assign([Axiom],VAR_Query) ,
%~                              Query=VAR_Query)]
%~ [convert(_58582),head_preconds_into_body((synthesize(Query,Axiom,Rule,Depth,Query):-u_assign([Axiom],_58886),Query=_58886))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,Depth],[let,Query,[Axiom],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule $Depth) 
    (let $Query 
      ($Axiom) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, Depth, Query) :-
    u_assign([Axiom], A),
    Query=A.

</span>

;; Unary rule
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Rule,Query) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=Rule ,
%~                              u_assign([->,Premise,Conclusion],Assign5) ,
%~                              Assign5=_305370 ,
%~                              u_assign([:,Ructor,_305370],Assign_List) ,
%~                              [Rule]=Assign_List ,
%~                              u_assign([Ructor,Proof],Assign7) ,
%~                              Assign7=_305436 ,
%~                              u_assign([:,_305436,Conclusion],VAR_Query) ,
%~                              Query=VAR_Query ,
%~                              u_assign([:,Proof,Premise],Assign_List3) ,
%~                              [ synthesize,
%~                                [:,Proof,Premise], Axiom,Rule,K] =
%~                                Assign_List3)]
%~ [convert(_158082),head_preconds_into_body((synthesize(Query,Axiom,Rule,_157086,Query):-(u_assign(['S',K],_157096),_157096=_157086),(((u_assign([->,Premise,Conclusion],_159282),_159282=_159272),u_assign([:,Ructor,_159272],_158666)),[Rule]=_158666),(((u_assign([Ructor,Proof],_160338),_160338=_160328),u_assign([:,_160328,Conclusion],_159778)),Query=_159778),u_assign([:,Proof,Premise],_160888),[synthesize,[:,Proof,Premise],Axiom,Rule,K]=_160888))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,['S',K]],['let*',[[[:,Ructor,[->,Premise,Conclusion]],[Rule]],[[:,[Ructor,Proof],Conclusion],Query],[[:,Proof,Premise],[synthesize,[:,Proof,Premise],Axiom,Rule,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise $Conclusion)) 
          ($Rule)) 
        ( (: 
            ($Ructor $Proof) $Conclusion) $Query) 
        ( (: $Proof $Premise) 
          (synthesize 
            (: $Proof $Premise) $Axiom $Rule $K))) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, A, Query) :-
    u_assign(['S', K], B),
    B=A,
    ( u_assign([->, Premise, Conclusion], C),
      C=D,
      u_assign([:, Ructor, D], E)
    ),
    [Rule]=E,
    ( u_assign([Ructor, Proof], F),
      F=G,
      u_assign([:, G, Conclusion], H)
    ),
    Query=H,
    u_assign([:, Proof, Premise], I),
    [synthesize, [:, Proof, Premise], Axiom, Rule, K]=I.

</span>

;; Binary rule
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Rule,Query) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=Rule ,
%~                              u_assign( [->,Premise1,Premise2,Conclusion],
%~                                Assign6) ,
%~                              Assign6=_53500 ,
%~                              u_assign([:,Ructor,_53500],Assign_List) ,
%~                              [Rule]=Assign_List ,
%~                              u_assign([Ructor,Proof1,Proof2],Assign8) ,
%~                              Assign8=_53566 ,
%~                              u_assign([:,_53566,Conclusion],VAR_Query) ,
%~                              Query=VAR_Query ,
%~                              u_assign([:,Proof1,Premise1],Assign_List3) ,
%~                              [ synthesize,
%~                                [:,Proof1,Premise1], Axiom,Rule,K] =
%~                                Assign_List3 ,
%~                              u_assign([:,Proof2,Premise2],Assign_List4) ,
%~                              [ synthesize,
%~                                [:,Proof2,Premise2], Axiom,Rule,K] =
%~                                Assign_List4)]
%~ [convert(_3546),head_preconds_into_body((synthesize(Query,Axiom,Rule,_3496,Query):-(u_assign(['S',K],_3500),_3500=_3496),(((u_assign([->,Premise1,Premise2,Conclusion],_3602),_3602=_3598),u_assign([:,Ructor,_3598],_3570)),[Rule]=_3570),(((u_assign([Ructor,Proof1,Proof2],_3688),_3688=_3684),u_assign([:,_3684,Conclusion],_3662)),Query=_3662),(u_assign([:,Proof1,Premise1],_3754),[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]=_3754),u_assign([:,Proof2,Premise2],_3796),[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]=_3796))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,['S',K]],['let*',[[[:,Ructor,[->,Premise1,Premise2,Conclusion]],[Rule]],[[:,[Ructor,Proof1,Proof2],Conclusion],Query],[[:,Proof1,Premise1],[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]],[[:,Proof2,Premise2],[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise1 $Premise2 $Conclusion)) 
          ($Rule)) 
        ( (: 
            ($Ructor $Proof1 $Proof2) $Conclusion) $Query) 
        ( (: $Proof1 $Premise1) 
          (synthesize 
            (: $Proof1 $Premise1) $Axiom $Rule $K)) 
        ( (: $Proof2 $Premise2) 
          (synthesize 
            (: $Proof2 $Premise2) $Axiom $Rule $K))) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, A, Query) :-
    u_assign(['S', K], B),
    B=A,
    ( u_assign([->, Premise1, Premise2, Conclusion], C),
      C=D,
      u_assign([:, Ructor, D], E)
    ),
    [Rule]=E,
    ( u_assign([Ructor, Proof1, Proof2], F),
      F=G,
      u_assign([:, G, Conclusion], H)
    ),
    Query=H,
    u_assign([:, Proof1, Premise1], I),
    [synthesize, [:, Proof1, Premise1], Axiom, Rule, K]=I,
    u_assign([:, Proof2, Premise2], J),
    [synthesize, [:, Proof2, Premise2], Axiom, Rule, K]=J.

</span>

;; Trinary rule
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Rule,Query) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=Rule ,
%~                              u_assign(
%~                                 [ ->, Premise1,Premise2,
%~                                   Premise3,Conclusion],
%~                                 Assign7) ,
%~                              Assign7=_379522 ,
%~                              u_assign([:,Ructor,_379522],Assign_List) ,
%~                              [Rule]=Assign_List ,
%~                              u_assign( [Ructor,Proof1,Proof2,Proof3],
%~                                Assign9) ,
%~                              Assign9=_379588 ,
%~                              u_assign([:,_379588,Conclusion],VAR_Query) ,
%~                              Query=VAR_Query ,
%~                              u_assign([:,Proof1,Premise1],Assign_List3) ,
%~                              [ synthesize,
%~                                [:,Proof1,Premise1], Axiom,Rule,K] =
%~                                Assign_List3 ,
%~                              u_assign([:,Proof2,Premise2],Assign_List4) ,
%~                              [ synthesize,
%~                                [:,Proof2,Premise2], Axiom,Rule,K] =
%~                                Assign_List4 ,
%~                              u_assign([:,Proof3,Premise3],Assign_List5) ,
%~                              [ synthesize,
%~                                [:,Proof3,Premise3], Axiom,Rule,K] =
%~                                Assign_List5)]
%~ [convert(_166418),head_preconds_into_body((synthesize(Query,Axiom,Rule,_165422,Query):-(u_assign(['S',K],_165432),_165432=_165422),(((u_assign([->,Premise1,Premise2,Premise3,Conclusion],_167618),_167618=_167608),u_assign([:,Ructor,_167608],_167002)),[Rule]=_167002),(((u_assign([Ructor,Proof1,Proof2,Proof3],_168814),_168814=_168804),u_assign([:,_168804,Conclusion],_168254)),Query=_168254),(u_assign([:,Proof1,Premise1],_169504),[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]=_169504),(u_assign([:,Proof2,Premise2],_170478),[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]=_170478),u_assign([:,Proof3,Premise3],_171452),[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]=_171452))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,['S',K]],['let*',[[[:,Ructor,[->,Premise1,Premise2,Premise3,Conclusion]],[Rule]],[[:,[Ructor,Proof1,Proof2,Proof3],Conclusion],Query],[[:,Proof1,Premise1],[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]],[[:,Proof2,Premise2],[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]],[[:,Proof3,Premise3],[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise1 $Premise2 $Premise3 $Conclusion)) 
          ($Rule)) 
        ( (: 
            ($Ructor $Proof1 $Proof2 $Proof3) $Conclusion) $Query) 
        ( (: $Proof1 $Premise1) 
          (synthesize 
            (: $Proof1 $Premise1) $Axiom $Rule $K)) 
        ( (: $Proof2 $Premise2) 
          (synthesize 
            (: $Proof2 $Premise2) $Axiom $Rule $K)) 
        ( (: $Proof3 $Premise3) 
          (synthesize 
            (: $Proof3 $Premise3) $Axiom $Rule $K))) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, A, Query) :-
    u_assign(['S', K], B),
    B=A,
    ( u_assign([ ->,
                 Premise1,
                 Premise2,
                 Premise3,
                 Conclusion
               ],
               C),
      C=D,
      u_assign([:, Ructor, D], E)
    ),
    [Rule]=E,
    ( u_assign([Ructor, Proof1, Proof2, Proof3], F),
      F=G,
      u_assign([:, G, Conclusion], H)
    ),
    Query=H,
    u_assign([:, Proof1, Premise1], I),
    [synthesize, [:, Proof1, Premise1], Axiom, Rule, K]=I,
    u_assign([:, Proof2, Premise2], J),
    [synthesize, [:, Proof2, Premise2], Axiom, Rule, K]=J,
    u_assign([:, Proof3, Premise3], K),
    [synthesize, [:, Proof3, Premise3], Axiom, Rule, K]=K.

</span>

;; Quaternary rule
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Rule,Query) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=Rule ,
%~                              u_assign(
%~                                 [ ->, Premise1,Premise2,
%~                                   Premise3,Premise4,
%~                                   Conclusion],
%~                                 Assign8) ,
%~                              Assign8=_246894 ,
%~                              u_assign([:,Ructor,_246894],Assign_List) ,
%~                              [Rule]=Assign_List ,
%~                              u_assign(
%~                                 [ Ructor, Proof1,Proof2,Proof3,
%~                                   Proof4],
%~                                 Assign10) ,
%~                              Assign10=_246960 ,
%~                              u_assign([:,_246960,Conclusion],VAR_Query) ,
%~                              Query=VAR_Query ,
%~                              u_assign([:,Proof1,Premise1],Assign_List3) ,
%~                              [ synthesize,
%~                                [:,Proof1,Premise1], Axiom,Rule,K] =
%~                                Assign_List3 ,
%~                              u_assign([:,Proof2,Premise2],Assign_List4) ,
%~                              [ synthesize,
%~                                [:,Proof2,Premise2], Axiom,Rule,K] =
%~                                Assign_List4 ,
%~                              u_assign([:,Proof3,Premise3],Assign_List5) ,
%~                              [ synthesize,
%~                                [:,Proof3,Premise3], Axiom,Rule,K] =
%~                                Assign_List5 ,
%~                              u_assign([:,Proof4,Premise4],Assign_List6) ,
%~                              [ synthesize,
%~                                [:,Proof4,Premise4], Axiom,Rule,K] =
%~                                Assign_List6)]
%~ [convert(_5122),head_preconds_into_body((synthesize(Query,Axiom,Rule,_4126,Query):-(u_assign(['S',K],_4136),_4136=_4126),(((u_assign([->,Premise1,Premise2,Premise3,Premise4,Conclusion],_6322),_6322=_6312),u_assign([:,Ructor,_6312],_5706)),[Rule]=_5706),(((u_assign([Ructor,Proof1,Proof2,Proof3,Proof4],_7588),_7588=_7578),u_assign([:,_7578,Conclusion],_7028)),Query=_7028),(u_assign([:,Proof1,Premise1],_8348),[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]=_8348),(u_assign([:,Proof2,Premise2],_9322),[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]=_9322),(u_assign([:,Proof3,Premise3],_10296),[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]=_10296),u_assign([:,Proof4,Premise4],_11270),[synthesize,[:,Proof4,Premise4],Axiom,Rule,K]=_11270))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,['S',K]],['let*',[[[:,Ructor,[->,Premise1,Premise2,Premise3,Premise4,Conclusion]],[Rule]],[[:,[Ructor,Proof1,Proof2,Proof3,Proof4],Conclusion],Query],[[:,Proof1,Premise1],[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]],[[:,Proof2,Premise2],[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]],[[:,Proof3,Premise3],[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]],[[:,Proof4,Premise4],[synthesize,[:,Proof4,Premise4],Axiom,Rule,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise1 $Premise2 $Premise3 $Premise4 $Conclusion)) 
          ($Rule)) 
        ( (: 
            ($Ructor $Proof1 $Proof2 $Proof3 $Proof4) $Conclusion) $Query) 
        ( (: $Proof1 $Premise1) 
          (synthesize 
            (: $Proof1 $Premise1) $Axiom $Rule $K)) 
        ( (: $Proof2 $Premise2) 
          (synthesize 
            (: $Proof2 $Premise2) $Axiom $Rule $K)) 
        ( (: $Proof3 $Premise3) 
          (synthesize 
            (: $Proof3 $Premise3) $Axiom $Rule $K)) 
        ( (: $Proof4 $Premise4) 
          (synthesize 
            (: $Proof4 $Premise4) $Axiom $Rule $K))) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, A, Query) :-
    u_assign(['S', K], B),
    B=A,
    ( u_assign([ ->,
                 Premise1,
                 Premise2,
                 Premise3,
                 Premise4,
                 Conclusion
               ],
               C),
      C=D,
      u_assign([:, Ructor, D], E)
    ),
    [Rule]=E,
    ( u_assign([ Ructor,
                 Proof1,
                 Proof2,
                 Proof3,
                 Proof4
               ],
               F),
      F=G,
      u_assign([:, G, Conclusion], H)
    ),
    Query=H,
    u_assign([:, Proof1, Premise1], I),
    [synthesize, [:, Proof1, Premise1], Axiom, Rule, K]=I,
    u_assign([:, Proof2, Premise2], J),
    [synthesize, [:, Proof2, Premise2], Axiom, Rule, K]=J,
    u_assign([:, Proof3, Premise3], K),
    [synthesize, [:, Proof3, Premise3], Axiom, Rule, K]=K,
    u_assign([:, Proof4, Premise4], L),
    [synthesize, [:, Proof4, Premise4], Axiom, Rule, K]=L.

</span>

;; Quintenary rule
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Rule,Query) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=Rule ,
%~                              u_assign(
%~                                 [ ->, Premise1,Premise2,
%~                                   Premise3,Premise4,
%~                                   Premise5,Conclusion],
%~                                 Assign9) ,
%~                              Assign9=_169654 ,
%~                              u_assign([:,Ructor,_169654],Assign_List) ,
%~                              [Rule]=Assign_List ,
%~                              u_assign(
%~                                 [ Ructor, Proof1,Proof2,Proof3,
%~                                   Proof4,Proof5],
%~                                 Assign11) ,
%~                              Assign11=_169720 ,
%~                              u_assign([:,_169720,Conclusion],VAR_Query) ,
%~                              Query=VAR_Query ,
%~                              u_assign([:,Proof1,Premise1],Assign_List3) ,
%~                              [ synthesize,
%~                                [:,Proof1,Premise1], Axiom,Rule,K] =
%~                                Assign_List3 ,
%~                              u_assign([:,Proof2,Premise2],Assign_List4) ,
%~                              [ synthesize,
%~                                [:,Proof2,Premise2], Axiom,Rule,K] =
%~                                Assign_List4 ,
%~                              u_assign([:,Proof3,Premise3],Assign_List5) ,
%~                              [ synthesize,
%~                                [:,Proof3,Premise3], Axiom,Rule,K] =
%~                                Assign_List5 ,
%~                              u_assign([:,Proof4,Premise4],Assign_List6) ,
%~                              [ synthesize,
%~                                [:,Proof4,Premise4], Axiom,Rule,K] =
%~                                Assign_List6 ,
%~                              u_assign([:,Proof5,Premise5],Assign_List7) ,
%~                              [ synthesize,
%~                                [:,Proof5,Premise5], Axiom,Rule,K] =
%~                                Assign_List7)]
%~ [convert(_3932),head_preconds_into_body((synthesize(Query,Axiom,Rule,_3882,Query):-(u_assign(['S',K],_3886),_3886=_3882),(((u_assign([->,Premise1,Premise2,Premise3,Premise4,Premise5,Conclusion],_3988),_3988=_3984),u_assign([:,Ructor,_3984],_3956)),[Rule]=_3956),(((u_assign([Ructor,Proof1,Proof2,Proof3,Proof4,Proof5],_4092),_4092=_4088),u_assign([:,_4088,Conclusion],_4066)),Query=_4066),(u_assign([:,Proof1,Premise1],_4176),[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]=_4176),(u_assign([:,Proof2,Premise2],_4218),[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]=_4218),(u_assign([:,Proof3,Premise3],_4260),[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]=_4260),(u_assign([:,Proof4,Premise4],_4302),[synthesize,[:,Proof4,Premise4],Axiom,Rule,K]=_4302),u_assign([:,Proof5,Premise5],_4344),[synthesize,[:,Proof5,Premise5],Axiom,Rule,K]=_4344))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,['S',K]],['let*',[[[:,Ructor,[->,Premise1,Premise2,Premise3,Premise4,Premise5,Conclusion]],[Rule]],[[:,[Ructor,Proof1,Proof2,Proof3,Proof4,Proof5],Conclusion],Query],[[:,Proof1,Premise1],[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]],[[:,Proof2,Premise2],[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]],[[:,Proof3,Premise3],[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]],[[:,Proof4,Premise4],[synthesize,[:,Proof4,Premise4],Axiom,Rule,K]],[[:,Proof5,Premise5],[synthesize,[:,Proof5,Premise5],Axiom,Rule,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise1 $Premise2 $Premise3 $Premise4 $Premise5 $Conclusion)) 
          ($Rule)) 
        ( (: 
            ($Ructor $Proof1 $Proof2 $Proof3 $Proof4 $Proof5) $Conclusion) $Query) 
        ( (: $Proof1 $Premise1) 
          (synthesize 
            (: $Proof1 $Premise1) $Axiom $Rule $K)) 
        ( (: $Proof2 $Premise2) 
          (synthesize 
            (: $Proof2 $Premise2) $Axiom $Rule $K)) 
        ( (: $Proof3 $Premise3) 
          (synthesize 
            (: $Proof3 $Premise3) $Axiom $Rule $K)) 
        ( (: $Proof4 $Premise4) 
          (synthesize 
            (: $Proof4 $Premise4) $Axiom $Rule $K)) 
        ( (: $Proof5 $Premise5) 
          (synthesize 
            (: $Proof5 $Premise5) $Axiom $Rule $K))) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, A, Query) :-
    u_assign(['S', K], B),
    B=A,
    ( u_assign([ ->,
                 Premise1,
                 Premise2,
                 Premise3,
                 Premise4,
                 Premise5,
                 Conclusion
               ],
               C),
      C=D,
      u_assign([:, Ructor, D], E)
    ),
    [Rule]=E,
    ( u_assign([ Ructor,
                 Proof1,
                 Proof2,
                 Proof3,
                 Proof4,
                 Proof5
               ],
               F),
      F=G,
      u_assign([:, G, Conclusion], H)
    ),
    Query=H,
    u_assign([:, Proof1, Premise1], I),
    [synthesize, [:, Proof1, Premise1], Axiom, Rule, K]=I,
    u_assign([:, Proof2, Premise2], J),
    [synthesize, [:, Proof2, Premise2], Axiom, Rule, K]=J,
    u_assign([:, Proof3, Premise3], K),
    [synthesize, [:, Proof3, Premise3], Axiom, Rule, K]=K,
    u_assign([:, Proof4, Premise4], L),
    [synthesize, [:, Proof4, Premise4], Axiom, Rule, K]=L,
    u_assign([:, Proof5, Premise5], M),
    [synthesize, [:, Proof5, Premise5], Axiom, Rule, K]=M.

</span>

; Evaluation took 2.74 seconds.
<span class="ansi33"> &self

</span><span class="ansi38-000068000">!(import! &kb orientation.kif.metta)

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&kb', 'orientation.kif.metta'], A).

</span>;; Import rule base
;; Auto-generated by suo-kif-to-metta.sh
;; Self-contained SUO-KIF file extracted from
;;
;; https://github.com/ontologyportal/sumo/blob/master/Merge.kif
;;
;; containing knowledge about `orientation`.
%~ [ convert(Convert),
%~   head_preconds_into_body((instance(orientation,'SpatialRelation',_330410):-_330410='True'))]
%~ [convert(_331558),head_preconds_into_body((instance(orientation,'SpatialRelation',_330410):-_330410='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[instance,orientation,'SpatialRelation'])
</span><span class="ansi38-255165000">  (instance orientation SpatialRelation)
</span><span class="ansi38-000082136">  :- dynamic(instance,3).

  instance(orientation, 'SpatialRelation', A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((instance(orientation,'TernaryPredicate',_381638):-_381638='True'))]
%~ [convert(_382786),head_preconds_into_body((instance(orientation,'TernaryPredicate',_381638):-_381638='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[instance,orientation,'TernaryPredicate'])
</span><span class="ansi38-255165000">  (instance orientation TernaryPredicate)
</span><span class="ansi38-000082136">  :- dynamic(instance,3).

  instance(orientation, 'TernaryPredicate', A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((domain(orientation,1,'Object',_432900):-_432900='True'))]
%~ [convert(_434074),head_preconds_into_body((domain(orientation,1,'Object',_432900):-_432900='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[domain,orientation,1,'Object'])
</span><span class="ansi38-255165000">  (domain orientation 1 Object)
</span><span class="ansi38-000082136">  :- dynamic(domain,4).

  domain(orientation, 1, 'Object', A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((domain(orientation,2,'Object',_478672):-_478672='True'))]
%~ [convert(_479846),head_preconds_into_body((domain(orientation,2,'Object',_478672):-_478672='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[domain,orientation,2,'Object'])
</span><span class="ansi38-255165000">  (domain orientation 2 Object)
</span><span class="ansi38-000082136">  :- dynamic(domain,4).

  domain(orientation, 2, 'Object', A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((domain(orientation,3,'PositionalAttribute',_3018):-_3018='True'))]
%~ [convert(_4192),head_preconds_into_body((domain(orientation,3,'PositionalAttribute',_3018):-_3018='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[domain,orientation,3,'PositionalAttribute'])
</span><span class="ansi38-255165000">  (domain orientation 3 PositionalAttribute)
</span><span class="ansi38-000082136">  :- dynamic(domain,4).

  domain(orientation, 3, 'PositionalAttribute', A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( documentation( orientation,
%~                              'EnglishLanguage',  "A general &%Predicate for indicating how two\n&%Objects are oriented with respect to one another.  For example,\n(orientation $OBJ1 $OBJ2 North) means that $OBJ1 is north of $OBJ2, and\n(orientation $OBJ1 $OBJ2 Vertical) means that $OBJ1 is positioned\nvertically with respect to $OBJ2.", A_general_c38_pf_Predicate_for_indicating_how_two_c92_n_c38_pf_Objects_are_oriented_with_respect_to_one_another_c46_For_example_c44_c92_n_c40_orientation_c36_OBJ1_c36_OBJ2_North_c41_means_that_c36_OBJ1_is_north_of_c36_OBJ2_c44_and_c92_n_c40_orientation_c36_OBJ1_c36_OBJ2_Vertical_c41_means_that_c36_OBJ1_is_positioned_c92_nvertically_with_respect_to_c36_OBJ2) :-
%~                              A_general_c38_pf_Predicate_for_indicating_how_two_c92_n_c38_pf_Objects_are_oriented_with_respect_to_one_another_c46_For_example_c44_c92_n_c40_orientation_c36_OBJ1_c36_OBJ2_North_c41_means_that_c36_OBJ1_is_north_of_c36_OBJ2_c44_and_c92_n_c40_orientation_c36_OBJ1_c36_OBJ2_Vertical_c41_means_that_c36_OBJ1_is_positioned_c92_nvertically_with_respect_to_c36_OBJ2='True')]
%~ [convert(_59866),head_preconds_into_body((documentation(orientation,'EnglishLanguage',"A general &%Predicate for indicating how two\n&%Objects are oriented with respect to one another.  For example,\n(orientation $OBJ1 $OBJ2 North) means that $OBJ1 is north of $OBJ2, and\n(orientation $OBJ1 $OBJ2 Vertical) means that $OBJ1 is positioned\nvertically with respect to $OBJ2.",_58692):-_58692='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[documentation,orientation,'EnglishLanguage',"A general &%Predicate for indicating how two\n&%Objects are oriented with respect to one another.  For example,\n(orientation $OBJ1 $OBJ2 North) means that $OBJ1 is north of $OBJ2, and\n(orientation $OBJ1 $OBJ2 Vertical) means that $OBJ1 is positioned\nvertically with respect to $OBJ2."])
</span><span class="ansi38-255165000">  (documentation orientation EnglishLanguage "A general &%Predicate for indicating how two\n&%Objects are oriented with respect to one another.  For example,\n(orientation $OBJ1 $OBJ2 North) means that $OBJ1 is north of $OBJ2, and\n(orientation $OBJ1 $OBJ2 Vertical) means that $OBJ1 is positioned\nvertically with respect to $OBJ2.")
</span><span class="ansi38-000082136">  :- dynamic(documentation,4).

  documentation(orientation,
                'EnglishLanguage',
                "A general &%Predicate for indicating how two\n&%Objects are oriented with respect to one another.  For example,\n(orientation $OBJ1 $OBJ2 North) means that $OBJ1 is north of $OBJ2, and\n(orientation $OBJ1 $OBJ2 Vertical) means that $OBJ1 is positioned\nvertically with respect to $OBJ2.",
                A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â\x9F\¹'(Â_c92_x9F1,Â_c92_x9F,True) :-
%~                              u_assign([orientation,X,Y,'Right'],Assign) ,
%~                              Assign=_366574 ,
%~                              u_assign([orientation,Z,Y,'Left'],Assign4) ,
%~                              Assign4=_366592 ,
%~                              u_assign(['â\x88\§',_366574,_366592],Assign5) ,
%~                              Assign5=Â_c92_x9F1 ,
%~                              u_assign([orientation,X,Z,'Right'],Assign6) ,
%~                              Assign6=Â_c92_x9F ,
%~                              True='True')]
%~ [convert(_263168),head_preconds_into_body(('â\x9F\¹'(_261534,_262090,_261254):-(((((u_assign([orientation,X,Y,'Right'],_261586),_261586=_261576),u_assign([orientation,Z,Y,'Left'],_261816),_261816=_261806),u_assign(['â\x88\§',_261576,_261806],_261544)),_261544=_261534),u_assign([orientation,X,Z,'Right'],_262100),_262100=_262090),_261254='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',['â\x9F\¹',['â\x88\§',[orientation,X,Y,'Right'],[orientation,Z,Y,'Left']],[orientation,X,Z,'Right']])
</span><span class="ansi38-255165000">  (â¹ 
    (â§ 
      (orientation $X $Y Right) 
      (orientation $Z $Y Left)) 
    (orientation $X $Z Right))
</span><span class="ansi38-000082136">  :- dynamic('â\x9F\¹',3).

  'â\u009F¹'(A, B, C) :-
    ( ( u_assign([orientation, X, Y, 'Right'], D),
        D=E,
        u_assign([orientation, Z, Y, 'Left'], F),
        F=G
      ),
      u_assign(['â\u0088§', E, G], H),
      H=A
    ),
    u_assign([orientation, X, Z, 'Right'], I),
    I=B,
    C='True'.

</span>

;; Add instances, extracted from
;;
;; https://github.com/ontologyportal/sumo/blob/master/tests/SP01.kif.tq
;;
;; to test it.
%~ [ convert(Convert),
%~   head_preconds_into_body((instance('A','Object',_388340):-_388340='True'))]
%~ [convert(_389488),head_preconds_into_body((instance('A','Object',_388340):-_388340='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[instance,'A','Object'])
</span><span class="ansi38-255165000">  (instance A Object)
</span><span class="ansi38-000082136">  :- dynamic(instance,3).

  instance('A', 'Object', A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((instance('B','Object',_428696):-_428696='True'))]
%~ [convert(_429844),head_preconds_into_body((instance('B','Object',_428696):-_428696='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[instance,'B','Object'])
</span><span class="ansi38-255165000">  (instance B Object)
</span><span class="ansi38-000082136">  :- dynamic(instance,3).

  instance('B', 'Object', A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((instance('C','Object',_469590):-_469590='True'))]
%~ [convert(_470738),head_preconds_into_body((instance('C','Object',_469590):-_469590='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[instance,'C','Object'])
</span><span class="ansi38-255165000">  (instance C Object)
</span><span class="ansi38-000082136">  :- dynamic(instance,3).

  instance('C', 'Object', A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((orientation('A','B','Right',_2774):-_2774='True'))]
%~ [convert(_2822),head_preconds_into_body((orientation('A','B','Right',_2774):-_2774='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[orientation,'A','B','Right'])
</span><span class="ansi38-255165000">  (orientation A B Right)
</span><span class="ansi38-000082136">  :- dynamic(orientation,4).

  orientation('A', 'B', 'Right', A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((orientation('C','B','Left',_34634):-_34634='True'))]
%~ [convert(_35808),head_preconds_into_body((orientation('C','B','Left',_34634):-_34634='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[orientation,'C','B','Left'])
</span><span class="ansi38-255165000">  (orientation C B Left)
</span><span class="ansi38-000082136">  :- dynamic(orientation,4).

  orientation('C', 'B', 'Left', A) :-
    A='True'.

</span>

; Evaluation took 292.35 ms.
<span class="ansi33"> &kb

</span>;; An example of query would be: does the following
;;
;; (orientation A C Right)
;;
;; hold$
<span class="ansi38-000068000">!(import! &rb "../rule-base.metta")

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&rb', '../rule-base.metta'], A).

</span>;; Label each statement in the knowledge base as a witness of a type,
;; because that is what the synthesizer expects.  For now each witness
;; is defined by using the `WitnessOf` construct.  So for instance the
;; statement
;;
;; (instance A Object)
;;
;; has the corresponding witness
;;
;; (WitnessOf (instance A Object))
;;
;; Then add the labelled statement in the labelled-kb space.
;; Inference rules to operate on SUMO
;; Binary Conjunction Introduction
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&rb',[:,'BinaryConjunctionIntroduction',[->,X,Y,['â\x88\§',X,Y]]])
</span><span class="ansi38-255165000">  (: BinaryConjunctionIntroduction 
    (-> $X $Y 
      (â§ $X $Y)))
</span>

;; Premises
;; Conclusion
;; Trinary Conjunction Introduction
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&rb',[:,'TrinaryConjunctionIntroduction',[->,X,Y,Z,['â\x88\§',X,Y,Z]]])
</span><span class="ansi38-255165000">  (: TrinaryConjunctionIntroduction 
    (-> $X $Y $Z 
      (â§ $X $Y $Z)))
</span>

;; Premises
;; Conclusion
;; Quaternary Conjunction Introduction
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&rb',[:,'QuaternaryConjunctionIntroduction',[->,X,Y,Z,W,['â\x88\§',X,Y,Z,W]]])
</span><span class="ansi38-255165000">  (: QuaternaryConjunctionIntroduction 
    (-> $X $Y $Z $W 
      (â§ $X $Y $Z $W)))
</span>

;; Premises
;; Conclusion
;; Modus Ponens
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&rb',[:,'ModusPonens',[->,['â\x9F\¹',X,Y],X,Y]])
</span><span class="ansi38-255165000">  (: ModusPonens 
    (-> 
      (â¹ $X $Y) $X $Y))
</span>

; Evaluation took 10.45 ms.
<span class="ansi33"> &rb

</span>;; Premises
;; Conclusion
<span class="ansi38-000068000">!(bind! &labelled-kb (new-space))

</span><span class="ansi38-017068017">exec(A) :-
    ['new-space', B],
    B=C,
    u_assign(['bind!', '&labelled-kb', C], A).

</span>; Evaluation took 0.276 ms. (275.80 microseconds) 
<span class="ansi33"> (@ Space ())
 % 'Space'([])

</span><span class="ansi38-000068000">!(match &kb $X (add-atom &labelled-kb (: (WitnessOf $X) $X)))

</span><span class="ansi38-017068017">exec(A) :-
    ( ( ( true,
          u_assign(['WitnessOf', X], B),
          B=C
        ),
        true,
        u_assign([:, C, X], D)
      ),
      D=E,
      u_assign(['add-atom', '&labelled-kb', E], F)
    ),
    F=G,
    u_assign([match, '&kb', X, G], A).

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&labelled-kb',[:,['WitnessOf',[]],[]])
</span><span class="ansi38-255165000">  (: 
    (WitnessOf ()) ())
</span>

; Evaluation took 0.549 ms. (549.40 microseconds) 
<span class="ansi33"> True
</span><span class="ansi32">['X'=[]]
</span>

;; Define knowledge base (called kb but different than &kb)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,kb,[->,'Atom']])
</span><span class="ansi38-255165000">  (: kb 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(([kb,X]:-true))]
%~ [convert(_247596),head_preconds_into_body(([kb,X]:-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[kb],[match,'&labelled-kb',X,X])
</span><span class="ansi38-255165000">  (= 
    (kb) 
    (match &labelled-kb $X $X))
</span><span class="ansi38-000082136">
  [kb, X].

</span>

;; Define rule base (called rb but different than &rb)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,rb,[->,'Atom']])
</span><span class="ansi38-255165000">  (: rb 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(([rb,X]:-true))]
%~ [convert(_293598),head_preconds_into_body(([rb,X]:-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[rb],[match,'&rb',X,X])
</span><span class="ansi38-255165000">  (= 
    (rb) 
    (match &rb $X $X))
</span><span class="ansi38-000082136">
  [rb, X].

</span>

;; Call synthesizer on query (orientation A B Right) (already axiom)
<span class="ansi38-000068000">!(synthesize (: $Proof (orientation A B Right)) kb rb Z)

</span><span class="ansi38-017068017">exec(A) :-
    ( ( true,
        u_assign([orientation, 'A', 'B', 'Right'], B),
        B=C
      ),
      u_assign([:, Proof, C], D),
      D=E
    ),
    true,
    u_assign([synthesize, E, kb, rb, 'Z'], A).

</span>;; Call synthesizer on query (orientation A C Right)
<span class="ansi38-000068000">!(synthesize (: $Proof (orientation A C Right)) kb rb (fromNumber 2))

</span><span class="ansi38-017068017">exec(A) :-
    ( ( true,
        u_assign([orientation, 'A', 'C', 'Right'], B),
        B=C
      ),
      u_assign([:, Proof, C], D),
      D=E
    ),
    ( true,
      u_assign([fromNumber, 2], F)
    ),
    F=G,
    u_assign([synthesize, E, kb, rb, G], A).

</span><span class="ansi32">% 19,873,550 inferences, 3.095 CPU in 3.095 seconds (100% CPU, 6420886 Lips)
</span> (@ = "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/sumo/orientation/orientation-test.metta" 0)
<br/><a href="https://github.com/logicmoo/vspace-metta/blob/main/MeTTaLog.md">Return to Summaries</a><br/>
doing(ansi2html -u < "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/TEE.ansi" > "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/sumo/orientation/orientation-test.html" )

</pre>
</body>

</html>
