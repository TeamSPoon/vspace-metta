<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>
<style type="text/css">
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-015015015 { color: #0F0F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-000082136 { color: #005288; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
.ansi38-000068000 { color: #004400; }
.ansi38-017068017 { color: #114411; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content">
 (@ track_load_into_file "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/sumo/john-carry-flower/john-carry-flower-test.metta")
;; Test reasoning on the content of orientation.kif.metta.  Before
;; running that file, make sure `orientation.kif.metta` has been
;; properly generated.  See `README.md` for more information on how to
;; do that.
;; Import synthesizer
<span class="ansi38-000068000">!(import! &self "../../synthesis/Synthesize.metta")

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&self', '../../synthesis/Synthesize.metta'], A).

</span>;; Import knowledge base
;; Import modules
<span class="ansi38-000068000">!(import! &self "../common/Num.metta")

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&self', '../common/Num.metta'], A).

</span>;; !(import! &self Unify.metta)
;; Enumerate all programs up to a given depth that are consistent with
;; the query, using the given axiom non-deterministic functions and rules.
;;
;; The arguments are:
;;
;; $query: an Atom under the form (: TERM TYPE).  The atom may contain
;;         free variables within TERM and TYPE to form various sort of
;;         queries, such as:
;;         1. Backward chaining: (: $term (Inheritance $x Mammal))
;;         2. Forward chaining: (: ($rule $premise AXIOM) $type)
;;         3. Mixed chaining: (: ($rule $premise AXIOM) (Inheritance $x Mammal))
;;         4. Type checking: (: TERM TYPE)
;;         5. Type inference: (: TERM $type)
;;
;; $axiom: a nullary function to axiom, to non-deterministically pick
;;         up an axiom.  An axiom is an Atom of the form
;;         (: TERM TYPE).
;;
;; $rule: a nullary function to rule, to non-deterministically pick up
;;        a rule.  A rule is a function mapping premises to
;;        conclusion, where premises and conclusion have the form
;;        (: TERM TYPE).
;;
;; $depth: a Nat representing the maximum depth of the generated
;;         programs.
;;
;; TODO: recurse over curried rules instead of duplicating code over
;; tuples.
;; Collection of functions operating on numbers
;; Define max
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,max,[->,A,A,A]])
</span><span class="ansi38-255165000">  (: max 
    (-> $A $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( max(X,Y,Assign_Max_Y) :-
%~                              u_assign([>,X,Y],Assign) ,
%~                              Assign=_102308 ,
%~                              u_assign([if,_102308,X,Y],Assign_Max_Y))]
%~ [convert(_39504),head_preconds_into_body((max(X,Y,_38268):-(u_assign([>,X,Y],_39810),_39810=_39800),u_assign([if,_39800,X,Y],_38268)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[max,X,Y],[if,[>,X,Y],X,Y])
</span><span class="ansi38-255165000">  (= 
    (max $X $Y) 
    (if 
      (> $X $Y) $X $Y))
</span><span class="ansi38-000082136">  :- dynamic(max,3).

  max(X, Y, A) :-
    u_assign([>, X, Y], B),
    B=C,
    u_assign([if, C, X, Y], A).

</span>

;; Define min
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,min,[->,A,A,A]])
</span><span class="ansi38-255165000">  (: min 
    (-> $A $A $A))
</span>

%~ /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/metta_vspace/pyswip/metta_interp.pl:1054 
%~ [ convert(Convert),
%~   head_preconds_into_body( min(X,Y,Assign_Min_Y) :-
%~                              u_assign([<,X,Y],Assign) ,
%~                              Assign=_228056 ,
%~                              u_assign([if,_228056,X,Y],Assign_Min_Y))]
%~ [convert(_169680),head_preconds_into_body((min(X,Y,_168444):-(u_assign([<,X,Y],_169986),_169986=_169976),u_assign([if,_169976,X,Y],_168444)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[min,X,Y],[if,[<,X,Y],X,Y])
</span><span class="ansi38-255165000">  (= 
    (min $X $Y) 
    (if 
      (< $X $Y) $X $Y))
</span><span class="ansi38-000082136">  :- dynamic(min,3).

  min(X, Y, A) :-
    u_assign([<, X, Y], B),
    B=C,
    u_assign([if, C, X, Y], A).

</span>

;; Clamp a number to be within a certain range
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,clamp,[->,A,A,A,A]])
</span><span class="ansi38-255165000">  (: clamp 
    (-> $A $A $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( clamp(X,L,U,Assign_Clamp_U) :-
%~                              u_assign([min,U,X],Assign) ,
%~                              Assign=_351690 ,
%~                              u_assign([max,L,_351690],Assign_Clamp_U))]
%~ [convert(_291350),head_preconds_into_body((clamp(X,L,U,_290044):-(u_assign([min,U,X],_291712),_291712=_291702),u_assign([max,L,_291702],_290044)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[clamp,X,L,U],[max,L,[min,U,X]])
</span><span class="ansi38-255165000">  (= 
    (clamp $X $L $U) 
    (max $L 
      (min $U $X)))
</span><span class="ansi38-000082136">  :- dynamic(clamp,4).

  clamp(X, L, U, A) :-
    u_assign([min, U, X], B),
    B=C,
    u_assign([max, L, C], A).

</span>

;; Define abs
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,abs,[->,A,A]])
</span><span class="ansi38-255165000">  (: abs 
    (-> $A $A))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( abs(X,Assign_Abs_X) :-
%~                              u_assign([<,X,0],Assign) ,
%~                              Assign=_497098 ,
%~                              u_assign([*,-1,X],Assign3) ,
%~                              Assign3=_497116 ,
%~                              u_assign([if,_497098,_497116,X],Assign_Abs_X))]
%~ [convert(_411436),head_preconds_into_body((abs(X,_410270):-((u_assign([<,X,0],_411742),_411742=_411732),u_assign([*,-1,X],_411902),_411902=_411892),u_assign([if,_411732,_411892,X],_410270)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[abs,X],[if,[<,X,0],[*,-1,X],X])
</span><span class="ansi38-255165000">  (= 
    (abs $X) 
    (if 
      (< $X 0) 
      (* -1 $X) $X))
</span><span class="ansi38-000082136">
  abs(X, A) :-
    ( u_assign([<, X, 0], B),
      B=C
    ),
    u_assign([*, -1, X], D),
    D=E,
    u_assign([if, C, E, X], A).

</span>

;; Define <=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,<=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: <= 
    (-> $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( <=(X,Y,Assign_Y) :-
%~                              u_assign([<,X,Y],Assign) ,
%~                              Assign=_161138 ,
%~                              u_assign([==,X,Y],Assign2) ,
%~                              Assign2=_161156 ,
%~                              u_assign([or,_161138,_161156],Assign_Y))]
%~ [convert(_86102),head_preconds_into_body((<=(X,Y,_84866):-((u_assign([<,X,Y],_86408),_86408=_86398),u_assign([==,X,Y],_86612),_86612=_86602),u_assign([or,_86398,_86602],_84866)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[<=,X,Y],[or,[<,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">  (= 
    (<= $X $Y) 
    (or 
      (< $X $Y) 
      (== $X $Y)))
</span><span class="ansi38-000082136">  :- dynamic(<=,3).

  <=(X, Y, A) :-
    ( u_assign([<, X, Y], B),
      B=C
    ),
    u_assign([==, X, Y], D),
    D=E,
    u_assign([or, C, E], A).

</span>

;; Define >=
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,>=,[->,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: >= 
    (-> $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( >=(X,Y,Assign_Y) :-
%~                              u_assign([>,X,Y],Assign) ,
%~                              Assign=_296308 ,
%~                              u_assign([==,X,Y],Assign2) ,
%~                              Assign2=_296326 ,
%~                              u_assign([or,_296308,_296326],Assign_Y))]
%~ [convert(_221272),head_preconds_into_body((>=(X,Y,_220036):-((u_assign([>,X,Y],_221578),_221578=_221568),u_assign([==,X,Y],_221782),_221782=_221772),u_assign([or,_221568,_221772],_220036)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[>=,X,Y],[or,[>,X,Y],[==,X,Y]])
</span><span class="ansi38-255165000">  (= 
    (>= $X $Y) 
    (or 
      (> $X $Y) 
      (== $X $Y)))
</span><span class="ansi38-000082136">  :- dynamic(>=,3).

  >=(X, Y, A) :-
    ( u_assign([>, X, Y], B),
      B=C
    ),
    u_assign([==, X, Y], D),
    D=E,
    u_assign([or, C, E], A).

</span>

;; Define approximately equal
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,approxEq,[->,A,A,A,'Bool']])
</span><span class="ansi38-255165000">  (: approxEq 
    (-> $A $A $A Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( approxEq(X,Y,Epsilon,Assign_ApproxEq_Epsilon) :-
%~                              u_assign([-,X,Y],Assign) ,
%~                              Assign=_442676 ,
%~                              u_assign([abs,_442676],Assign3) ,
%~                              Assign3=_442700 ,
%~                              u_assign([<=,_442700,Epsilon],Assign_ApproxEq_Epsilon))]
%~ [convert(_356436),head_preconds_into_body((approxEq(X,Y,Epsilon,_355130):-(((u_assign([-,X,Y],_356784),_356784=_356774),u_assign([abs,_356774],_356742)),_356742=_356732),u_assign([<=,_356732,Epsilon],_355130)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[approxEq,X,Y,Epsilon],[<=,[abs,[-,X,Y]],Epsilon])
</span><span class="ansi38-255165000">  (= 
    (approxEq $X $Y $Epsilon) 
    (<= 
      (abs 
        (- $X $Y)) $Epsilon))
</span><span class="ansi38-000082136">  :- dynamic(approxEq,4).

  approxEq(X, Y, Epsilon, A) :-
    ( u_assign([-, X, Y], B),
      B=C,
      u_assign([abs, C], D)
    ),
    D=E,
    u_assign([<=, E, Epsilon], A).

</span>

;; Define Nat
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Nat','Type'])
</span><span class="ansi38-255165000">  (: Nat Type)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'Z','Nat'])
</span><span class="ansi38-255165000">  (: Z Nat)
</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'S',[->,'Nat','Nat']])
</span><span class="ansi38-255165000">  (: S 
    (-> Nat Nat))
</span>

;; Define cast functions between Nat and Number
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNumber,[->,'Number','Nat']])
</span><span class="ansi38-255165000">  (: fromNumber 
    (-> Number Nat))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( fromNumber(N,N) :-
%~                              u_assign([<=,N,0],Assign) ,
%~                              Assign=_148352 ,
%~                              u_assign([-,N,1],Assign2) ,
%~                              Assign2=_148394 ,
%~                              u_assign([fromNumber,_148394],Assign3) ,
%~                              Assign3=_148418 ,
%~                              u_assign(['S',_148418],Assign4) ,
%~                              Assign4=_148442 ,
%~                              u_assign([if,_148352,'Z',_148442],N))]
%~ [convert(_25584),head_preconds_into_body((fromNumber(N,_24418):-((u_assign([<=,N,0],_25890),_25890=_25880),((((u_assign([-,N,1],_26146),_26146=_26136),u_assign([fromNumber,_26136],_26104)),_26104=_26094),u_assign(['S',_26094],_26062)),_26062=_26052),u_assign([if,_25880,'Z',_26052],_24418)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNumber,N],[if,[<=,N,0],'Z',['S',[fromNumber,[-,N,1]]]])
</span><span class="ansi38-255165000">  (= 
    (fromNumber $N) 
    (if 
      (<= $N 0) Z 
      (S 
        (fromNumber 
          (- $N 1)))))
</span><span class="ansi38-000082136">  :- dynamic(fromNumber,2).

  fromNumber(N, A) :-
    ( u_assign([<=, N, 0], B),
      B=C
    ),
    ( ( u_assign([-, N, 1], D),
        D=E,
        u_assign([fromNumber, E], F)
      ),
      F=G,
      u_assign(['S', G], H)
    ),
    H=I,
    u_assign([if, C, 'Z', I], A).

</span>

<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,fromNat,[->,'Nat','Number']])
</span><span class="ansi38-255165000">  (: fromNat 
    (-> Nat Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((fromNat('Z',0):-true))]
%~ [convert(_195424),head_preconds_into_body((fromNat('Z',0):-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,'Z'],0)
</span><span class="ansi38-255165000">  (= 
    (fromNat Z) 0)
</span><span class="ansi38-000082136">  :- dynamic(fromNat,2).

  fromNat('Z', 0).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( fromNat(FromNat,FromNat1) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=FromNat ,
%~                              u_assign([fromNat,K],Assign3) ,
%~                              [+,1,Assign3,FromNat1])]
%~ [convert(_240580),head_preconds_into_body((fromNat(_239626,_239346):-(u_assign(['S',K],_239636),_239636=_239626),u_assign([fromNat,K],_240904),[+,1,_240904,_239346]))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[fromNat,['S',K]],[+,1,[fromNat,K]])
</span><span class="ansi38-255165000">  (= 
    (fromNat 
      (S $K)) 
    (+ 1 
      (fromNat $K)))
</span><span class="ansi38-000082136">  :- dynamic(fromNat,2).

  fromNat(A, B) :-
    u_assign(['S', K], C),
    C=A,
    u_assign([fromNat, K], D),
    [+, 1, D, B].

</span>

;; Define a generic less than operator, â©», for Nat.  < cannot be used
;; because it is a built-in, its type is hardwired and cannot be
;; overloaded.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Nat','Nat','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Nat Nat Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('â©»'(_,'Z',_339322):-_339322='False'))]
%~ [convert(_340514),head_preconds_into_body(('â©»'(_,'Z',_339322):-_339322='False'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',_,'Z'],'False')
</span><span class="ansi38-255165000">  (= 
    (â©» $_ Z) False)
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(_, 'Z', A) :-
    A='False'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'('Z',Z,True) :-
%~                              u_assign(['S',_],Assign) ,
%~                              Assign=Z ,
%~                              True='True')]
%~ [convert(_386892),head_preconds_into_body(('â©»'('Z',_385924,_385632):-(u_assign(['S',_],_385934),_385934=_385924),_385632='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»','Z',['S',_]],'True')
</span><span class="ansi38-255165000">  (= 
    (â©» Z 
      (S $_)) True)
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'('Z', A, B) :-
    u_assign(['S', _], C),
    C=A,
    B='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'(Â1,Â,Assign_Â2) :-
%~                              u_assign(['S',X],Assign) ,
%~                              Assign=Â1 ,
%~                              u_assign(['S',Y],Assign4) ,
%~                              Assign4=Â ,
%~                              u_assign(['â©»',X,Y],Assign_Â2))]
%~ [convert(_457934),head_preconds_into_body(('â©»'(_456818,_456952,_456538):-((u_assign(['S',X],_456828),_456828=_456818),u_assign(['S',Y],_456962),_456962=_456952),u_assign(['â©»',X,Y],_456538)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',['S',X],['S',Y]],['â©»',X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» 
      (S $X) 
      (S $Y)) 
    (â©» $X $Y))
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(A, B, C) :-
    ( u_assign(['S', X], D),
      D=A
    ),
    u_assign(['S', Y], E),
    E=B,
    u_assign(['â©»', X, Y], C).

</span>

;; Overload â©» for Number.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â©»',[->,'Number','Number','Bool']])
</span><span class="ansi38-255165000">  (: â©» 
    (-> Number Number Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â©»'(X,Y,Assign_Â_Y) :-
%~                              u_assign([<,X,Y],Assign_Â_Y))]
%~ [convert(_36808),head_preconds_into_body(('â©»'(X,Y,_35572):-u_assign([<,X,Y],_35572)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['â©»',X,Y],[<,X,Y])
</span><span class="ansi38-255165000">  (= 
    (â©» $X $Y) 
    (< $X $Y))
</span><span class="ansi38-000082136">  :- dynamic('â©»',3).

  'â©»'(X, Y, A) :-
    u_assign([<, X, Y], A).

</span>

;; Return the ceiling of a non negative number.  If the number is
;; negative it returns 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,ceil,[->,'Number','Number']])
</span><span class="ansi38-255165000">  (: ceil 
    (-> Number Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ceil(N,Assign_Ceil_N) :-
%~                              u_assign([fromNumber,N],Assign) ,
%~                              Assign=_168266 ,
%~                              u_assign([fromNat,_168266],Assign_Ceil_N))]
%~ [convert(_112564),head_preconds_into_body((ceil(N,_111398):-(u_assign([fromNumber,N],_112870),_112870=_112860),u_assign([fromNat,_112860],_111398)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[ceil,N],[fromNat,[fromNumber,N]])
</span><span class="ansi38-255165000">  (= 
    (ceil $N) 
    (fromNat 
      (fromNumber $N)))
</span><span class="ansi38-000082136">  :- dynamic(ceil,2).

  ceil(N, A) :-
    u_assign([fromNumber, N], B),
    B=C,
    u_assign([fromNat, C], A).

</span>

;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'number->bool',[->,'Number','Bool']])
</span><span class="ansi38-255165000">  (: number->bool 
    (-> Number Bool))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'number->bool'(X,Number_c62_bool_X) :-
%~                              u_assign([<,0,X],Number_c62_bool_X))]
%~ [convert(_209562),head_preconds_into_body(('number->bool'(X,_208396):-u_assign([<,0,X],_208396)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['number->bool',X],[<,0,X])
</span><span class="ansi38-255165000">  (= 
    (number->bool $X) 
    (< 0 $X))
</span><span class="ansi38-000082136">  :- dynamic('number->bool',2).

  'number->bool'(X, A) :-
    u_assign([<, 0, X], A).

</span>

;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'bool->number',[->,'Bool','Number']])
</span><span class="ansi38-255165000">  (: bool->number 
    (-> Bool Number))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('bool->number'('False',0):-true))]
%~ [convert(_280662),head_preconds_into_body(('bool->number'('False',0):-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','False'],0)
</span><span class="ansi38-255165000">  (= 
    (bool->number False) 0)
</span><span class="ansi38-000082136">  :- dynamic('bool->number',2).

  'bool->number'('False', 0).

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(('bool->number'(_317234,1):-is_True(_317234)))]
%~ [convert(_318070),head_preconds_into_body(('bool->number'(_317234,1):-is_True(_317234)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['bool->number','True'],1)
</span><span class="ansi38-255165000">  (= 
    (bool->number True) 1)
</span><span class="ansi38-000082136">  :- dynamic('bool->number',2).

  'bool->number'(A, 1) :-
    is_True(A).

</span>

;; Define a less than type.  Note that it is purposefully different
;; than â©» as it is a type, not an operator.  Inhabitants of (â x y)
;; are proofs that x â©» y == True.  For now â is only axiomatized for
;; Nat.
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,'â\x8D\\x83\',[->,True,True,'Type']])
</span><span class="ansi38-255165000">  (: â 
    (-> $True $True Type))
</span>

;; Zero is always less than the successor of something
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['zero-lt-succ-axiom'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ['zero-lt-succ-axiom',Assign2] :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=_482300 ,
%~                              u_assign(['â\x8D\\x83\','Z',_482300],Assign1) ,
%~                              Assign1=_482330 ,
%~                              u_assign([:,'ZeroLTSucc',_482330],Assign2))]
%~ [convert(_383314),head_preconds_into_body((['zero-lt-succ-axiom',_381474]:-(((u_assign(['S',K],_383686),_383686=_383676),u_assign(['â\x8D\\x83\','Z',_383676],_383632)),_383632=_383622),u_assign([:,'ZeroLTSucc',_383622],_381474)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['zero-lt-succ-axiom'],[:,'ZeroLTSucc',['â\x8D\\x83\','Z',['S',K]]])
</span><span class="ansi38-255165000">  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (â Z 
        (S $K))))
</span><span class="ansi38-000082136">
  ['zero-lt-succ-axiom', A] :-
    ( u_assign(['S', K], B),
      B=C,
      u_assign(['â\u008D\u0083', 'Z', C], D)
    ),
    D=E,
    u_assign([:, 'ZeroLTSucc', E], A).

</span>

;; If x â y then (S x) â (S y)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,['succ-monotonicity-rule'],[->,'Atom']])
</span><span class="ansi38-255165000">  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( ['succ-monotonicity-rule',Assign5] :-
%~                              u_assign(['â\x8D\\x83\',X,Y],Assign) ,
%~                              Assign=_164828 ,
%~                              u_assign(['S',X],Assign1) ,
%~                              Assign1=_164864 ,
%~                              u_assign(['S',Y],Assign2) ,
%~                              Assign2=_164882 ,
%~                              u_assign(['â\x8D\\x83\',_164864,_164882],Assign3) ,
%~                              Assign3=_164912 ,
%~                              u_assign([->,_164828,_164912],Assign4) ,
%~                              Assign4=_164942 ,
%~                              u_assign([:,'SuccMonotonicity',_164942],Assign5))]
%~ [convert(_3528),head_preconds_into_body((['succ-monotonicity-rule',_3506]:-((((u_assign(['â\x8D\\x83\',X,Y],_3880),_3880=_3870),(((u_assign(['S',X],_4126),_4126=_4116),u_assign(['S',Y],_4260),_4260=_4250),u_assign(['â\x8D\\x83\',_4116,_4250],_4084)),_4084=_4074),u_assign([->,_3870,_4074],_3838)),_3838=_3828),u_assign([:,'SuccMonotonicity',_3828],_3506)))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',['succ-monotonicity-rule'],[:,'SuccMonotonicity',[->,['â\x8D\\x83\',X,Y],['â\x8D\\x83\',['S',X],['S',Y]]]])
</span><span class="ansi38-255165000">  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (â $X $Y) 
        (â 
          (S $X) 
          (S $Y)))))
</span><span class="ansi38-000082136">
  ['succ-monotonicity-rule', A] :-
    ( ( u_assign(['â\u008D\u0083', X, Y], B),
        B=C
      ),
      ( ( u_assign(['S', X], D),
          D=E
        ),
        u_assign(['S', Y], F),
        F=G,
        u_assign(['â\u008D\u0083', E, G], H)
      ),
      H=I,
      u_assign([->, C, I], J)
    ),
    J=K,
    u_assign([:, 'SuccMonotonicity', K], A).

</span>

; Evaluation took 1388.53 ms.
<span class="ansi33"> &self

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,synthesize,[->,'Atom',[->,'Atom'],[->,'Atom'],'Nat','Atom']])
</span><span class="ansi38-255165000">  (: synthesize 
    (-> Atom 
      (-> Atom) 
      (-> Atom) Nat Atom))
</span>

;; Nullary rule (axiom)
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Depth,Query) :-
%~                              u_assign([Axiom],VAR_Query) ,
%~                              Query=VAR_Query)]
%~ [convert(_239818),head_preconds_into_body((synthesize(Query,Axiom,Rule,Depth,Query):-u_assign([Axiom],_240122),Query=_240122))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,Depth],[let,Query,[Axiom],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule $Depth) 
    (let $Query 
      ($Axiom) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, Depth, Query) :-
    u_assign([Axiom], A),
    Query=A.

</span>

;; Unary rule
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Rule,Query) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=Rule ,
%~                              u_assign([->,Premise,Conclusion],Assign5) ,
%~                              Assign5=_486608 ,
%~                              u_assign([:,Ructor,_486608],Assign_List) ,
%~                              [Rule]=Assign_List ,
%~                              u_assign([Ructor,Proof],Assign7) ,
%~                              Assign7=_486674 ,
%~                              u_assign([:,_486674,Conclusion],VAR_Query) ,
%~                              Query=VAR_Query ,
%~                              u_assign([:,Proof,Premise],Assign_List3) ,
%~                              [ synthesize,
%~                                [:,Proof,Premise], Axiom,Rule,K] =
%~                                Assign_List3)]
%~ [convert(_339320),head_preconds_into_body((synthesize(Query,Axiom,Rule,_338324,Query):-(u_assign(['S',K],_338334),_338334=_338324),(((u_assign([->,Premise,Conclusion],_340520),_340520=_340510),u_assign([:,Ructor,_340510],_339904)),[Rule]=_339904),(((u_assign([Ructor,Proof],_341576),_341576=_341566),u_assign([:,_341566,Conclusion],_341016)),Query=_341016),u_assign([:,Proof,Premise],_342126),[synthesize,[:,Proof,Premise],Axiom,Rule,K]=_342126))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,['S',K]],['let*',[[[:,Ructor,[->,Premise,Conclusion]],[Rule]],[[:,[Ructor,Proof],Conclusion],Query],[[:,Proof,Premise],[synthesize,[:,Proof,Premise],Axiom,Rule,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise $Conclusion)) 
          ($Rule)) 
        ( (: 
            ($Ructor $Proof) $Conclusion) $Query) 
        ( (: $Proof $Premise) 
          (synthesize 
            (: $Proof $Premise) $Axiom $Rule $K))) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, A, Query) :-
    u_assign(['S', K], B),
    B=A,
    ( u_assign([->, Premise, Conclusion], C),
      C=D,
      u_assign([:, Ructor, D], E)
    ),
    [Rule]=E,
    ( u_assign([Ructor, Proof], F),
      F=G,
      u_assign([:, G, Conclusion], H)
    ),
    Query=H,
    u_assign([:, Proof, Premise], I),
    [synthesize, [:, Proof, Premise], Axiom, Rule, K]=I.

</span>

;; Binary rule
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Rule,Query) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=Rule ,
%~                              u_assign( [->,Premise1,Premise2,Conclusion],
%~                                Assign6) ,
%~                              Assign6=_236956 ,
%~                              u_assign([:,Ructor,_236956],Assign_List) ,
%~                              [Rule]=Assign_List ,
%~                              u_assign([Ructor,Proof1,Proof2],Assign8) ,
%~                              Assign8=_237022 ,
%~                              u_assign([:,_237022,Conclusion],VAR_Query) ,
%~                              Query=VAR_Query ,
%~                              u_assign([:,Proof1,Premise1],Assign_List3) ,
%~                              [ synthesize,
%~                                [:,Proof1,Premise1], Axiom,Rule,K] =
%~                                Assign_List3 ,
%~                              u_assign([:,Proof2,Premise2],Assign_List4) ,
%~                              [ synthesize,
%~                                [:,Proof2,Premise2], Axiom,Rule,K] =
%~                                Assign_List4)]
%~ [convert(_61004),head_preconds_into_body((synthesize(Query,Axiom,Rule,_60008,Query):-(u_assign(['S',K],_60018),_60018=_60008),(((u_assign([->,Premise1,Premise2,Conclusion],_62204),_62204=_62194),u_assign([:,Ructor,_62194],_61588)),[Rule]=_61588),(((u_assign([Ructor,Proof1,Proof2],_63330),_63330=_63320),u_assign([:,_63320,Conclusion],_62770)),Query=_62770),(u_assign([:,Proof1,Premise1],_63950),[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]=_63950),u_assign([:,Proof2,Premise2],_64924),[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]=_64924))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,['S',K]],['let*',[[[:,Ructor,[->,Premise1,Premise2,Conclusion]],[Rule]],[[:,[Ructor,Proof1,Proof2],Conclusion],Query],[[:,Proof1,Premise1],[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]],[[:,Proof2,Premise2],[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise1 $Premise2 $Conclusion)) 
          ($Rule)) 
        ( (: 
            ($Ructor $Proof1 $Proof2) $Conclusion) $Query) 
        ( (: $Proof1 $Premise1) 
          (synthesize 
            (: $Proof1 $Premise1) $Axiom $Rule $K)) 
        ( (: $Proof2 $Premise2) 
          (synthesize 
            (: $Proof2 $Premise2) $Axiom $Rule $K))) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, A, Query) :-
    u_assign(['S', K], B),
    B=A,
    ( u_assign([->, Premise1, Premise2, Conclusion], C),
      C=D,
      u_assign([:, Ructor, D], E)
    ),
    [Rule]=E,
    ( u_assign([Ructor, Proof1, Proof2], F),
      F=G,
      u_assign([:, G, Conclusion], H)
    ),
    Query=H,
    u_assign([:, Proof1, Premise1], I),
    [synthesize, [:, Proof1, Premise1], Axiom, Rule, K]=I,
    u_assign([:, Proof2, Premise2], J),
    [synthesize, [:, Proof2, Premise2], Axiom, Rule, K]=J.

</span>

;; Trinary rule
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Rule,Query) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=Rule ,
%~                              u_assign(
%~                                 [ ->, Premise1,Premise2,
%~                                   Premise3,Conclusion],
%~                                 Assign7) ,
%~                              Assign7=_49348 ,
%~                              u_assign([:,Ructor,_49348],Assign_List) ,
%~                              [Rule]=Assign_List ,
%~                              u_assign( [Ructor,Proof1,Proof2,Proof3],
%~                                Assign9) ,
%~                              Assign9=_49414 ,
%~                              u_assign([:,_49414,Conclusion],VAR_Query) ,
%~                              Query=VAR_Query ,
%~                              u_assign([:,Proof1,Premise1],Assign_List3) ,
%~                              [ synthesize,
%~                                [:,Proof1,Premise1], Axiom,Rule,K] =
%~                                Assign_List3 ,
%~                              u_assign([:,Proof2,Premise2],Assign_List4) ,
%~                              [ synthesize,
%~                                [:,Proof2,Premise2], Axiom,Rule,K] =
%~                                Assign_List4 ,
%~                              u_assign([:,Proof3,Premise3],Assign_List5) ,
%~                              [ synthesize,
%~                                [:,Proof3,Premise3], Axiom,Rule,K] =
%~                                Assign_List5)]
%~ [convert(_3620),head_preconds_into_body((synthesize(Query,Axiom,Rule,_3570,Query):-(u_assign(['S',K],_3574),_3574=_3570),(((u_assign([->,Premise1,Premise2,Premise3,Conclusion],_3676),_3676=_3672),u_assign([:,Ructor,_3672],_3644)),[Rule]=_3644),(((u_assign([Ructor,Proof1,Proof2,Proof3],_3768),_3768=_3764),u_assign([:,_3764,Conclusion],_3742)),Query=_3742),(u_assign([:,Proof1,Premise1],_3840),[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]=_3840),(u_assign([:,Proof2,Premise2],_3882),[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]=_3882),u_assign([:,Proof3,Premise3],_3924),[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]=_3924))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,['S',K]],['let*',[[[:,Ructor,[->,Premise1,Premise2,Premise3,Conclusion]],[Rule]],[[:,[Ructor,Proof1,Proof2,Proof3],Conclusion],Query],[[:,Proof1,Premise1],[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]],[[:,Proof2,Premise2],[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]],[[:,Proof3,Premise3],[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise1 $Premise2 $Premise3 $Conclusion)) 
          ($Rule)) 
        ( (: 
            ($Ructor $Proof1 $Proof2 $Proof3) $Conclusion) $Query) 
        ( (: $Proof1 $Premise1) 
          (synthesize 
            (: $Proof1 $Premise1) $Axiom $Rule $K)) 
        ( (: $Proof2 $Premise2) 
          (synthesize 
            (: $Proof2 $Premise2) $Axiom $Rule $K)) 
        ( (: $Proof3 $Premise3) 
          (synthesize 
            (: $Proof3 $Premise3) $Axiom $Rule $K))) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, A, Query) :-
    u_assign(['S', K], B),
    B=A,
    ( u_assign([ ->,
                 Premise1,
                 Premise2,
                 Premise3,
                 Conclusion
               ],
               C),
      C=D,
      u_assign([:, Ructor, D], E)
    ),
    [Rule]=E,
    ( u_assign([Ructor, Proof1, Proof2, Proof3], F),
      F=G,
      u_assign([:, G, Conclusion], H)
    ),
    Query=H,
    u_assign([:, Proof1, Premise1], I),
    [synthesize, [:, Proof1, Premise1], Axiom, Rule, K]=I,
    u_assign([:, Proof2, Premise2], J),
    [synthesize, [:, Proof2, Premise2], Axiom, Rule, K]=J,
    u_assign([:, Proof3, Premise3], K),
    [synthesize, [:, Proof3, Premise3], Axiom, Rule, K]=K.

</span>

;; Quaternary rule
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Rule,Query) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=Rule ,
%~                              u_assign(
%~                                 [ ->, Premise1,Premise2,
%~                                   Premise3,Premise4,
%~                                   Conclusion],
%~                                 Assign8) ,
%~                              Assign8=_436442 ,
%~                              u_assign([:,Ructor,_436442],Assign_List) ,
%~                              [Rule]=Assign_List ,
%~                              u_assign(
%~                                 [ Ructor, Proof1,Proof2,Proof3,
%~                                   Proof4],
%~                                 Assign10) ,
%~                              Assign10=_436508 ,
%~                              u_assign([:,_436508,Conclusion],VAR_Query) ,
%~                              Query=VAR_Query ,
%~                              u_assign([:,Proof1,Premise1],Assign_List3) ,
%~                              [ synthesize,
%~                                [:,Proof1,Premise1], Axiom,Rule,K] =
%~                                Assign_List3 ,
%~                              u_assign([:,Proof2,Premise2],Assign_List4) ,
%~                              [ synthesize,
%~                                [:,Proof2,Premise2], Axiom,Rule,K] =
%~                                Assign_List4 ,
%~                              u_assign([:,Proof3,Premise3],Assign_List5) ,
%~                              [ synthesize,
%~                                [:,Proof3,Premise3], Axiom,Rule,K] =
%~                                Assign_List5 ,
%~                              u_assign([:,Proof4,Premise4],Assign_List6) ,
%~                              [ synthesize,
%~                                [:,Proof4,Premise4], Axiom,Rule,K] =
%~                                Assign_List6)]
%~ [convert(_195282),head_preconds_into_body((synthesize(Query,Axiom,Rule,_194286,Query):-(u_assign(['S',K],_194296),_194296=_194286),(((u_assign([->,Premise1,Premise2,Premise3,Premise4,Conclusion],_196482),_196482=_196472),u_assign([:,Ructor,_196472],_195866)),[Rule]=_195866),(((u_assign([Ructor,Proof1,Proof2,Proof3,Proof4],_197748),_197748=_197738),u_assign([:,_197738,Conclusion],_197188)),Query=_197188),(u_assign([:,Proof1,Premise1],_198508),[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]=_198508),(u_assign([:,Proof2,Premise2],_199482),[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]=_199482),(u_assign([:,Proof3,Premise3],_200456),[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]=_200456),u_assign([:,Proof4,Premise4],_201430),[synthesize,[:,Proof4,Premise4],Axiom,Rule,K]=_201430))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,['S',K]],['let*',[[[:,Ructor,[->,Premise1,Premise2,Premise3,Premise4,Conclusion]],[Rule]],[[:,[Ructor,Proof1,Proof2,Proof3,Proof4],Conclusion],Query],[[:,Proof1,Premise1],[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]],[[:,Proof2,Premise2],[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]],[[:,Proof3,Premise3],[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]],[[:,Proof4,Premise4],[synthesize,[:,Proof4,Premise4],Axiom,Rule,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise1 $Premise2 $Premise3 $Premise4 $Conclusion)) 
          ($Rule)) 
        ( (: 
            ($Ructor $Proof1 $Proof2 $Proof3 $Proof4) $Conclusion) $Query) 
        ( (: $Proof1 $Premise1) 
          (synthesize 
            (: $Proof1 $Premise1) $Axiom $Rule $K)) 
        ( (: $Proof2 $Premise2) 
          (synthesize 
            (: $Proof2 $Premise2) $Axiom $Rule $K)) 
        ( (: $Proof3 $Premise3) 
          (synthesize 
            (: $Proof3 $Premise3) $Axiom $Rule $K)) 
        ( (: $Proof4 $Premise4) 
          (synthesize 
            (: $Proof4 $Premise4) $Axiom $Rule $K))) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, A, Query) :-
    u_assign(['S', K], B),
    B=A,
    ( u_assign([ ->,
                 Premise1,
                 Premise2,
                 Premise3,
                 Premise4,
                 Conclusion
               ],
               C),
      C=D,
      u_assign([:, Ructor, D], E)
    ),
    [Rule]=E,
    ( u_assign([ Ructor,
                 Proof1,
                 Proof2,
                 Proof3,
                 Proof4
               ],
               F),
      F=G,
      u_assign([:, G, Conclusion], H)
    ),
    Query=H,
    u_assign([:, Proof1, Premise1], I),
    [synthesize, [:, Proof1, Premise1], Axiom, Rule, K]=I,
    u_assign([:, Proof2, Premise2], J),
    [synthesize, [:, Proof2, Premise2], Axiom, Rule, K]=J,
    u_assign([:, Proof3, Premise3], K),
    [synthesize, [:, Proof3, Premise3], Axiom, Rule, K]=K,
    u_assign([:, Proof4, Premise4], L),
    [synthesize, [:, Proof4, Premise4], Axiom, Rule, K]=L.

</span>

;; Quintenary rule
%~ [ convert(Convert),
%~   head_preconds_into_body( synthesize(Query,Axiom,Rule,Rule,Query) :-
%~                              u_assign(['S',K],Assign) ,
%~                              Assign=Rule ,
%~                              u_assign(
%~                                 [ ->, Premise1,Premise2,
%~                                   Premise3,Premise4,
%~                                   Premise5,Conclusion],
%~                                 Assign9) ,
%~                              Assign9=_354592 ,
%~                              u_assign([:,Ructor,_354592],Assign_List) ,
%~                              [Rule]=Assign_List ,
%~                              u_assign(
%~                                 [ Ructor, Proof1,Proof2,Proof3,
%~                                   Proof4,Proof5],
%~                                 Assign11) ,
%~                              Assign11=_354658 ,
%~                              u_assign([:,_354658,Conclusion],VAR_Query) ,
%~                              Query=VAR_Query ,
%~                              u_assign([:,Proof1,Premise1],Assign_List3) ,
%~                              [ synthesize,
%~                                [:,Proof1,Premise1], Axiom,Rule,K] =
%~                                Assign_List3 ,
%~                              u_assign([:,Proof2,Premise2],Assign_List4) ,
%~                              [ synthesize,
%~                                [:,Proof2,Premise2], Axiom,Rule,K] =
%~                                Assign_List4 ,
%~                              u_assign([:,Proof3,Premise3],Assign_List5) ,
%~                              [ synthesize,
%~                                [:,Proof3,Premise3], Axiom,Rule,K] =
%~                                Assign_List5 ,
%~                              u_assign([:,Proof4,Premise4],Assign_List6) ,
%~                              [ synthesize,
%~                                [:,Proof4,Premise4], Axiom,Rule,K] =
%~                                Assign_List6 ,
%~                              u_assign([:,Proof5,Premise5],Assign_List7) ,
%~                              [ synthesize,
%~                                [:,Proof5,Premise5], Axiom,Rule,K] =
%~                                Assign_List7)]
%~ [convert(_87964),head_preconds_into_body((synthesize(Query,Axiom,Rule,_86968,Query):-(u_assign(['S',K],_86978),_86978=_86968),(((u_assign([->,Premise1,Premise2,Premise3,Premise4,Premise5,Conclusion],_89164),_89164=_89154),u_assign([:,Ructor,_89154],_88548)),[Rule]=_88548),(((u_assign([Ructor,Proof1,Proof2,Proof3,Proof4,Proof5],_90500),_90500=_90490),u_assign([:,_90490,Conclusion],_89940)),Query=_89940),(u_assign([:,Proof1,Premise1],_91330),[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]=_91330),(u_assign([:,Proof2,Premise2],_92304),[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]=_92304),(u_assign([:,Proof3,Premise3],_93278),[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]=_93278),(u_assign([:,Proof4,Premise4],_94252),[synthesize,[:,Proof4,Premise4],Axiom,Rule,K]=_94252),u_assign([:,Proof5,Premise5],_95226),[synthesize,[:,Proof5,Premise5],Axiom,Rule,K]=_95226))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[synthesize,Query,Axiom,Rule,['S',K]],['let*',[[[:,Ructor,[->,Premise1,Premise2,Premise3,Premise4,Premise5,Conclusion]],[Rule]],[[:,[Ructor,Proof1,Proof2,Proof3,Proof4,Proof5],Conclusion],Query],[[:,Proof1,Premise1],[synthesize,[:,Proof1,Premise1],Axiom,Rule,K]],[[:,Proof2,Premise2],[synthesize,[:,Proof2,Premise2],Axiom,Rule,K]],[[:,Proof3,Premise3],[synthesize,[:,Proof3,Premise3],Axiom,Rule,K]],[[:,Proof4,Premise4],[synthesize,[:,Proof4,Premise4],Axiom,Rule,K]],[[:,Proof5,Premise5],[synthesize,[:,Proof5,Premise5],Axiom,Rule,K]]],Query])
</span><span class="ansi38-255165000">  (= 
    (synthesize $Query $Axiom $Rule 
      (S $K)) 
    (let* 
      ( ( (: $Ructor 
            (-> $Premise1 $Premise2 $Premise3 $Premise4 $Premise5 $Conclusion)) 
          ($Rule)) 
        ( (: 
            ($Ructor $Proof1 $Proof2 $Proof3 $Proof4 $Proof5) $Conclusion) $Query) 
        ( (: $Proof1 $Premise1) 
          (synthesize 
            (: $Proof1 $Premise1) $Axiom $Rule $K)) 
        ( (: $Proof2 $Premise2) 
          (synthesize 
            (: $Proof2 $Premise2) $Axiom $Rule $K)) 
        ( (: $Proof3 $Premise3) 
          (synthesize 
            (: $Proof3 $Premise3) $Axiom $Rule $K)) 
        ( (: $Proof4 $Premise4) 
          (synthesize 
            (: $Proof4 $Premise4) $Axiom $Rule $K)) 
        ( (: $Proof5 $Premise5) 
          (synthesize 
            (: $Proof5 $Premise5) $Axiom $Rule $K))) $Query))
</span><span class="ansi38-000082136">  :- dynamic(synthesize,5).

  synthesize(Query, Axiom, Rule, A, Query) :-
    u_assign(['S', K], B),
    B=A,
    ( u_assign([ ->,
                 Premise1,
                 Premise2,
                 Premise3,
                 Premise4,
                 Premise5,
                 Conclusion
               ],
               C),
      C=D,
      u_assign([:, Ructor, D], E)
    ),
    [Rule]=E,
    ( u_assign([ Ructor,
                 Proof1,
                 Proof2,
                 Proof3,
                 Proof4,
                 Proof5
               ],
               F),
      F=G,
      u_assign([:, G, Conclusion], H)
    ),
    Query=H,
    u_assign([:, Proof1, Premise1], I),
    [synthesize, [:, Proof1, Premise1], Axiom, Rule, K]=I,
    u_assign([:, Proof2, Premise2], J),
    [synthesize, [:, Proof2, Premise2], Axiom, Rule, K]=J,
    u_assign([:, Proof3, Premise3], K),
    [synthesize, [:, Proof3, Premise3], Axiom, Rule, K]=K,
    u_assign([:, Proof4, Premise4], L),
    [synthesize, [:, Proof4, Premise4], Axiom, Rule, K]=L,
    u_assign([:, Proof5, Premise5], M),
    [synthesize, [:, Proof5, Premise5], Axiom, Rule, K]=M.

</span>

; Evaluation took 2.73 seconds.
<span class="ansi33"> &self

</span><span class="ansi38-000068000">!(import! &kb john-carry-flower.kif.metta)

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&kb', 'john-carry-flower.kif.metta'], A).

</span>;; Import rule base
;; Auto-generated by suo-kif-to-metta.sh
;; Self-contained SUO-KIF file extracted from
;;
;; https://github.com/ontologyportal/sumo/blob/master/Merge.kif
;;
;; containing knowledge about `objectTransferred`.
%~ [ convert(Convert),
%~   head_preconds_into_body( 'â\x9F\¹'(Â_c92_x9F1,Â_c92_x9F,True) :-
%~                              u_assign([subclass,X,Y],Assign) ,
%~                              Assign=_300054 ,
%~                              u_assign([instance,Z,X],Assign4) ,
%~                              Assign4=_300072 ,
%~                              u_assign(['â\x88\§',_300054,_300072],Assign5) ,
%~                              Assign5=Â_c92_x9F1 ,
%~                              u_assign([instance,Z,Y],Assign6) ,
%~                              Assign6=Â_c92_x9F ,
%~                              True='True')]
%~ [convert(_196762),head_preconds_into_body(('â\x9F\¹'(_195206,_195710,_194926):-(((((u_assign([subclass,X,Y],_195258),_195258=_195248),u_assign([instance,Z,X],_195462),_195462=_195452),u_assign(['â\x88\§',_195248,_195452],_195216)),_195216=_195206),u_assign([instance,Z,Y],_195720),_195720=_195710),_194926='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',['â\x9F\¹',['â\x88\§',[subclass,X,Y],[instance,Z,X]],[instance,Z,Y]])
</span><span class="ansi38-255165000">  (â¹ 
    (â§ 
      (subclass $X $Y) 
      (instance $Z $X)) 
    (instance $Z $Y))
</span><span class="ansi38-000082136">  :- dynamic('â\x9F\¹',3).

  'â\u009F¹'(A, B, C) :-
    ( ( u_assign([subclass, X, Y], D),
        D=E,
        u_assign([instance, Z, X], F),
        F=G
      ),
      u_assign(['â\u0088§', E, G], H),
      H=A
    ),
    u_assign([instance, Z, Y], I),
    I=B,
    C='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((instance(objectTransferred,'CaseRole',_331512):-_331512='True'))]
%~ [convert(_332660),head_preconds_into_body((instance(objectTransferred,'CaseRole',_331512):-_331512='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[instance,objectTransferred,'CaseRole'])
</span><span class="ansi38-255165000">  (instance objectTransferred CaseRole)
</span><span class="ansi38-000082136">  :- dynamic(instance,3).

  instance(objectTransferred, 'CaseRole', A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((subrelation(objectTransferred,patient,_383238):-_383238='True'))]
%~ [convert(_384386),head_preconds_into_body((subrelation(objectTransferred,patient,_383238):-_383238='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[subrelation,objectTransferred,patient])
</span><span class="ansi38-255165000">  (subrelation objectTransferred patient)
</span><span class="ansi38-000082136">  :- dynamic(subrelation,3).

  subrelation(objectTransferred, patient, A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((domain(objectTransferred,1,'Transfer',_438906):-_438906='True'))]
%~ [convert(_440080),head_preconds_into_body((domain(objectTransferred,1,'Transfer',_438906):-_438906='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[domain,objectTransferred,1,'Transfer'])
</span><span class="ansi38-255165000">  (domain objectTransferred 1 Transfer)
</span><span class="ansi38-000082136">  :- dynamic(domain,4).

  domain(objectTransferred, 1, 'Transfer', A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((domain(objectTransferred,2,'Object',_491288):-_491288='True'))]
%~ [convert(_492462),head_preconds_into_body((domain(objectTransferred,2,'Object',_491288):-_491288='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[domain,objectTransferred,2,'Object'])
</span><span class="ansi38-255165000">  (domain objectTransferred 2 Object)
</span><span class="ansi38-000082136">  :- dynamic(domain,4).

  domain(objectTransferred, 2, 'Object', A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( format( 'EnglishLanguage',
%~                              objectTransferred,  "the object transferred in %1 is %n %2", The_object_transferred_in_pf_1_is_pf_n_pf_2) :-
%~                              The_object_transferred_in_pf_1_is_pf_n_pf_2='True')]
%~ [convert(_24858),head_preconds_into_body((format('EnglishLanguage',objectTransferred,"the object transferred in %1 is %n %2",_23684):-_23684='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[format,'EnglishLanguage',objectTransferred,"the object transferred in %1 is %n %2"])
</span><span class="ansi38-255165000">  (format EnglishLanguage objectTransferred "the object transferred in %1 is %n %2")
</span><span class="ansi38-000082136">  :- dynamic(format,4).

  format('EnglishLanguage',
         objectTransferred,
         "the object transferred in %1 is %n %2",
         A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( documentation( objectTransferred,
%~                              'EnglishLanguage',  "A relation that specifies the object that\nis transferred during the process.  For example, in a &%Mailing process, the object\ntransferred is a letter or package.", A_relation_that_specifies_the_object_that_c92_nis_transferred_during_the_process_c46_For_example_c44_in_a_c38_pf_Mailing_process_c44_the_object_c92_ntransferred_is_a_letter_or_package) :-
%~                              A_relation_that_specifies_the_object_that_c92_nis_transferred_during_the_process_c46_For_example_c44_in_a_c38_pf_Mailing_process_c44_the_object_c92_ntransferred_is_a_letter_or_package='True')]
%~ [convert(_136844),head_preconds_into_body((documentation(objectTransferred,'EnglishLanguage',"A relation that specifies the object that\nis transferred during the process.  For example, in a &%Mailing process, the object\ntransferred is a letter or package.",_135670):-_135670='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[documentation,objectTransferred,'EnglishLanguage',"A relation that specifies the object that\nis transferred during the process.  For example, in a &%Mailing process, the object\ntransferred is a letter or package."])
</span><span class="ansi38-255165000">  (documentation objectTransferred EnglishLanguage "A relation that specifies the object that\nis transferred during the process.  For example, in a &%Mailing process, the object\ntransferred is a letter or package.")
</span><span class="ansi38-000082136">  :- dynamic(documentation,4).

  documentation(objectTransferred,
                'EnglishLanguage',
                "A relation that specifies the object that\nis transferred during the process.  For example, in a &%Mailing process, the object\ntransferred is a letter or package.",
                A) :-
    A='True'.

</span>

;; (â¹
;;   (objectTransferred $P $OBJ)
;;   (â ($O $D)
;;     (â§
;;       (origin $P $O)
;;       (destination $P $D)
;;       (holdsDuring
;;         (ImmediatePastFn $P)
;;         (located $OBJ $O))
;;       (holdsDuring
;;         (ImmediateFutureFn $P)
;;         (located $OBJ $D)))))
%~ [ convert(Convert),
%~   head_preconds_into_body( 'â\x9F\¹'(Â_c92_x9F1,Â_c92_x9F,True) :-
%~                              u_assign([instance,True,'Transfer'],Assign) ,
%~                              Assign=_429686 ,
%~                              u_assign([objectTransferred,True,O],Assign4) ,
%~                              Assign4=_429710 ,
%~                              u_assign([orientation,O2,O,'Inside'],Assign5) ,
%~                              Assign5=_429728 ,
%~                              u_assign(['â\x88\§',_429686,_429710,_429728],Assign6) ,
%~                              Assign6=Â_c92_x9F1 ,
%~                              u_assign([objectTransferred,True,O2],Assign7) ,
%~                              Assign7=Â_c92_x9F ,
%~                              True='True')]
%~ [convert(_296516),head_preconds_into_body(('â\x9F\¹'(_294746,_295464,_294466):-(((((u_assign([instance,True,'Transfer'],_294798),_294798=_294788),(u_assign([objectTransferred,True,O],_294958),_294958=_294948),u_assign([orientation,O2,O,'Inside'],_295162),_295162=_295152),u_assign(['â\x88\§',_294788,_294948,_295152],_294756)),_294756=_294746),u_assign([objectTransferred,True,O2],_295474),_295474=_295464),_294466='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',['â\x9F\¹',['â\x88\§',[instance,True,'Transfer'],[objectTransferred,True,O],[orientation,O2,O,'Inside']],[objectTransferred,True,O2]])
</span><span class="ansi38-255165000">  (â¹ 
    (â§ 
      (instance $True Transfer) 
      (objectTransferred $True $O) 
      (orientation $O2 $O Inside)) 
    (objectTransferred $True $O2))
</span><span class="ansi38-000082136">  :- dynamic('â\x9F\¹',3).

  'â\u009F¹'(A, B, C) :-
    ( ( u_assign([instance, True, 'Transfer'], D),
        D=E,
        u_assign([objectTransferred, True, O], F),
        F=G,
        u_assign([orientation, O2, O, 'Inside'], H),
        H=I
      ),
      u_assign(['â\u0088§', E, G, I], J),
      J=A
    ),
    u_assign([objectTransferred, True, O2], K),
    K=B,
    C='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body( 'â\x9F\¹'(Â_c92_x9F1,Â_c92_x9F,True) :-
%~                              u_assign([instance,True,'Transfer'],Assign) ,
%~                              Assign=_84410 ,
%~                              u_assign([objectTransferred,True,O],Assign4) ,
%~                              Assign4=_84434 ,
%~                              u_assign([orientation,O2,O,'On'],Assign5) ,
%~                              Assign5=_84452 ,
%~                              u_assign(['â\x88\§',_84410,_84434,_84452],Assign6) ,
%~                              Assign6=Â_c92_x9F1 ,
%~                              u_assign([objectTransferred,True,O2],Assign7) ,
%~                              Assign7=Â_c92_x9F ,
%~                              True='True')]
%~ [convert(_3148),head_preconds_into_body(('â\x9F\¹'(_2880,_3086,_2856):-(((((u_assign([instance,True,'Transfer'],_2910),_2910=_2906),(u_assign([objectTransferred,True,O],_2960),_2960=_2956),u_assign([orientation,O2,O,'On'],_3010),_3010=_3006),u_assign(['â\x88\§',_2906,_2956,_3006],_2884)),_2884=_2880),u_assign([objectTransferred,True,O2],_3090),_3090=_3086),_2856='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',['â\x9F\¹',['â\x88\§',[instance,True,'Transfer'],[objectTransferred,True,O],[orientation,O2,O,'On']],[objectTransferred,True,O2]])
</span><span class="ansi38-255165000">  (â¹ 
    (â§ 
      (instance $True Transfer) 
      (objectTransferred $True $O) 
      (orientation $O2 $O On)) 
    (objectTransferred $True $O2))
</span><span class="ansi38-000082136">  :- dynamic('â\x9F\¹',3).

  'â\u009F¹'(A, B, C) :-
    ( ( u_assign([instance, True, 'Transfer'], D),
        D=E,
        u_assign([objectTransferred, True, O], F),
        F=G,
        u_assign([orientation, O2, O, 'On'], H),
        H=I
      ),
      u_assign(['â\u0088§', E, G, I], J),
      J=A
    ),
    u_assign([objectTransferred, True, O2], K),
    K=B,
    C='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((subclass('Carrying','Transfer',_112704):-_112704='True'))]
%~ [convert(_113852),head_preconds_into_body((subclass('Carrying','Transfer',_112704):-_112704='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[subclass,'Carrying','Transfer'])
</span><span class="ansi38-255165000">  (subclass Carrying Transfer)
</span><span class="ansi38-000082136">  :- dynamic(subclass,3).

  subclass('Carrying', 'Transfer', A) :-
    A='True'.

</span>

;; Add instances of `objectTransferred`, extracted from
;;
;; https://github.com/ontologyportal/sumo/blob/master/tests/SP04.kif.tq
;;
;; to test it.
%~ [ convert(Convert),
%~   head_preconds_into_body((subclass('Flower','PlantAnatomicalStructure',_156914):-_156914='True'))]
%~ [convert(_158062),head_preconds_into_body((subclass('Flower','PlantAnatomicalStructure',_156914):-_156914='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[subclass,'Flower','PlantAnatomicalStructure'])
</span><span class="ansi38-255165000">  (subclass Flower PlantAnatomicalStructure)
</span><span class="ansi38-000082136">  :- dynamic(subclass,3).

  subclass('Flower', 'PlantAnatomicalStructure', A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((instance('Inside','PositionalAttribute',_207850):-_207850='True'))]
%~ [convert(_208998),head_preconds_into_body((instance('Inside','PositionalAttribute',_207850):-_207850='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[instance,'Inside','PositionalAttribute'])
</span><span class="ansi38-255165000">  (instance Inside PositionalAttribute)
</span><span class="ansi38-000082136">  :- dynamic(instance,3).

  instance('Inside', 'PositionalAttribute', A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((subclass('Container','Object',_257062):-_257062='True'))]
%~ [convert(_258210),head_preconds_into_body((subclass('Container','Object',_257062):-_257062='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[subclass,'Container','Object'])
</span><span class="ansi38-255165000">  (subclass Container Object)
</span><span class="ansi38-000082136">  :- dynamic(subclass,3).

  subclass('Container', 'Object', A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((domain(objectTransferred,1,'Transfer',_301160):-_301160='True'))]
%~ [convert(_302334),head_preconds_into_body((domain(objectTransferred,1,'Transfer',_301160):-_301160='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[domain,objectTransferred,1,'Transfer'])
</span><span class="ansi38-255165000">  (domain objectTransferred 1 Transfer)
</span><span class="ansi38-000082136">  :- dynamic(domain,4).

  domain(objectTransferred, 1, 'Transfer', A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((domain(objectTransferred,2,'Object',_345598):-_345598='True'))]
%~ [convert(_346772),head_preconds_into_body((domain(objectTransferred,2,'Object',_345598):-_345598='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[domain,objectTransferred,2,'Object'])
</span><span class="ansi38-255165000">  (domain objectTransferred 2 Object)
</span><span class="ansi38-000082136">  :- dynamic(domain,4).

  domain(objectTransferred, 2, 'Object', A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((instance(objectTransferred,'CaseRole',_389302):-_389302='True'))]
%~ [convert(_390450),head_preconds_into_body((instance(objectTransferred,'CaseRole',_389302):-_389302='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[instance,objectTransferred,'CaseRole'])
</span><span class="ansi38-255165000">  (instance objectTransferred CaseRole)
</span><span class="ansi38-000082136">  :- dynamic(instance,3).

  instance(objectTransferred, 'CaseRole', A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((subrelation(objectTransferred,patient,_432830):-_432830='True'))]
%~ [convert(_433978),head_preconds_into_body((subrelation(objectTransferred,patient,_432830):-_432830='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[subrelation,objectTransferred,patient])
</span><span class="ansi38-255165000">  (subrelation objectTransferred patient)
</span><span class="ansi38-000082136">  :- dynamic(subrelation,3).

  subrelation(objectTransferred, patient, A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((instance('JohnsCarry','Carrying',_480578):-_480578='True'))]
%~ [convert(_481726),head_preconds_into_body((instance('JohnsCarry','Carrying',_480578):-_480578='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[instance,'JohnsCarry','Carrying'])
</span><span class="ansi38-255165000">  (instance JohnsCarry Carrying)
</span><span class="ansi38-000082136">  :- dynamic(instance,3).

  instance('JohnsCarry', 'Carrying', A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((objectTransferred('JohnsCarry','JohnsVase',_2746):-_2746='True'))]
%~ [convert(_3040),head_preconds_into_body((objectTransferred('JohnsCarry','JohnsVase',_2746):-_2746='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[objectTransferred,'JohnsCarry','JohnsVase'])
</span><span class="ansi38-255165000">  (objectTransferred JohnsCarry JohnsVase)
</span><span class="ansi38-000082136">  :- dynamic(objectTransferred,3).

  objectTransferred('JohnsCarry', 'JohnsVase', A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((agent('JohnsCarry','John',_49276):-_49276='True'))]
%~ [convert(_50424),head_preconds_into_body((agent('JohnsCarry','John',_49276):-_49276='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[agent,'JohnsCarry','John'])
</span><span class="ansi38-255165000">  (agent JohnsCarry John)
</span><span class="ansi38-000082136">  :- dynamic(agent,3).

  agent('JohnsCarry', 'John', A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((instance('JohnsFlower','Flower',_89082):-_89082='True'))]
%~ [convert(_90230),head_preconds_into_body((instance('JohnsFlower','Flower',_89082):-_89082='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[instance,'JohnsFlower','Flower'])
</span><span class="ansi38-255165000">  (instance JohnsFlower Flower)
</span><span class="ansi38-000082136">  :- dynamic(instance,3).

  instance('JohnsFlower', 'Flower', A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((instance('JohnsVase','Container',_130828):-_130828='True'))]
%~ [convert(_131976),head_preconds_into_body((instance('JohnsVase','Container',_130828):-_130828='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[instance,'JohnsVase','Container'])
</span><span class="ansi38-255165000">  (instance JohnsVase Container)
</span><span class="ansi38-000082136">  :- dynamic(instance,3).

  instance('JohnsVase', 'Container', A) :-
    A='True'.

</span>

%~ [ convert(Convert),
%~   head_preconds_into_body((orientation('JohnsFlower','JohnsVase','Inside',_175590):-_175590='True'))]
%~ [convert(_176764),head_preconds_into_body((orientation('JohnsFlower','JohnsVase','Inside',_175590):-_175590='True'))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&kb',[orientation,'JohnsFlower','JohnsVase','Inside'])
</span><span class="ansi38-255165000">  (orientation JohnsFlower JohnsVase Inside)
</span><span class="ansi38-000082136">  :- dynamic(orientation,4).

  orientation('JohnsFlower', 'JohnsVase', 'Inside', A) :-
    A='True'.

</span>

; Evaluation took 767.30 ms.
<span class="ansi33"> &kb

</span>;; An example of query would be
;;
;; (query (â§ (instance $C Carrying) (agent $C John) (instance $F Flower) (objectTransferred $C $F)))
<span class="ansi38-000068000">!(import! &rb "../rule-base.metta")

</span><span class="ansi38-017068017">exec(A) :-
    true,
    u_assign(['import!', '&rb', '../rule-base.metta'], A).

</span>;; Label each statement in the knowledge base as a witness of a type,
;; because that is what the synthesizer expects.  For now each witness
;; is defined by using the `WitnessOf` construct.  So for instance the
;; statement
;;
;; (instance A Object)
;;
;; has the corresponding witness
;;
;; (WitnessOf (instance A Object))
;;
;; Then add the labelled statement in the labelled-kb space.
;; Inference rules to operate on SUMO
;; Binary Conjunction Introduction
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&rb',[:,'BinaryConjunctionIntroduction',[->,X,Y,['â\x88\§',X,Y]]])
</span><span class="ansi38-255165000">  (: BinaryConjunctionIntroduction 
    (-> $X $Y 
      (â§ $X $Y)))
</span>

;; Premises
;; Conclusion
;; Trinary Conjunction Introduction
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&rb',[:,'TrinaryConjunctionIntroduction',[->,X,Y,Z,['â\x88\§',X,Y,Z]]])
</span><span class="ansi38-255165000">  (: TrinaryConjunctionIntroduction 
    (-> $X $Y $Z 
      (â§ $X $Y $Z)))
</span>

;; Premises
;; Conclusion
;; Quaternary Conjunction Introduction
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&rb',[:,'QuaternaryConjunctionIntroduction',[->,X,Y,Z,W,['â\x88\§',X,Y,Z,W]]])
</span><span class="ansi38-255165000">  (: QuaternaryConjunctionIntroduction 
    (-> $X $Y $Z $W 
      (â§ $X $Y $Z $W)))
</span>

;; Premises
;; Conclusion
;; Modus Ponens
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&rb',[:,'ModusPonens',[->,['â\x9F\¹',X,Y],X,Y]])
</span><span class="ansi38-255165000">  (: ModusPonens 
    (-> 
      (â¹ $X $Y) $X $Y))
</span>

; Evaluation took 10.99 ms.
<span class="ansi33"> &rb

</span>;; Premises
;; Conclusion
<span class="ansi38-000068000">!(bind! &labelled-kb (new-space))

</span><span class="ansi38-017068017">exec(A) :-
    ['new-space', B],
    B=C,
    u_assign(['bind!', '&labelled-kb', C], A).

</span>; Evaluation took 0.268 ms. (267.90 microseconds) 
<span class="ansi33"> (@ Space ())
 % 'Space'([])

</span><span class="ansi38-000068000">!(match &kb $X (add-atom &labelled-kb (: (WitnessOf $X) $X)))

</span><span class="ansi38-017068017">exec(A) :-
    ( ( ( true,
          u_assign(['WitnessOf', X], B),
          B=C
        ),
        true,
        u_assign([:, C, X], D)
      ),
      D=E,
      u_assign(['add-atom', '&labelled-kb', E], F)
    ),
    F=G,
    u_assign([match, '&kb', X, G], A).

</span><span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&labelled-kb',[:,['WitnessOf',[]],[]])
</span><span class="ansi38-255165000">  (: 
    (WitnessOf ()) ())
</span>

; Evaluation took 0.522 ms. (522.50 microseconds) 
<span class="ansi33"> True
</span><span class="ansi32">['X'=[]]
</span>

;; Define knowledge base (called kb but different than &kb)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,kb,[->,'Atom']])
</span><span class="ansi38-255165000">  (: kb 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(([kb,X]:-true))]
%~ [convert(_482430),head_preconds_into_body(([kb,X]:-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[kb],[match,'&labelled-kb',X,X])
</span><span class="ansi38-255165000">  (= 
    (kb) 
    (match &labelled-kb $X $X))
</span><span class="ansi38-000082136">
  [kb, X].

</span>

;; Define rule base (called rb but different than &rb)
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_atom('&self',[:,rb,[->,'Atom']])
</span><span class="ansi38-255165000">  (: rb 
    (-> Atom))
</span>

%~ [ convert(Convert),
%~   head_preconds_into_body(([rb,X]:-true))]
%~ [convert(_174198),head_preconds_into_body(([rb,X]:-true))]
<span class="ansi38-255165000"></span><span class="ansi38-015015015">  ; Action: load=metta_defn('&self',[rb],[match,'&rb',X,X])
</span><span class="ansi38-255165000">  (= 
    (rb) 
    (match &rb $X $X))
</span><span class="ansi38-000082136">
  [rb, X].

</span>

;; ;; Call synthesizer on query (â§ (instance $C Carrying) (agent $C John))
;; !(synthesize (: $proof (â§ (instance $C Carrying) (agent $C John)))
;;              kb rb (fromNumber 1))
;; ;; Call synthesizer on query (â§ (instance $C Carrying) (agent $C John) (instance $F Flower))
;; !(synthesize (: $proof (â§ (instance $C Carrying) (agent $C John) (instance $F Flower)))
;;              kb rb (fromNumber 2))
;; Call synthesizer on query (instance JohnsCarry Transfer)
;;
;; Should synthesize the following proof tree
;;                                                              ----------------------------     ------------------------------
;;                                                              (subclass Carrying Transfer)     (instance JohnsCarry Carrying)
;;                                                              ---------------------------------------------------------------(BinaryConjunctionIntroduction)
;; (â¹ (â§ (subclass $X $Y) (instance $Z $X)) (instance $Z $Y))  (â§ (subclass Carrying Transfer) (instance JohnsCarry Carrying))
;; ----------------------------------------------------------------------------------------------------------------------------(ModusPonens)
;;                                             (instance JohnsCarry Transfer)
<span class="ansi38-000068000">!(synthesize (: $Proof (instance JohnsCarry Transfer)) kb rb (fromNumber 2))

</span><span class="ansi38-017068017">exec(A) :-
    ( ( true,
        u_assign([instance, 'JohnsCarry', 'Transfer'], B),
        B=C
      ),
      u_assign([:, Proof, C], D),
      D=E
    ),
    ( true,
      u_assign([fromNumber, 2], F)
    ),
    F=G,
    u_assign([synthesize, E, kb, rb, G], A).

</span>;; Call synthesizer on query (â§ (instance JohnsCarry Transfer) (objectTransferred JohnsCarry JohnsVase) (orientation JohnsFlower JohnsVase Inside))
;;
;; Should synthesize the following proof tree
;;
;;
;;                                                              ----------------------------     ------------------------------
;;                                                              (subclass Carrying Transfer)     (instance JohnsCarry Carrying)
;;                                                              ---------------------------------------------------------------(BinaryConjunctionIntroduction)
;; (â¹ (â§ (subclass $X $Y) (instance $Z $X)) (instance $Z $Y))  (â§ (subclass Carrying Transfer) (instance JohnsCarry Carrying))
;; ----------------------------------------------------------------------------------------------------------------------------(ModusPonens)   ----------------------------------------  ------------------------------------------
;;                                             (instance JohnsCarry Transfer)                                                                  (objectTransferred JohnsCarry JohnsVase)  (orientation JohnsFlower JohnsVase Inside)
;;                                             ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------(TrinaryConjunctionIntroduction)
;;                                                                       (â§ (instance JohnsCarry Transfer) (objectTransferred JohnsCarry JohnsVase) (orientation JohnsFlower JohnsVase Inside))
<span class="ansi38-000068000">!(synthesize (: $Proof (â§ (instance JohnsCarry Transfer) (objectTransferred JohnsCarry JohnsVase) (orientation JohnsFlower JohnsVase Inside))) kb rb (fromNumber 3))

</span><span class="ansi38-017068017">exec(A) :-
    ( ( ( ( true,
            u_assign([instance, 'JohnsCarry', 'Transfer'], B)
          ),
          B=C,
          ( true,
            u_assign([objectTransferred, 'JohnsCarry', 'JohnsVase'], D)
          ),
          D=E,
          true,
          u_assign([orientation, 'JohnsFlower', 'JohnsVase', 'Inside'], F),
          F=G
        ),
        u_assign(['â\u0088§', C, E, G], H),
        H=I
      ),
      u_assign([:, Proof, I], J),
      J=K
    ),
    ( true,
      u_assign([fromNumber, 3], L)
    ),
    L=M,
    u_assign([synthesize, K, kb, rb, M], A).

</span>;; Call synthesizer on query (objectTransferred JohnsCarry JohnsFlower)
;;
;; Should synthesize the following proof tree
;;                                                                                                                                       ----------------------------     ------------------------------
;;                                                                                                                                       (subclass Carrying Transfer)     (instance JohnsCarry Carrying)
;;                                                                                                                                       ---------------------------------------------------------------(BinaryConjunctionIntroduction)
;;                                                                          (â¹ (â§ (subclass $X $Y) (instance $Z $X)) (instance $Z $Y))  (â§ (subclass Carrying Transfer) (instance JohnsCarry Carrying))
;;                                                                          ----------------------------------------------------------------------------------------------------------------------------(ModusPonens)   ----------------------------------------  ------------------------------------------
;;                                                                                                                      (instance JohnsCarry Transfer)                                                                  (objectTransferred JohnsCarry JohnsVase)  (orientation JohnsFlower JohnsVase Inside)
;; -----------------------------------------------------------------------------------------------------------------    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------(TrinaryConjunctionIntroduction)
;; (â¹ (â§ (instance $T Transfer) (objectTransferred $T $O) (orientation $O2 $O Inside)) (objectTransferred $T $O2))    (â§ (instance JohnsCarry Transfer) (objectTransferred JohnsCarry JohnsVase) (orientation JohnsFlower JohnsVase Inside))
;; ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------(ModusPonens)
;;                                                                                              (objectTransferred JohnsCarry JohnsFlower)
<span class="ansi38-000068000">!(synthesize (: $Proof (objectTransferred JohnsCarry JohnsFlower)) kb rb (fromNumber 4))

</span><span class="ansi38-017068017">exec(A) :-
    ( ( true,
        u_assign([objectTransferred, 'JohnsCarry', 'JohnsFlower'], B),
        B=C
      ),
      u_assign([:, Proof, C], D),
      D=E
    ),
    ( true,
      u_assign([fromNumber, 4], F)
    ),
    F=G,
    u_assign([synthesize, E, kb, rb, G], A).

</span>;; Call synthesizer on query (â§ (instance $C Carrying)
;;                              (agent $C John)
;;                              (instance $F Flower)
;;                              (objectTransferred $C $F))
;;
;; Should synthesize the following proof tree
;;                                                                                                                                                                                                                                                                              ----------------------------     ------------------------------
;;                                                                                                                                                                                                                                                                              (subclass Carrying Transfer)     (instance JohnsCarry Carrying)
;;                                                                                                                                                                                                                                                                              ---------------------------------------------------------------(BinaryConjunctionIntroduction)
;;                                                                                                                                                                                                                 (â¹ (â§ (subclass $X $Y) (instance $Z $X)) (instance $Z $Y))  (â§ (subclass Carrying Transfer) (instance JohnsCarry Carrying))
;;                                                                                                                                                                                                                 ----------------------------------------------------------------------------------------------------------------------------(ModusPonens)   ----------------------------------------  ------------------------------------------
;;                                                                                                                                                                                                                 (instance JohnsCarry Transfer)                                                                  (objectTransferred JohnsCarry JohnsVase)  (orientation JohnsFlower JohnsVase Inside)
;;                                                                                            -----------------------------------------------------------------------------------------------------------------    -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------(TrinaryConjunctionIntroduction)
;;                                                                                            (â¹ (â§ (instance $T Transfer) (objectTransferred $T $O) (orientation $O2 $O Inside)) (objectTransferred $T $O2))    (â§ (instance JohnsCarry Transfer) (objectTransferred JohnsCarry JohnsVase) (orientation JohnsFlower JohnsVase Inside))
;; ------------------------------   -----------------------   -----------------------------   ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------(ModusPonens)
;; (instance JohnsCarry Carrying)   (agent JohnsCarry John)   (instance JohnsFlower Flower)   (objectTransferred JohnsCarry JohnsFlower)
;; --------------------------------------------------------------------------------------------------------------------------------------(QuaternaryConjuctionIntroduction)
;;  (â§ (instance JohnsCarry Carrying) (agent JohnsCarry John) (instance JohnsFlower Flower) (objectTransferred JohnsCarry JohnsFlower))
;;
;; Corresponding to the MeTTa expression:
;;
;; (: (QuaternaryConjunctionIntroduction (WitnessOf (instance JohnsCarry Carrying))
;;                                       (WitnessOf (agent JohnsCarry John))
;;                                       (WitnessOf (instance JohnsFlower Flower))
;;                                       (ModusPonens (WitnessOf (â¹ (â§ (instance JohnsCarry Transfer) (objectTransferred JohnsCarry JohnsVase) (orientation JohnsFlower JohnsVase Inside)) (objectTransferred JohnsCarry JohnsFlower)))
;;                                                    (TrinaryConjunctionIntroduction (ModusPonens (WitnessOf (â¹ (â§ (subclass Carrying Transfer) (instance JohnsCarry Carrying)) (instance JohnsCarry Transfer)))
;;                                                                                                 (BinaryConjunctionIntroduction (WitnessOf (subclass Carrying Transfer)) (WitnessOf (instance JohnsCarry Carrying))))
;;                                                                                    (WitnessOf (objectTransferred JohnsCarry JohnsVase))
;;                                                                                    (WitnessOf (orientation JohnsFlower JohnsVase Inside)))))
;;    (â§ (instance JohnsCarry Carrying) (agent JohnsCarry John) (instance JohnsFlower Flower) (objectTransferred JohnsCarry JohnsFlower)))
<span class="ansi38-000068000">!(synthesize (: $Proof (â§ (instance $C Carrying) (agent $C John) (instance $False Flower) (objectTransferred $C $False))) kb rb (fromNumber 5))

</span><span class="ansi38-017068017">exec(A) :-
    ( ( ( ( true,
            u_assign([instance, C, 'Carrying'], B)
          ),
          B=C,
          ( true,
            u_assign([agent, C, 'John'], D)
          ),
          D=E,
          ( true,
            u_assign([instance, False, 'Flower'], F)
          ),
          F=G,
          true,
          u_assign([objectTransferred, C, False], H),
          H=I
        ),
        u_assign(['â\u0088§', C, E, G, I], J),
        J=K
      ),
      u_assign([:, Proof, K], L),
      L=M
    ),
    ( true,
      u_assign([fromNumber, 5], N)
    ),
    N=O,
    u_assign([synthesize, M, kb, rb, O], A).

</span><span class="ansi32">% 25,421,802 inferences, 4.513 CPU in 4.513 seconds (100% CPU, 5633607 Lips)
</span> (@ = "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/sumo/john-carry-flower/john-carry-flower-test.metta" 0)
<br/><a href="https://github.com/logicmoo/vspace-metta/blob/main/MeTTaLog.md">Return to Summaries</a><br/>
doing(ansi2html -u < "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/TEE.ansi" > "/opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/vspace-metta/examples/compat/sumo/john-carry-flower/john-carry-flower-test.html" )

</pre>
</body>

</html>
